<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker笔记</title>
    <url>/2024/06/05/Docker%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[基础安装#【可选】centos8配置yum源cd /etc/yum.repos.drm -rf ./*curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-8.repo yum -y clean all #清除所有文件yum -y makecache #建立缓存yum repolist  #查看yum仓库信息# 移除旧版本dockersudo yum remove docker \                  docker-client \                  docker-client-latest \                  docker-common \                  docker-latest \                  docker-latest-logrotate \                  docker-logrotate \                  docker-engine# 配置docker yum源。sudo yum install -y yum-utilssudo yum-config-manager \--add-repo \http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo# 安装 最新 dockersudo yum install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin# 启动&amp; 开机启动docker； enable + start 二合一systemctl enable docker --now#选【1】或者【2】或者【3】# 配置加速【1】sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123;  &quot;registry-mirrors&quot;: [&quot;https://mirror.ccs.tencentyun.com&quot;]&#125;EOF# 配置加速【2】sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123;  &quot;registry-mirrors&quot;: [&quot;https://mirror.ccs.tencentyun.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker# 配置加速【3】sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123;    &quot;registry-mirrors&quot;: [        &quot;https://do.nark.eu.org&quot;,        &quot;https://dc.j8.work&quot;,        &quot;https://docker.m.daocloud.io&quot;,        &quot;https://dockerproxy.com&quot;,        &quot;https://docker.mirrors.ustc.edu.cn&quot;,        &quot;https://docker.nju.edu.cn&quot;    ]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker


如何获取专属镜像加速地址

阿里云 - 容器Hub服务控制台：https://cr.console.aliyun.com/

  .qoaxriukctnz{width:70%}



  .hbbvsmyxrkcy{width:70%}



命令以nginx起手开始学习
#查看运行中的容器docker ps#查看所有容器docker ps -a#搜索镜像docker search nginx#下载镜像docker pull nginx#下载指定版本镜像docker pull nginx:1.26.0#查看所有镜像docker images#删除指定id的镜像docker rmi e784f4560448#运行一个新容器docker run nginx#停止容器docker stop keen_blackwell#启动容器docker start 592#重启容器docker restart 592#查看容器资源占用情况docker stats 592#查看容器日志docker logs 592#删除指定容器docker rm 592#强制删除指定容器docker rm -f 592# 后台启动容器docker run -d --name mynginx nginx# 后台启动并暴露端口docker run -d --name mynginx -p 80:80 nginx# 进入容器内部docker exec -it mynginx /bin/bash# 提交容器变化打成一个新的镜像docker commit -m &quot;update index.html&quot; mynginx mynginx:v1.0# 保存镜像为指定文件docker save -o mynginx.tar mynginx:v1.0# 删除多个镜像docker rmi bde7d154a67f 94543a6c1aef e784f4560448# 加载镜像docker load -i mynginx.tar # 登录 docker hubdocker login# 重新给镜像打标签docker tag mynginx:v1.0 leifengyang/mynginx:v1.0# 推送镜像docker push leifengyang/mynginx:v1.0

存储删除容器时，目录挂载和卷映射里的文件都不会被删除
两种方式，注意区分：

目录挂载： -v /app/nghtml:/usr/share/nginx/html

卷映射：-v ngconf:/etc/nginx
注：卷映射对应的位置统一放在/var/lib/docker/volumes/&lt;volume-name&gt;
如此时就会放在&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;ngconf下


docker run -d -p 99:80 \-v /app/nghtml:/usr/share/nginx/html \-v ngconf:/etc/nginx \--name app03 \nginx#查看所有卷docker volume ls#创建卷docker volume create haha#查看卷详情docker volume inspect ngconf

网络dokcer为每个容器分配唯一ip，使用容器ip+容器端口可以互相访问
通过以下命令可以查看
# linux查看网络ip a# 查看容器的细节docker container inspect &lt;container_name&gt;# 简写docker inspect &lt;container_name&gt;

因为ip由于各种原因可能会变化，而docker0默认不支持主机域名
# 创建网络 docker network --helpdocker network create mynet# 运行时指定网络docker run -d -p 88:80 --name app1 --network mynet nginxdocker run -d -p 99:80 --name app2 --network mynet nginx# 可再查看下容器详情docker inspect app1# 注意，在加入网络时可以通过--alias给容器起别名# 这样该网络内的其它容器可以用别名互相访问！# mysql容器，指定别名为db，另外每一个容器都有一个别名是容器名docker network connect hmall mysql --alias db


  .xsmuoysairhw{width:70%}


创建自定义网络，容器名就是稳定域名
# 在app1内部访问app2的80端口，此时不是暴露在外面的端口（99）curl http://app2:80

Redis主从同步集群
  .alztuyoyjroj{width:70%}


使用bitnami的redis镜像，这里的镜像不需要修改配置文件，只需要定义一些环境变量
bitnami的dockerhub地址

redis单服务启动命令
docker run --name redis -p 6379:6379 -d -e ALLOW_EMPTY_PASSWORD=yes bitnami/redis:latest
#自定义网络docker network create mynet#主节点docker run -d -p 6379:6379 \-v /app/rd1:/bitnami/redis/data \-e REDIS_REPLICATION_MODE=master \-e REDIS_PASSWORD=123456 \--network mynet --name redis01 \bitnami/redis#从节点docker run -d -p 6380:6379 \-v /app/rd2:/bitnami/redis/data \-e REDIS_REPLICATION_MODE=slave \-e REDIS_MASTER_HOST=redis01 \-e REDIS_MASTER_PORT_NUMBER=6379 \-e REDIS_MASTER_PASSWORD=123456 \-e REDIS_PASSWORD=123456 \--network mynet --name redis02 \bitnami/redis

启动Mysql去官方文档寻找三大点：网络、 存储、 环境变量

  .dhcytzqzlciu{width:70%}


因为本地就有mysql，这里暴露的端口就不选3306了
docker run -d -p 3306:3306 \-v /app/myconf:/etc/mysql/conf.d \-v /app/mydata:/var/lib/mysql \-e MYSQL_ROOT_PASSWORD=123456 \mysql

启动PostgreSqldocker run -d \ -p 5432:5432 \ -v /mydata/postgres/pgdata:/var/lib/postgresql/data \ -e POSTGRES_PASSWORD=wqeq \ --name pgsql \ postgres

PostgreSQL 默认只监听 localhost，无法接受外部连接。
解决办法：

修改 PostgreSQL 配置文件（容器中一般路径是 /var/lib/postgresql/data/postgresql.conf）
listen_addresses = &#x27;*&#x27;

修改 pg_hba.conf 文件，添加允许外部访问的规则：
host all all 0.0.0.0/0 md5

重启 PostgreSQL 容器:
docker restart &lt;container_id&gt;

Docker Compose批量管理容器的工具

  .kfaeqdjlnvon{width:70%}


博客实践
  .rvdonxoxxkxd{width:70%}


命令式安装#创建网络docker network create blog#启动mysqldocker run -d -p 3306:3306 \-e MYSQL_ROOT_PASSWORD=123456 \-e MYSQL_DATABASE=wordpress \-v mysql-data:/var/lib/mysql \-v /app/myconf:/etc/mysql/conf.d \--restart always --name mysql \--network blog \mysql:8.0#启动wordpress（开源博客系统）docker run -d -p 8090:80 \-e WORDPRESS_DB_HOST=mysql \-e WORDPRESS_DB_USER=root \-e WORDPRESS_DB_PASSWORD=123456 \-e WORDPRESS_DB_NAME=wordpress \-v wordpress:/var/www/html \--restart always --name wordpress-app \--network blog \wordpress:latest

compose.yaml安装官方参考文档

  .bobfuntbssxm{width:70%}


其实就是参考docker run时候的参数，再在参考文档里面去找对应的语法，对应如图

  .ymtjyhdrlgbo{width:70%}


services:   mysql:    container_name: mysql    image: mysql:8.0    ports:      - &quot;3306:3306&quot; #一个短横线代表一个数组里面的元素    environment: # 数组写法      - MYSQL_ROOT_PASSWORD=123456      - MYSQL_DATABASE=wordpress    volumes:      - mysql-data:/var/lib/mysql      - /app/myconf:/etc/mysql/conf.d    restart: always    networks:      - blog  wordpress:    image: wordpress    ports:      - &quot;8099:80&quot;    environment: # k-v写法      WORDPRESS_DB_HOST: mysql      WORDPRESS_DB_USER: root      WORDPRESS_DB_PASSWORD: 123456      WORDPRESS_DB_NAME: wordpress    volumes:      - wordpress:/var/www/html    restart: always    networks:      - blog    depends_on: #肯定是要mysql启动好了以后才能启动wordpress，所以是依赖mysql      - mysqlvolumes:  mysql-data:  wordpress:networks: #声明网络  blog:

启动：
# up:启动、上线；-d 以后台方式；文件名默认是compose.yaml，如果不是，就要-f指定docker compose -f compose.yaml up -d

“1”代表这个容器启动了一个

  .daqifossemxz{width:70%}




特性
增量更新


修改 Docker Compose 文件。重新启动应用。只会触发修改项的重新启动。


数据不删


默认就算down了容器，所有挂载的卷不会被移除。比较安全



# 增量更新，只更新compose.yaml中改过的部分docker compose -f compose.yaml # down为下线；up为上线【不删除卷】docker compose -f compose.yaml down# 可 docker compose down --helpdocker compose -f compose.yaml down --rmi all -v#【可选】还可指定项目名称docker compose -f compose.yaml -p myapp up -d#查看项目以下的容器docker compose -p myapp ps


  .kpwhuabnskhe{width:70%}




Dockerfile
  .hspcndjjygnk{width:70%}



  .gjrjlvwcsvfr{width:70%}





常见指令
作用



FROM



RUN



CMD



LABEL



EXPOSE



ENV



ADD



COPY



ENTRYPOINT



VOLUME



USER



WORKDIR



ARG



官方参考文档
FROM openjdk:17LABEL author=lcdzzzCOPY app.jar /app.jarEXPOSE 8080ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] #每个空格会分隔数组里面的每个元素，等于 java -jar /app.jar

构建镜像
# -t指定镜像名字  .指定工作目录docker build -f Dockerfile -t myjavaapp:v1.0 .

Docker分层机制
  .bpjlvjkuendj{width:70%}


# 查看构建历史docker image history [image_name]# 查看镜像详情docker image inspect nginx


  .zveehjriwqor{width:70%}




镜像和(多个)容器的关系如下，容器是在镜像基础之上的可读可写层，所以容器删除以后，这一层的东西也是不保存的。而镜像的基础数据还存在磁盘里。

  .yrqdvzivpktd{width:70%}



  .ntkqoywqrame{width:70%}


# -s,--size 陈列全部文件的大小docker ps -s


  .emyikkqzlfda{width:70%}




总结
  .hhtidmmzawwm{width:70%}






]]></content>
  </entry>
  <entry>
    <title>2022操作系统复习</title>
    <url>/2022/05/15/2022%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[操作系统引论定义
os是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充
主要作用提高利用率并为用户和应用程序提供一个简单的接口，便于用户使用
大量的应用软件，都直接依赖于操作系统的支持，取得它所提供的服务

os的目标
方便性
有效性
可扩充性
开放性

os的作用
作为用户和计算机硬件系统之间的接口
作为计算机系统资源的管理者，资源分为【处理机、存储器、IO设备、文件（数据和程序）】
实现了对计算机资源的抽象

操作系统的特征基本特征
并发
共享
虚拟
异步

主要功能处理机管理功能
进程控制
进程同步
进程通信
调度

存储器管理功能
内存分配
内存保护
地址映射
内存扩充

设备管理功能
缓冲管理
设备分配
设备处理

文件管理功能
文件存储空间管理
目录管理
文件读写管理和保护

os和用户之间的接口
用户接口
程序接口

进程的描述和控制程序顺序执行时的特征

顺序性
封闭性
可再现性

并发执行的特征

间断性
失去封闭性
不可再现性

进程和程序的区别


进程
程序



动态
静态


是程序的执行
是有序代码的集合


独立的运行单位，能与其他的进程并发执行
而程序不行


暂时的
永久的


进程的组成包括：程序段、数据块、进程控制块（PCB）



进程定义：进程是进程实体的运行过程，是系统进行分资源分配和调度的一个独立单位
特征：

动态性【【由创建而产生，由调度而执行，因得不到资源的阻塞，由撤销而消亡】
并发性
独立性
异步性【交替相互执行】

三种基本状态

就绪状态
已准备好运行，即进程已分配到除CPU以外的所有必要资源，只要获得CPU，便可立即执行。系统中若有多个进程处于就绪状态，通常将他们按一定的策略【如优先级策略】排成队列，该队列为就绪队列。

执行状态
进程获得CPU。对于时刻而言，在单处理机系统中，只有一个进程处于执行状态。在多处理机系统中，有多个进程处于执行状态。

阻塞状态
指正在执行的进程由于发生某时间（如I&#x2F;O请求、申请缓冲区失败等）暂时无法执行时的状态，亦即进程的执行收到阻塞
此时引起进程调度，OS把处理机分配给另一个就绪进程，而让受阻进程处于暂停状态，一般这种暂停状态称为阻塞状态【等待状态、封锁状态】，阻塞队列


基本状态的转换
除三种基本状态以外还有一个重要操作【挂起操作】

挂起：强迫进程释放分配到的资源，将进程调出到外存
活动：未被挂起的就绪和阻塞状态，称为活动就绪和活动阻塞
静止：被挂起的就绪状态和阻塞状态，为静止就绪和静止阻塞


进程管理中的数据结构
PCB的作用

PCB 是进程存在的唯一标志
使一个在多道程序环境下不能独立运行的程序，成为一个能独立运行的基本单位，成为能与其它进程并发执行的进程

进程同步基本概念
两种形式的制约关系（直接和间接）
临界资源
临界区：每个进程中访问临界资源的那段代码叫临界区
同步机制应遵循的规则：
空闲让进： 交替不行！！！
有效的利用临界资源
有没有“交替”，有了就违反
不能有“轮流访问”的情况，要“按需”


忙则等待： 互斥！！！
保证对临界资源的互斥访问
讲武德，互斥


有限等待   一直在里面等待，一个时间段之内出不来，因为没人通知他能出来
避免“死等”
对于要访问临界资源的进程，要在有限的时间内进入临界区


让权等待 if while …不停访问资源
以免“忙等”
不能平明的问cpu临界资源有没有被已有进程使用，霸占cpu（比如一直循环问）





信号量机制
整型信号量
/*p*/wait(S)&#123;	while(S&lt;=0);	S--;&#125;/*s*/signal(S)&#123;	S++;&#125;

定义为一个用于表示资源数目的整型量S，除初始化外，仅能通过两国和标准原子操作 wait(S) signal(S)来访问，很长时间依赖，这两个操作分别称为P、V操作
缺点：只要s&lt;&#x3D;0，就会不断测试，因此未遵循“让权等待”原则

记录型信号量  解决了”忙等“的问题
采取“让权等待“策略后，有出现了多个策略同时等待同一临界资源的情况。为此，不仅需要一个value变量来表示资源数目，还需要一个进程链表指针list，用于链接所有等待进程
typedef struct&#123;	int value;	struct process_controller_block *list;&#125;semaphore;wait(semaphore *S)&#123;    S-&gt;value--;    if(s-&gt;value&lt;0) block(S-&gt;list);&#125;signal(semaphore *S)&#123;    s-&gt;value++;    if(S-&gt;value&lt;=0) wakeup(S-&gt;list);&#125;

AND信号量 解决了”死锁“的现象
上面的机制仅适用于各进程间只共享一个临界资源的情况，当进程需要几个共享资源时，容易出现死锁现象
AND同步机制：进程需要的所有资源一次性分配给进程，进程使用完后再一起释放。所以之前的wait操作变为了同时wait操作，即Swait（Simultaneous wait）
所以PV操作变为了：Swait(S1,S2,……,Sn)，Ssignal(S1,S2,……,Sn)。

信号量集：
当要求在资源量大于某一下限值时，才予分配，且一次性需要N个某类临界资源时，可以采用信号量集机制(S为信号量，t为该资源的分配下限值，d为进程对该资源的需求值)：
Swait(S1,t1,d1,…..,Sn,tnndn)
Ssinal(S1,t1,d1,…..,Sn,tnndn)
特殊情况：
Swait(S,d,d)：**仅有一个信号量S，每次申请d个资源，但现有资源少于d时，不予分配
Swait(S,1,1)：即为一般的记录型信号量（S&gt;1时），或互斥信号量（S&#x3D;1时）。
Swait(S,1,0)：S≥1时，允许多个进程进行某特定区；S变为0后，阻止任何进程进入特定区。相当于一个可控开关。


信号量的应用p56-57，时间关系，先列出来，不仔细写了

利用信号量实现进程互斥
利用信号量实现前驱关系

经典进程的同步问题生产者-消费者问题哲学家进餐问题读者-写者问题线程为了更好的理解，这里把线程和进程放在一起写

进程是执行的程序，资源分配的最小单位
线程是CPU调度的基本单位
线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。

区别



进程
线程



是拥有资源的最小单位
是调度的最小单位


拥有自己独立的地址空间，每启动一个进程，系统会为其分配地址空间，建立数据来维护代码段、堆栈段、数据段
没有独立的空间地址，它使用相同的地址空间共享数据


cpu切换花费大
cpu切换花费小


创建的开销大
创建的开销小


占用资源大
占用资源小



线程之间通信更方便，同一进程下，线程共享全局变量、静态变量等数据


多进程程序更加安全、生命力更强，一个进程死掉不会影响另一个进程（它拥有独立地址空间）
多线程程序不易维护，一个线程死掉，整个线程就结束了（共享地址空间）


进程保护要求高，开销大，效率相对较低
线程效率就比较高，可以频繁切换


处理机调度与死锁处理机调度的层次和调度算法的目标处理机调度的层次
高级调度（长程调度、作业调度） 调度对象是作业
决定将外存上处于后背队列中的哪几个作业调入内存

低级调度（短程调度、进程调度） 调度对象是进程
决定就绪队列中的哪个进程应获得处理机

中级调度 （内存调度）
提高内存利用率和系统吞吐量


调度算法的目标处理机点都算法的共同目标

资源利用率$$cpu的利用率&#x3D;cpu有效工作时间&#x2F;（cpu有效工作时间+cpu空闲等待时间）$$

公平性

平衡性

策略强制执行


各类时间周转时间&#x3D;完成时间-到达时间
等待时间&#x3D;周转时间-运行时间
带权周转时间&#x3D;周转时间&#x2F;运行时间
作业与作业调度作业作业：一个比程序更为广泛的概念。包含了通常的程序和数据，还配有一份作业说明书
作业步：作业步组成做鱼
JCB作业控制块 ：作业在系统中存在的标志
作业运行的三个阶段和三个状态：

收容、运行、完成 三个阶段
后备、运行、完成 三个状态

作业调度作业调度的任务：

根据JCB中的信息，检查系统能不能满足作业对资源的需求。再通过调度算法，从外存的后背队列中选取某些作业调入内存，并为它们创建进程、分配资源。
每次执行作业调度时，要决定 介绍多少个作业 和接纳哪些作业

调度算法先来先服务作业 (FCFS)first come first served短作业优先 (SJF) short job first优先级调度算法 (PSA) priority scheduling algorithm高响应比优先算法 (HRRN)highest response ratio next
FCFS算法只考虑作业的等待时间，没有考虑作业运行时间，而SJF刚好相反。

HRRN则两者都考虑到了

响应比 （优先权）：这是个动态优先级$$响应比&#x3D;（等待时间+要求服务时间）&#x2F;要求服务时间$$

等待时间+服务时间&#x3D;响应时间$$响应比Rp&#x3D;响应时间&#x2F;要求服务时间$$

↑↑↑就这玩意↑↑↑ 这玩意高的先上处理机


进程调度进程调度的任务
保存处理机和现场信息
按某种算法选取进程
把处理机分配给进程

进程调度方式
非抢占方式
抢占方式

进程调度算法p93
轮转调度算法优先级调度算法多队列调度算法多级反馈队列算法死锁死锁的定义、必要条件、处理方法定义：
产生死锁的必要条件

互斥条件
请求和保持条件
不可抢占条件
循环等待条件

处理方法

预防死锁
避免死锁
检测死锁
解除死锁

预防死锁破坏“请求和保持”条件破坏“不可抢占”条件破坏循环等待条件‘
避免死锁系统安全状态银行家算法（避免死锁）需求矩阵怎么求？
死锁的检测与解除
死锁检测算法：用于检测系统状态，以确定系统中是否发生了死锁
死锁解除算法：当认定了系统已发生死锁，利用解除算法，将系统从死锁状态解脱出来

死锁的检测资源分配图对于进程p来说：出去是请求，进来是分配
死锁定理通过简化资源分配图来检测是当系统处于s状态时，是否为死锁状态
简化方法：依次消除与不阻塞进程相连的边（死锁检测算法），知道无边可小

在资源分配图中，找到一个既不阻塞又非独立的进程节点Pi。顺利情况下，P可以获得资源并运行完毕，最后释放所占有的全部资源。相当于去掉P的请求边和分配边
重复步骤1
经过一系列简化后，如果能使所有的进程节点都称为鼓励节点，则称该图可完全简化

S为死锁的充分条件：当且仅当S状态的资源分配图是不可完全简化的。

若资源分配图中没有环路，则系统中没有死锁；若有，则可能有死锁
若每个资源表中只包含一个资源实例（只有一个资源），则环路是死锁存在的充要条件

死锁的解除方法

抢占资源。从n个进程中抢占足够多的资源，分配给死锁进程。
终止（或撤销进程）。终止一个或多个进程，直到解除死锁状态（代价大）。
进程回退法。

存储器管理时间关系，先挑重点写了
程序的装入和链接用户程序要在系统中运行，必须先装入内存，然后再编程一个可以执行的程序，步骤如下：

编译
链接
装入

程序的装入绝对装入方式可重定位装入方式  又叫静态重定位动态运行时的装入方式 又叫动态重定位程序的链接
静态链接方式
装入时动态链接方式
运行时动态链接方式

连续分配存储管理方式单一连续分配无外部碎片，实现简单
只适用于单用户，有内部碎片
固定分区分配实现简单，无外部碎片
程序太大时，可能所有的分区都不能满足要求，会产生内部碎片，内存利用率低
动态分区分配又称可变分区分配，根据进程实际需要，动态分配内存空间（不会预先划分分区）
无内部碎片，有外部碎片（可用紧凑技术解决）
动态分区分配中的数据结构
空闲分区表
空闲分区链

动态分区分配算法从空闲分区表、链中选出一分区分配给该作业
ps:后面会讲传统的四种分配算法
分区分配操作
分配内存
回收内存

基于顺序搜索的动态分区分配算法所谓顺序搜索，就是一次搜索空闲分区链上的空闲分区，寻找一个大小满足要求的分区
基于顺序搜索的动态分区算法有下面四种

首次适应算法
循环首次适应算法
最佳适应算法（既满足要求，又是最小的空闲分区分配给作业，避免“大材小用”）
最坏适应算法（总是挑选一个最大的空闲区）

分页存储管理方式分页存储管理的基本方法分页为了解决内存碎片
逻辑地址空间中的地址为A，页面大小为L
逻辑地址存在于进程当中
页号P&#x3D;int（A&#x2F;L）
页内地址d&#x3D;A MOD L
地址变化机构基本的地址变化机构用于实现逻辑地址到物理地址的转换
说明：

页表地址F
页表长度M
页号P
页内地址（偏移量）W
内存块号b
页面大小L

步骤：

根据逻辑地址计算出页号和页内地址偏移量

判断页号是否越界

查询页表，找到页号对应的页表项

用内存块号和页内偏移量得到物理地址

物理地址 E&#x3D;b*L+w


访问目标内存单元


具有快表的地址变化机构快表又称“联想寄存器”：用来存放最近访问的页面项表的副本，一种访问速度比内存快很多的告诉缓存
分段存储管理方式具体来说：分段存储管理方式更符合用户和程序员如下多方面的需要
作用

方便编程
信息共享
信息保护
动态增长
动态链接

分段系统的基本原理分段段表地址变化机构分页和分段主要区别


页
段



物理单位
逻辑单位


大小固定
长度不固定


分页的用户程序地址空间是一维的
分段系统中用户程序的地址空间是二维的


虚拟存储器虚拟存储器概述常规存储管理方式的特征和局部性原理常规存储器管理方式的特征
一次性
驻留性

局部性原理
时间局部性（典型的原因是在程序中存在着大量的循环操作）
空间局部性（因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放）

虚拟存储器的基本工作情况
基于局部性原理可知，运行之前没必要把全部装入内存，而仅须将当前要运行的少数页面或段先装入内存（部分调入内存）
程序运行时如果它要访问的页（段）已调入内存，便继续执行
如果程序要访问的页、段尚未调入内存，便发出缺页（段）终端请求
此时OS利用请求调页（段）功能将他们调入内存
如果内存已满，OS利用页（段）置换功能，将内存中不要的页（段）调至盘上

虚拟存储器的定义和特征虚拟存储器的定义所谓虚拟存储器，是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统
虚拟存储器的特征
多次性
对换性
虚拟性

虚拟存储器的实现方法目前，所有的虚拟存储器都是采用下述方式之一实现的
请求分页管理系统就是在分页系统的基础上增加了请求调页功能和页面置换功能的一个页式虚拟存储系统
解决内存不够问题。
请求分段系统类似于上面
请求分页存储管理方式请求分页中的硬件支持p157
请求分页中的内存分配页面调入策略页面置换算法不要的页面换到外存取，需要的调入内存
最佳置换算法先进先出置换算法最近最久未使用算法Clock置换算法（简单版）Clock置换算法（改进版）“抖动”与工作集产生抖动的根本原因：
同时在系统中运行的进程太多，由此分配发给每一个进程的物理块太少，不能满足进程正常运行的基本要求
工作集
基本概念
定义

请求分段存储管理方式请求分段中的硬件支持请求段表机制缺段中断机构地址变换机构分段的共享与保护共享段表共享段表的分配和回收分段保护
越界检查
存储控制检查
环保护机构
一个程序可以访问驻留在相同环或较低特权环（外环）的数据
一个程序可以访问驻留在相同环或较高特权环（内环）的服务



输入输出系统IO系统的功能、模型、接口IO系统的层次接口和模型IO软件的层次结构从上到下分别为

用户层IO软件
设备独立性软件
设备驱动程序
中断处理程序

IO设备和设备控制器IO设备IO设备的类型按速率分配

低速： 几到几百个字节如键盘鼠标

中速：传输速率为每秒几千字节到数万字节如行式打印机，激光打印机

高速：百千到千兆字节


信息交换单位分类：

块设备

字符设备


共享属性：

独占

共享

虚拟


设备控制器主要功能：控制一个或多个IO设备，以实现IO设备和计算机之间的数据交换。他是CPU和IO设备之间的接口
基本功能
接受和识别命令（控制寄存器）
数据交换（数据寄存器）
标识和报告设备状态（状态寄存器）
地址识别（地址译码器）
数据缓冲区
差错控制

设备控制器的组成
设备控制器与处理机的接口
设备控制器与设备的接口
IO逻辑

对IO设备的控制方式即用什么样的方式来控制IO设备的数据读写
使用轮询的可编程IO方式使用中断的可编程IO方式直接存储器访问方式也叫DMA
特点：

数据传输的基本单位是数据块
所传送数据是设备直接送入内存的，或相反
只有一个或多个数据块开始或结束时，才需CPU干预

组成：

主机和DMA控制器的接口
DMA控制器和块设备的接口
IO控制设备的逻辑

IO通道控制方式是对DMA方式的发展，近一步减少cpu的干预
从一个数据块—&gt;到一组数据块
通道程序
类似任务清单，通道是通过执行通道程序并与设备控制器共同实现对IO设备的控制的。
设备分配设备的固有属性

独占设备
共享给设备
虚拟设备（通过假脱机技术将独占设备改造成共享设备）

用户层的IO软件假脱机（Spooling）系统一般在用户层实现
通过假脱机技术，将一台物理IO设备虚拟为多态逻辑IO设备，这样也就允许多个用户共享一台物理设备。
Spooling的组成
输入井和输出井
输入缓冲区和输出缓冲区（中转站）
输入进程和输出进程
井管理程序

Spooling系统的特点
提高了IO速度
将独占设备改造成共享设备
涉嫌了虚拟设备功能

缓冲区管理缓冲器的引入原因：

缓和CPU和IO设备间速度不匹配的矛盾
减少对CPU的中断频率，放宽对CPU中断响应时间的限制
解决数据粒度不匹配的问题
提高CPU和IO设备的并行性

单缓冲区双缓冲区环形缓冲区（循环缓冲区）缓冲池缓冲池管理多个缓冲区
为了方便，一般将缓冲池中具有相同类型的缓冲区链接成一个队列，于是课形成以下三个队列：

空白缓冲队列 emq
输入队列 inq
输出队列 outq

磁盘存储器的性能和调度磁盘性能简述一个盘面有若干磁道，磁道之间有间隔
组成
参考：https://blog.csdn.net/zhanglh046/article/details/115710477

盘面
主轴
磁道
扇区
柱面
磁头臂（机械臂）
磁头
磁盘驱动器
磁盘控制器

早期的磁盘调度算法
先来先服务
最短寻道时间优先

基于扫描的磁盘调度算法
扫描算法
循环扫描算法

文件管理文件和文件系统数据项、记录、文件文件名和类型文件类型
按用途分类
系统文件
用户文件
库文件


按文件中数据的形式分类
源文件
目标文件
可执行文件


按存储的控制属性分类
只执行文件
只读文件
读写文件


按组织形式和处理方式分类
普通文件
目录文件
特殊文件



文件系统的层次结构文件系统的模型可分为三个层次：

最高层：文件系统接口
中间层：对对象操纵和管理的软件集合
最底层：对象及其属性

]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>GaussDB安装及应用</title>
    <url>/2024/11/23/GaussDB%E5%AE%89%E8%A3%85%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[安装openGauss官网
我们选择极简版

  .ixmkgkvlcoet{width:70%}


由于有要求：

普通用户必须有数据库包解压路径、安装路径的读、写和执行操作权限，并且安装路径必须为空。
普通用户对下载的openGauss压缩包有执行权限。

因此我们直接useradd openGauss，在openGauss家目录下对tar.bz2进行解压
useradd openGauss# 把openGauss-5.0.3-CentOS-64bit.tar.bz2 放在/home/openGauss下tar -jxf openGauss-5.0.3-CentOS-64bit.tar.bz2 cd /home/openGauss/simpleInstallchmod +x ./install.sh# 执行install.sh脚本安装openGauss# -w：初始化数据库密码（gs_initdb指定），因安全需要，此项必须设置。# -p：指定openGauss端口号，如不指定，默认为5432。sh install.sh  -w &quot;guadb@123&quot; -p 5432 &amp;&amp;source ~/.bashrc


执行时，如果出现报错“the maximum number of SEMMNI is not correct, the current SEMMNI is xxx. Please check it.”，请使用有root权限的用户执行如下命令。
可以直接切换成root


sysctl -w kernel.sem=&quot;250 85000 250 330&quot; 


接着切换成openGauss用户，再执行一遍sh install.sh  -w &quot;guadb@123&quot; -p 5432 &amp;&amp;source ~/.bashrc
安装后，数据库目录安装路径&#x2F;home&#x2F;openGauss&#x2F;data&#x2F;single_node，其中&#x2F;home&#x2F;openGauss为解压包路径，data&#x2F;single_node为新创建的数据库节点目录。

应用基本命令
# 停止gs_ctl stop -D /home/openGauss/data/single_node# 启动gs_ctl start -D /home/openGauss/data/single_node# 进入命令行 # d postgres：这个选项指定了要连接的数据库名称。在这个例子中，数据库名称是 postgres，这是 PostgreSQL 安装时默认创建的数据库之一。gsql -d postgres -p 5432 



]]></content>
  </entry>
  <entry>
    <title>MybatisPlus</title>
    <url>/2022/06/22/MybatisPlus/</url>
    <content><![CDATA[分页功能配置和依赖spring:  datasource:    driver-class-name: com.mysql.jdbc.Driver    password: wqeq    type: com.alibaba.druid.pool.DruidDataSource    url: jdbc:mysql://localhost:3306/test08?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai    username: rootmybatis-plus:  configuration:    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl


注意：org.apache.ibatis.logging.stdout.StdOutImpl 是加入日志功能，可以返回sql语句供我们查看

maven依赖：
&lt;!-- 引入mybatisPlus --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.4.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;    &lt;version&gt;3.4.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 引入mysql驱动包 --&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;5.1.27&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 引入Druid依赖，阿里巴巴所提供的数据源 --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid&lt;/artifactId&gt;    &lt;version&gt;1.1.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;version&gt;1.18.0&lt;/version&gt;&lt;/dependency&gt;



数据库和实体类数据库：
SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for `user`-- ----------------------------DROP TABLE IF EXISTS `user`;CREATE TABLE `user` (  `id` bigint(20) NOT NULL,  `name` varchar(30) DEFAULT &#x27;null&#x27;,  `age` varchar(50) DEFAULT &#x27;null&#x27;,  `email` varchar(50) DEFAULT &#x27;null&#x27;,  PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=latin1;-- ------------------------------ Records of user-- ----------------------------INSERT INTO `user` VALUES (&#x27;1&#x27;, &#x27;jone&#x27;, &#x27;18&#x27;, &#x27;1&#x27;);INSERT INTO `user` VALUES (&#x27;2&#x27;, &#x27;jack&#x27;, &#x27;20&#x27;, &#x27;2&#x27;);INSERT INTO `user` VALUES (&#x27;3&#x27;, &#x27;TOM&#x27;, &#x27;28&#x27;, &#x27;3&#x27;);INSERT INTO `user` VALUES (&#x27;4&#x27;, &#x27;SANDY&#x27;, &#x27;21&#x27;, &#x27;4&#x27;);INSERT INTO `user` VALUES (&#x27;5&#x27;, &#x27;BILLIE&#x27;, &#x27;24&#x27;, &#x27;5&#x27;);

实体类：
package com.lcdzzz.fenye.pojo;import lombok.*;@Datapublic class User &#123;   private Long id;   private String name;   private Integer age;   private String email;&#125;


使用了lombok简化了实体类的编写

实现config包下的MybatisPlusConfig
@Configuration@MapperScan(&quot;com.lcdzzz.fenye.mapper&quot;)public class MybatisPlusConfig &#123;    /**     * MybatisPlusInterceptor用来配置mybatisplus里面的插件     * @return     */    @Bean    public MybatisPlusInterceptor MybatisPlusInterceptor() &#123;        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));//在插件对象中添加一个内部插件        return interceptor;    &#125;&#125;

mapper层UserMapper
public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125;

测试@SpringBootTestpublic class MyBatisPlusPluginsTest &#123;    @Autowired    private UserMapper userMapper;    @Test    public void testPage()&#123;        Page&lt;User&gt; page = new Page&lt;&gt;(2,3);        userMapper.selectPage(page,null);        System.out.println(page.getRecords());        System.out.println(page.getTotal());        System.out.println(page.getPages());        System.out.println(page.hasNext());        System.out.println(page.hasPrevious());    &#125;&#125;


  .zigqnwinaouj{width:70%}










代码生成器依赖&lt;dependency&gt;          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;          &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;          &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;          &lt;scope&gt;test&lt;/scope&gt;      &lt;/dependency&gt;      &lt;!--mysql驱动--&gt;      &lt;dependency&gt;          &lt;groupId&gt;mysql&lt;/groupId&gt;          &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;          &lt;scope&gt;runtime&lt;/scope&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;com.baomidou&lt;/groupId&gt;          &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;          &lt;version&gt;3.5.1&lt;/version&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;org.freemarker&lt;/groupId&gt;          &lt;artifactId&gt;freemarker&lt;/artifactId&gt;          &lt;version&gt;2.3.31&lt;/version&gt;      &lt;/dependency&gt;      &lt;!--mybatis-plus启动器--&gt;      &lt;dependency&gt;          &lt;groupId&gt;com.baomidou&lt;/groupId&gt;          &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;          &lt;version&gt;3.5.1&lt;/version&gt;      &lt;/dependency&gt;





实现直接用test类
package com.example.demo;import com.baomidou.mybatisplus.generator.FastAutoGenerator;import com.baomidou.mybatisplus.generator.config.OutputFile;import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;import java.util.Collections;public class FastAutoGeneratorTest &#123;    public static void main(String[] args) &#123;        FastAutoGenerator.create(&quot;jdbc:mysql://127.0.0.1:3306/cec_equipment_tracking_system?characterEncoding=utf-8&amp;userSSL=false&quot;, &quot;root&quot;, &quot;wqeq&quot;)                .globalConfig(builder -&gt; &#123;                    builder.author(&quot;lcdzzz&quot;) // 设置作者                            //.enableSwagger() // 开启 swagger 模式                            .fileOverride() // 覆盖已生成文件                            .outputDir(&quot;D://mybatis_plus&quot;); // 指定输出目录                &#125;)                .packageConfig(builder -&gt; &#123;                    builder.parent(&quot;com.lcdzzz&quot;) // 设置父包名                            .moduleName(&quot;mybatisplus&quot;) // 设置父包模块名                            .pathInfo(Collections.singletonMap(OutputFile.mapperXml, &quot;D://mybatis_plus&quot;)); // 设置mapperXml生成路径                &#125;)                .strategyConfig(builder -&gt; &#123;                    builder.addInclude(&quot;deliver&quot;) // 设置需要生成的表名                            .addInclude(&quot;equipment&quot;)                            .addInclude(&quot;project&quot;)                            .addInclude(&quot;quality&quot;)                            .addTablePrefix(&quot;t_&quot;, &quot;c_&quot;); // 设置过滤表前缀                &#125;)                .templateEngine(new FreemarkerTemplateEngine()) // 使用Freemarker引擎模板，默认的是Velocity引擎模板                .execute();    &#125;&#125;

代码生成器(24)依赖&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;    &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;            &lt;groupId&gt;org.freemarker&lt;/groupId&gt;            &lt;artifactId&gt;freemarker&lt;/artifactId&gt;            &lt;version&gt;2.3.28&lt;/version&gt;            &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;

实现package io.github.lcdzzz;import com.baomidou.mybatisplus.generator.FastAutoGenerator;import com.baomidou.mybatisplus.generator.config.OutputFile;import com.baomidou.mybatisplus.generator.config.rules.DbColumnType;import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;import org.junit.jupiter.api.Test;import org.springframework.boot.test.context.SpringBootTest;import java.util.Collections;@SpringBootTestclass DataScopeApplicationTests &#123;    @Test    void contextLoads() &#123;        FastAutoGenerator.create(&quot;jdbc:mysql://127.0.0.1:3306/test06?characterEncoding=utf-8&amp;userSSL=false&quot;, &quot;root&quot;, &quot;wqeq&quot;)                .globalConfig(builder -&gt; &#123;                    builder.author(&quot;lcdzzz&quot;) // 设置作者                            //.enableSwagger() // 开启 swagger 模式                            .fileOverride() // 覆盖已生成文件                            .outputDir(&quot;D://2024tienchinStudy//data_scope//src//main//java&quot;); // 指定输出目录                &#125;)                .packageConfig(builder -&gt; &#123;                    builder.parent(&quot;io.github.lcdzzz&quot;) // 设置父包名//                            .moduleName(&quot;mybatisplus&quot;) // 设置父包模块名                            .pathInfo(Collections.singletonMap(OutputFile.xml, &quot;D://2024tienchinStudy//data_scope//src//main//resources//mapper&quot;)); // 设置mapperXml生成路径                &#125;)                .strategyConfig(builder -&gt; &#123;                    builder.addInclude(&quot;sys_dept&quot;,&quot;sys_role&quot;,&quot;sys_user&quot;) // 设置需要生成的表名                            .addTablePrefix(&quot;sys_&quot;); // 设置过滤表前缀                &#125;)                .templateEngine(new FreemarkerTemplateEngine()) // 使用Freemarker引擎模板，默认的是Velocity引擎模板                .execute();    &#125;&#125;

]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>MybatisPlus</tag>
        <tag>java</tag>
        <tag>springboot</tag>
        <tag>分页</tag>
        <tag>插件</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurity</title>
    <url>/2022/08/01/SpringSecurity%E9%9A%8F%E8%AE%B0/</url>
    <content><![CDATA[SpringSecurity完成基于数据库的认证（登录）
application.yml配置
spring:  datasource:        name: test        url: jdbc:mysql://localhost:3306/javaboy?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai        username: root        password: wqeq        # 使用druid数据源        type: com.alibaba.druid.pool.DruidDataSource        driver-class-name: com.mysql.cj.jdbc.Driver

mysql,mybatis,druid依赖必须有
&lt;dependency&gt;          &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;          &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;          &lt;version&gt;2.2.1&lt;/version&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;mysql&lt;/groupId&gt;          &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;          &lt;scope&gt;runtime&lt;/scope&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;com.alibaba&lt;/groupId&gt;          &lt;artifactId&gt;druid&lt;/artifactId&gt;          &lt;version&gt;1.1.7&lt;/version&gt;      &lt;/dependency&gt;



创建实体类

User类 ：

实现    UserDetails接口，并实现其中的方法(这是个规范，因为每个人设计的用户名和密码不一定都是username和password)

List&lt; Role &gt; roles;变量用于存储user的角色属性

Collection&lt;? enxtend GrandtedAuthority&gt; getAuthorities()方法，用于返回用户所有角色
public class User implements UserDetails &#123;     private Integer id;     private String username;     private String password;     private Boolean enabled;     private Boolean locked;     private List&lt;Role&gt; roles;    public Boolean getLocked() &#123;        return locked;    &#125;    public List&lt;Role&gt; getRoles() &#123;        return roles;    &#125;    public void setRoles(List&lt;Role&gt; roles) &#123;        this.roles = roles;    &#125;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public void setPassword(String password) &#123;        this.password = password;    &#125;    public Boolean getEnabled() &#123;        return enabled;    &#125;    public void setEnabled(Boolean enabled) &#123;        this.enabled = enabled;    &#125;    public void setLocked(Boolean locked) &#123;        this.locked = locked;    &#125;    @Override    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;        List&lt;SimpleGrantedAuthority&gt; authorities = new ArrayList&lt;&gt;();        for (Role role : roles) &#123;            authorities.add(new SimpleGrantedAuthority(&quot;ROLE_&quot;+role.getName()));        &#125;        return authorities;    &#125;    @Override    public String getPassword() &#123;        return password;    &#125;    @Override    public String getUsername() &#123;        return username;    &#125;    @Override    public boolean isAccountNonExpired() &#123; //账户是否未过期        return true;//一般表里会有一个字段表示账户是否过期，但是我们的表里还没有，为了方便起见，默认返回true，也就是未过期    &#125;    @Override    public boolean isAccountNonLocked() &#123;//账户是否未锁定        return !locked;    &#125;    @Override    public boolean isCredentialsNonExpired() &#123;//密码是否未过期        return true;    &#125;    @Override    public boolean isEnabled() &#123;//是否可用        return enabled;    &#125;&#125;


Role类，List&lt; Role &gt; roles;变量用于存储user的角色属性
package com.lcdzzz.mysecuritydb.bean;import java.util.List;public class Role &#123;    private Integer id;    private String name;    private String nameZh;    private List&lt;Role&gt; roles;    public List&lt;Role&gt; getRoles() &#123;        return roles;    &#125;    public void setRoles(List&lt;Role&gt; roles) &#123;        this.roles = roles;    &#125;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getNameZh() &#123;        return nameZh;    &#125;    public void setNameZh(String nameZh) &#123;        this.nameZh = nameZh;    &#125;&#125;



定义mapper层和实现类（service层）

UserMapper

创建service层中的UserService类，实现UserDetailService这个类和它的方法（public UserDetails loadUserByUsername这个方法）
@Servicepublic class UserService implements UserDetailsService &#123;    @Autowired    UserMapper userMapper;    @Override    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;        User user = userMapper.loadUserByUsername(username);        if (user==null)&#123;            throw new UsernameNotFoundException(&quot;用户不存在!&quot;);        &#125;        user.setRoles(userMapper.getUserRolesById(user.getId()));        return user;    &#125;&#125;



用@Autowired注解注入UserMapper对象

在loadUserByUsername来自定义查询用户信息的方法

一个是loadUserByUsername这个方法，如果没有在数据库找到符合条件的数据，则返回null，抛出UsernameNotFoundException异常
一个是getRolesById这个方法，得到用户的角色（身份）信息


在UserMapper中定义方法
@Mapperpublic interface UserMapper  &#123;     User loadUserByUsername(String username);    List&lt;Role&gt; getUserRolesById(Integer id);&#125;



在UserMapper.xml中实现
&lt;mapper namespace=&quot;com.lcdzzz.mysecuritydb.mapper.UserMapper&quot;&gt;    &lt;select id=&quot;loadUserByUsername&quot; resultType=&quot;com.lcdzzz.mysecuritydb.bean.User&quot;&gt;        select * from user where username=#&#123;username&#125;    &lt;/select&gt;    &lt;select id=&quot;getUserRolesById&quot; resultType=&quot;com.lcdzzz.mysecuritydb.bean.Role&quot;&gt;        select * from role where id in (select rid from user_role where uid=#&#123;id&#125;)    &lt;/select&gt;&lt;/mapper&gt;


config层中的SecurityConfig

记得加上@Configuration注解

SecurityConfig继承WebSecurityConfigurerAdapter

来一个protect void configure(AuthenticationManagerBuilder auth) 方法

用@Autowired注解把UserService注入进来

来一个PasswordEncoder passwordEncoder()方法，再return new BCryptPasswordEncoder()，最后加上注解@Bean

在“3”说的方法里写：auth.userDetailService(userService) 来指定使用自定义查询用户信息来完成身份认证;

并且通过protected void configure(HttpSecurity http)方法来定义权限的访问范围
@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;    @Autowired    UserService userService;    @Override    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;        auth.userDetailsService(userService);//指定使用自定义查询用户信息来完成身份认证    &#125;    @Bean    PasswordEncoder passwordEncoder()&#123;        return new BCryptPasswordEncoder();    &#125;    @Bean    RoleHierarchy roleHierarchy() &#123;        RoleHierarchyImpl roleHierarchy = new RoleHierarchyImpl();        String hierarchy = &quot;ROLE_dba &gt; ROLE_admin \n ROLE_admin &gt; ROLE_user&quot;;        roleHierarchy.setHierarchy(hierarchy);        return roleHierarchy;    &#125;    @Override    protected void configure(HttpSecurity http) throws Exception &#123;        http.authorizeRequests()                .antMatchers(&quot;/dba/**&quot;).hasRole(&quot;dba&quot;)                .antMatchers(&quot;/admin/**&quot;).hasRole(&quot;admin&quot;)                .antMatchers(&quot;/user/**&quot;).hasRole(&quot;user&quot;)                .anyRequest().authenticated()                .and()                .formLogin()                .permitAll()                .and()                .csrf().disable();    &#125;&#125;

其中这段代码很重要他代表dba既可以干admin的事情也可以干user的事情；admin可以干user的事情。&#x3D;&#x3D;角色的继承&#x3D;&#x3D;
@Bean    RoleHierarchy roleHierarchy() &#123;        RoleHierarchyImpl roleHierarchy = new RoleHierarchyImpl();        String hierarchy = &quot;ROLE_dba &gt; ROLE_admin \n ROLE_admin &gt; ROLE_user&quot;;        roleHierarchy.setHierarchy(hierarchy);        return roleHierarchy;    &#125;



在controller层写一个HelloController

在porm.xml里配一个resources，指定资源文件目录




动态配置权限（基于数据库）
上面登录完成后，要想通过数据库来动态配置权限。就要定义几个东西

关于MyFilter类：

在config层中创一个 MyFilter类，当然名字是自定义的。去实现 FilterInvocationSecurityMetadataSource并实现其中的三个方法

getAttribute方法的作用：&#x3D;&#x3D;根据请求的地址，分析出来这个地址需要哪些角色&#x3D;&#x3D;

AntPathMacher pathMatcher = new AntPathMatcher() 这个是一个路径匹配符

在这个方法正式运作之前，要在Menu定义一个private List&lt; Role&gt; roles 变量，因为每个menu需要是某个角色才能访问，意思是当前这个menu需要具备哪些角色才能访问

在mapper层来一个MenuMapper类，定义 List&lt; Menu&gt; getAllMenus() 方法

在service层来一个 MenuService ，实现一个 List&lt; Menu&gt; getAllMenu()方法，通过@Autowired把MenuMapper自动装配过来

在MenuMapper中实现。在这里 因为到时候查出来是一对多的关系，所以不能resultType，要使用resultMap

转到MyFilter，用@Autowired把MenuService注入进来

以下是关键代码以及解释：
@Override   /**    * 根据请求的地址，分析出来这个地址需要哪些角色    * 根据需要的角色，拿出来目前“我”具有的角色，比较一下是否具备    */   public Collection&lt;ConfigAttribute&gt; getAttributes(Object o) throws IllegalArgumentException &#123;       String requestUrl = ((FilterInvocation) o).getRequestUrl();//请求的地址       List&lt;Menu&gt; allMenus = menuService.getAllMenus();//得到所有的菜单       for (Menu menu : allMenus) &#123;           if (pathMatcher.match(menu.getPattern(), requestUrl)) &#123;//第一个是规则，第二个是地址，看看是否匹配               List&lt;Role&gt; roles = menu.getRoles();               String[] rolesStr = new String[roles.size()];               for (int i = 0; i &lt; roles.size(); i++) &#123;                   rolesStr[i] = roles.get(i).getName();               &#125;               return SecurityConfig.createList(rolesStr);           &#125;       &#125;       return SecurityConfig.createList(&quot;ROLE_login&quot;);//如果角色是ROLE_login，代表登录之后就可以访问这个资源   &#125;      


关于MyAccessDecisionManager

创建MyAccessDecisionManager类，让它实现AccessDecisionManager接口，并实现里面的方法，记得在类的上面加上@Component注解

以下是关键方法以及代码的解释
@Override   /**    * authentication保存着当前登录的用户的信息。从这里可以知道我有哪些角色    * collection就是MyFilter类中的getAttributes的返回值。从这里可以知道需要哪些角色    */   public void decide(Authentication authentication, Object o, Collection&lt;ConfigAttribute&gt; collection) throws AccessDeniedException, InsufficientAuthenticationException &#123;       for (ConfigAttribute attribute : collection) &#123;//这是需要的角色           if (&quot;ROLE_login&quot;.equals(attribute.getAttribute())) &#123;//意思是这个请求只要登录了就能访问（这边可以自定义，我们这里就这么举例）               if (authentication instanceof AnonymousAuthenticationToken) &#123;//AnonymousAuthenticationToken意思是匿名用户，也就是没登录，所以要抛异常                   throw new AccessDeniedException(&quot;非法请求!&quot;);               &#125; else &#123;                   return;               &#125;           &#125;           Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities();//得到我现在属于的角色           for (GrantedAuthority authority : authorities) &#123;               if (authority.getAuthority().equals(attribute.getAttribute())) &#123;//如果我具备你需要的                   return;               &#125;           &#125;       &#125;       throw new AccessDeniedException(&quot;非法请求!&quot;);//非常不幸的走到了这一步，意味着你是非法请求（不然中途就break了）   &#125;      



Spring Security结合OAuth2协议
生成一个加密后的密码，明文“123”
@SpringBootTestclass Oauth2ApplicationTests &#123;    @Test    public void contextLoads() &#123;        System.out.println(new BCryptPasswordEncoder().encode(&quot;123&quot;));    &#125;&#125;



配置授权服务器AuthorizationServerConfig继承AuthorizationServerConfigurerAdapter
@Configuration@EnableAuthorizationServerpublic class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter &#123;    @Autowired    AuthenticationManager authenticationManager;//主要用来支持password的认证模式    @Autowired    RedisConnectionFactory redisConnectionFactory;    @Autowired    UserDetailsService userDetailsService;//刷新token的时候会用到    @Bean    PasswordEncoder passwordEncoder()&#123;        return new BCryptPasswordEncoder();    &#125;    @Override    public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123;        clients.inMemory()//配置在内存里边的                .withClient(&quot;password&quot;)//认证模式为password模式                .authorizedGrantTypes(&quot;password&quot;, &quot;refresh_token&quot;)//配授权模式，两种                .accessTokenValiditySeconds(1800)//token的过期时间，1800秒                .resourceIds(&quot;rid&quot;)//给资源取个名字                .scopes(&quot;all&quot;)                .secret(&quot;c405d914-f9cf-42d5-972e-0ffd4a1522bd&quot;);//一会需要的密码    &#125;    /**     * 配置令牌的存储，待会把令牌存到哪去！     */    @Override    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception &#123;        endpoints.tokenStore(new RedisTokenStore(redisConnectionFactory))                .authenticationManager(authenticationManager)                .userDetailsService(userDetailsService);    &#125;    @Override    public void configure(AuthorizationServerSecurityConfigurer security) throws Exception &#123;        security.allowFormAuthenticationForClients();//表示支持登录认证    &#125;&#125;



配置资源服务器ResourceServerConfig继承ResourceServerConfigurerAdapter
/** * 资源服务器 */@Configuration //表示是个配置类@EnableResourceServerpublic class ResourceServerConfig extends ResourceServerConfigurerAdapter &#123;    @Override    public void configure(ResourceServerSecurityConfigurer resources) throws Exception &#123;        resources.resourceId(&quot;rid&quot;)//指定资源id，就是在授权服务器里面配置的 rid  【.resourceIds(&quot;rid&quot;)】                .stateless(true);//意思是这些资源是基于令牌来认证的    &#125;    /**     * 这就是我提供的资源！     */    @Override    public void configure(HttpSecurity http) throws Exception &#123;        http.authorizeRequests().antMatchers(&quot;/admin/**&quot;).hasRole(&quot;admin&quot;)                .antMatchers(&quot;/user/**&quot;).hasRole(&quot;user&quot;)                .anyRequest().authenticated();//剩下其他的请求都是（authenticated）登录之后就可以访问    &#125;&#125;



配置SecurityConfig继承WebSecurityConfigurerAdapter
@Configurationpublic class SecurityConfig  extends WebSecurityConfigurerAdapter &#123;    @Override    @Bean    protected AuthenticationManager authenticationManager() throws Exception &#123;        return super.authenticationManager();//这个authenticationManager和        // 下面的userDetailsService会传给授权服务器    &#125;    @Bean    @Override    protected UserDetailsService userDetailsService() &#123;        return super.userDetailsService();    &#125;    @Override    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;        auth.inMemoryAuthentication()                .withUser(&quot;lcdzzz&quot;).password(&quot;$2a$10$BQsi4LxO/9536a2wwW.5D.T/t3fm52xzF17Eo6xlFinxuk8uKjEg2&quot;).roles(&quot;admin&quot;)                .and()                .withUser(&quot;zhoudian&quot;)                .password(&quot;$2a$10$BQsi4LxO/9536a2wwW.5D.T/t3fm52xzF17Eo6xlFinxuk8uKjEg2&quot;)                .roles(&quot;user&quot;);    &#125;    @Override    protected void configure(HttpSecurity http) throws Exception &#123;        http.antMatcher(&quot;/oauth/**&quot;)                .authorizeRequests()                .antMatchers(&quot;/oauth/**&quot;).permitAll()                .and().csrf().disable();    &#125;&#125;



在application.properties里配置
spring.redis.host=8.142.93.194spring.redis.port=6379spring.redis.database=0spring.redis.timeout=1000

Spring Security使用Json登录
在filter层中创建MyAuthenticationFilter来继承UsernamePasswordAuthenticationFilter，重写父类的attemptAuthentication方法
public class MyAuthenticationFilter extends UsernamePasswordAuthenticationFilter &#123;    @Override    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123;        if (!request.getMethod().equals(&quot;POST&quot;)) &#123;            throw new AuthenticationServiceException(                    &quot;Authentication method not supported: &quot; + request.getMethod());        &#125;        if (request.getContentType().equals(MediaType.APPLICATION_JSON_VALUE)) &#123;            //说明用户以 JSON 的形式传递的参数            String username = null;            String password = null;            try &#123;                Map&lt;String, String&gt; map = new ObjectMapper().readValue(request.getInputStream(), Map.class);//getInputStream是一个流，把这个流解析出来就是个json字符串了                //不是所有请求都有流，get就没有，只有有body的请求才有流                username = map.get(&quot;username&quot;);                password = map.get(&quot;password&quot;);            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;            if (username == null) &#123;                username = &quot;&quot;;            &#125;            if (password == null) &#123;                password = &quot;&quot;;            &#125;            username = username.trim();            UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(                    username, password);            // Allow subclasses to set the &quot;details&quot; property            setDetails(request, authRequest);            return this.getAuthenticationManager().authenticate(authRequest);        &#125;        return super.attemptAuthentication(request, response);    &#125;&#125;

接下来如何让上面的东西生效呢？则需要再配下security的配置
在config层创建一个SecurityConfig继承WebSecurityConfigurerAdapter
@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;    @Override    protected void configure(HttpSecurity http) throws Exception &#123;        http.authorizeRequests().anyRequest().authenticated()                .and()                .formLogin().permitAll()                .and().csrf().disable();        http.addFilterAt(myAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);//加一个filter    &#125;    @Bean    MyAuthenticationFilter myAuthenticationFilter() throws Exception &#123;        MyAuthenticationFilter filter = new MyAuthenticationFilter();        filter.setAuthenticationManager(authenticationManagerBean());        return filter;    &#125;&#125;

]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>springsecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>SprngSecurity实战实例，JWT Token登录认证&amp;权限控制</title>
    <url>/2022/11/03/SprngSecurity%E5%AE%9E%E6%88%98%E5%AE%9E%E4%BE%8B%EF%BC%8CJWT%20Token%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81&amp;%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[
这个在暑假就写过，上学以后重新再去写一遍发现困难比较多，于是准备写一篇记录一下。
tips: 源码在文章末尾，sql文件在源码resource文件夹下的sql文件夹里 

需求想用springsecurity实现JWT Token登录认证，实现动态菜单生成，权限控制，登出（用户注销）。
认证准备工作
maven依赖
     &lt;dependency&gt;         &lt;groupId&gt;com.alibaba&lt;/groupId&gt;         &lt;artifactId&gt;fastjson&lt;/artifactId&gt;         &lt;version&gt;1.2.47&lt;/version&gt;     &lt;/dependency&gt;&lt;dependency&gt;         &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;         &lt;artifactId&gt;lombok&lt;/artifactId&gt;         &lt;version&gt;1.18.0&lt;/version&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;     &lt;/dependency&gt;        &lt;dependency&gt;         &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;         &lt;artifactId&gt;jjwt&lt;/artifactId&gt;         &lt;version&gt;0.9.1&lt;/version&gt;     &lt;/dependency&gt;        &lt;!--redis依赖--&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;     &lt;/dependency&gt;

添加Redis相关配置
import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.serializer.SerializerFeature;import com.fasterxml.jackson.databind.JavaType;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.type.TypeFactory;import org.springframework.data.redis.serializer.RedisSerializer;import org.springframework.data.redis.serializer.SerializationException;import com.alibaba.fastjson.parser.ParserConfig;import org.springframework.util.Assert;import java.nio.charset.Charset;/** * Redis使用FastJson序列化 *  * @author sg */public class FastJsonRedisSerializer&lt;T&gt; implements RedisSerializer&lt;T&gt;&#123;    public static final Charset DEFAULT_CHARSET = Charset.forName(&quot;UTF-8&quot;);    private Class&lt;T&gt; clazz;    static    &#123;        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);    &#125;    public FastJsonRedisSerializer(Class&lt;T&gt; clazz)    &#123;        super();        this.clazz = clazz;    &#125;    @Override    public byte[] serialize(T t) throws SerializationException    &#123;        if (t == null)        &#123;            return new byte[0];        &#125;        return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET);    &#125;    @Override    public T deserialize(byte[] bytes) throws SerializationException    &#123;        if (bytes == null || bytes.length &lt;= 0)        &#123;            return null;        &#125;        String str = new String(bytes, DEFAULT_CHARSET);        return JSON.parseObject(str, clazz);    &#125;    protected JavaType getJavaType(Class&lt;?&gt; clazz)    &#123;        return TypeFactory.defaultInstance().constructType(clazz);    &#125;&#125;

响应类


   public class RespBean &#123;    private Integer status;    private String msg;    private Object object;    public static RespBean ok(String msg) &#123;        return new RespBean(200, msg, null);    &#125;    public static RespBean ok(String msg, Object obj) &#123;        return new RespBean(200, msg, obj);    &#125;    public static RespBean error(String msg) &#123;        return new RespBean(500, msg, null);    &#125;    public static RespBean error(String msg, Object obj) &#123;        return new RespBean(500, msg, obj);    &#125;    public static RespBean error() &#123;        return new RespBean();    &#125;    public RespBean(Integer status, String msg) &#123;        this.status = status;        this.msg = msg;    &#125;    public RespBean() &#123;        this.status = 500;        this.msg = &quot;操作异常&quot;;    &#125;    public RespBean(Integer status, String msg, Object object) &#123;        this.status = status;        this.msg = msg;        this.object = object;    &#125;    public Integer getStatus() &#123;        return status;    &#125;    public void setStatus(Integer status) &#123;        this.status = status;    &#125;    public String getMsg() &#123;        return msg;    &#125;    public void setMsg(String msg) &#123;        this.msg = msg;    &#125;    public Object getObject() &#123;        return object;    &#125;&#125;


工具类
import io.jsonwebtoken.Claims;import io.jsonwebtoken.JwtBuilder;import io.jsonwebtoken.Jwts;import io.jsonwebtoken.SignatureAlgorithm;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import java.util.Base64;import java.util.Date;import java.util.UUID;/** * JWT工具类 */public class JwtUtil &#123;    //有效期为    public static final Long JWT_TTL = 60 * 60 *1000L;// 60 * 60 *1000  一个小时    //设置秘钥明文    public static final String JWT_KEY = &quot;lcdzzz&quot;;    public static String getUUID()&#123;        String token = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);        return token;    &#125;        /**     * 生成jtw     * @param subject token中要存放的数据（json格式）     * @return     */    public static String createJWT(String subject) &#123;        JwtBuilder builder = getJwtBuilder(subject, null, getUUID());// 设置过期时间        return builder.compact();    &#125;    /**     * 生成jtw     * @param subject token中要存放的数据（json格式）     * @param ttlMillis token超时时间     * @return     */    public static String createJWT(String subject, Long ttlMillis) &#123;        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, getUUID());// 设置过期时间        return builder.compact();    &#125;    private static JwtBuilder getJwtBuilder(String subject, Long ttlMillis, String uuid) &#123;        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;        SecretKey secretKey = generalKey();        long nowMillis = System.currentTimeMillis();        Date now = new Date(nowMillis);        if(ttlMillis==null)&#123;            ttlMillis=JwtUtil.JWT_TTL;        &#125;        long expMillis = nowMillis + ttlMillis;        Date expDate = new Date(expMillis);        return Jwts.builder()                .setId(uuid)              //唯一的ID                .setSubject(subject)   // 主题  可以是JSON数据                .setIssuer(&quot;lcdzzz&quot;)     // 签发者                .setIssuedAt(now)      // 签发时间                .signWith(signatureAlgorithm, secretKey) //使用HS256对称加密算法签名, 第二个参数为秘钥                .setExpiration(expDate);    &#125;    /**     * 创建token     * @param id     * @param subject     * @param ttlMillis     * @return     */    public static String createJWT(String id, String subject, Long ttlMillis) &#123;        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, id);// 设置过期时间        return builder.compact();    &#125;    public static void main(String[] args) throws Exception &#123;//        String jwt = createJWT(&quot;2123&quot;);        Claims claims = parseJWT(&quot;eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiIyOTY2ZGE3NGYyZGM0ZDAxOGU1OWYwNjBkYmZkMjZhMSIsInN1YiI6IjIiLCJpc3MiOiJzZyIsImlhdCI6MTYzOTk2MjU1MCwiZXhwIjoxNjM5OTY2MTUwfQ.NluqZnyJ0gHz-2wBIari2r3XpPp06UMn4JS2sWHILs0&quot;);        String subject = claims.getSubject();        System.out.println(subject);//        System.out.println(claims);    &#125;    /**     * 生成加密后的秘钥 secretKey     * @return     */    public static SecretKey generalKey() &#123;        byte[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY);        SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, &quot;AES&quot;);        return key;    &#125;        /**     * 解析     *     * @param jwt     * @return     * @throws Exception     */    public static Claims parseJWT(String jwt) throws Exception &#123;        SecretKey secretKey = generalKey();        return Jwts.parser()                .setSigningKey(secretKey)                .parseClaimsJws(jwt)                .getBody();    &#125;&#125;

import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.BoundSetOperations;import org.springframework.data.redis.core.HashOperations;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.ValueOperations;import org.springframework.stereotype.Component;import java.util.*;import java.util.concurrent.TimeUnit;@SuppressWarnings(value = &#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)@Componentpublic class RedisCache&#123;    @Autowired    private RedisTemplate redisTemplate;    /**     * 缓存基本的对象，Integer、String、实体类等     *     * @param key 缓存的键值     * @param value 缓存的值     */    public &lt;T&gt; void setCacheObject(final String key, final T value)    &#123;        redisTemplate.opsForValue().set(key, value);    &#125;    /**     * 缓存基本的对象，Integer、String、实体类等     *     * @param key 缓存的键值     * @param value 缓存的值     * @param timeout 时间     * @param timeUnit 时间颗粒度     */    public &lt;T&gt; void setCacheObject(final String key, final T value, final Integer timeout, final TimeUnit timeUnit)    &#123;        redisTemplate.opsForValue().set(key, value, timeout, timeUnit);    &#125;    /**     * 设置有效时间     *     * @param key Redis键     * @param timeout 超时时间     * @return true=设置成功；false=设置失败     */    public boolean expire(final String key, final long timeout)    &#123;        return expire(key, timeout, TimeUnit.SECONDS);    &#125;    /**     * 设置有效时间     *     * @param key Redis键     * @param timeout 超时时间     * @param unit 时间单位     * @return true=设置成功；false=设置失败     */    public boolean expire(final String key, final long timeout, final TimeUnit unit)    &#123;        return redisTemplate.expire(key, timeout, unit);    &#125;    /**     * 获得缓存的基本对象。     *     * @param key 缓存键值     * @return 缓存键值对应的数据     */    public &lt;T&gt; T getCacheObject(final String key)    &#123;        ValueOperations&lt;String, T&gt; operation = redisTemplate.opsForValue();        return operation.get(key);    &#125;    /**     * 删除单个对象     *     * @param key     */    public boolean deleteObject(final String key)    &#123;        return redisTemplate.delete(key);    &#125;    /**     * 删除集合对象     *     * @param collection 多个对象     * @return     */    public long deleteObject(final Collection collection)    &#123;        return redisTemplate.delete(collection);    &#125;    /**     * 缓存List数据     *     * @param key 缓存的键值     * @param dataList 待缓存的List数据     * @return 缓存的对象     */    public &lt;T&gt; long setCacheList(final String key, final List&lt;T&gt; dataList)    &#123;        Long count = redisTemplate.opsForList().rightPushAll(key, dataList);        return count == null ? 0 : count;    &#125;    /**     * 获得缓存的list对象     *     * @param key 缓存的键值     * @return 缓存键值对应的数据     */    public &lt;T&gt; List&lt;T&gt; getCacheList(final String key)    &#123;        return redisTemplate.opsForList().range(key, 0, -1);    &#125;    /**     * 缓存Set     *     * @param key 缓存键值     * @param dataSet 缓存的数据     * @return 缓存数据的对象     */    public &lt;T&gt; BoundSetOperations&lt;String, T&gt; setCacheSet(final String key, final Set&lt;T&gt; dataSet)    &#123;        BoundSetOperations&lt;String, T&gt; setOperation = redisTemplate.boundSetOps(key);        Iterator&lt;T&gt; it = dataSet.iterator();        while (it.hasNext())        &#123;            setOperation.add(it.next());        &#125;        return setOperation;    &#125;    /**     * 获得缓存的set     *     * @param key     * @return     */    public &lt;T&gt; Set&lt;T&gt; getCacheSet(final String key)    &#123;        return redisTemplate.opsForSet().members(key);    &#125;    /**     * 缓存Map     *     * @param key     * @param dataMap     */    public &lt;T&gt; void setCacheMap(final String key, final Map&lt;String, T&gt; dataMap)    &#123;        if (dataMap != null) &#123;            redisTemplate.opsForHash().putAll(key, dataMap);        &#125;    &#125;    /**     * 获得缓存的Map     *     * @param key     * @return     */    public &lt;T&gt; Map&lt;String, T&gt; getCacheMap(final String key)    &#123;        return redisTemplate.opsForHash().entries(key);    &#125;    /**     * 往Hash中存入数据     *     * @param key Redis键     * @param hKey Hash键     * @param value 值     */    public &lt;T&gt; void setCacheMapValue(final String key, final String hKey, final T value)    &#123;        redisTemplate.opsForHash().put(key, hKey, value);    &#125;    /**     * 获取Hash中的数据     *     * @param key Redis键     * @param hKey Hash键     * @return Hash中的对象     */    public &lt;T&gt; T getCacheMapValue(final String key, final String hKey)    &#123;        HashOperations&lt;String, String, T&gt; opsForHash = redisTemplate.opsForHash();        return opsForHash.get(key, hKey);    &#125;    /**     * 删除Hash中的数据     *     * @param key     * @param hkey     */    public void delCacheMapValue(final String key, final String hkey)    &#123;        HashOperations hashOperations = redisTemplate.opsForHash();        hashOperations.delete(key, hkey);    &#125;    /**     * 获取多个Hash中的数据     *     * @param key Redis键     * @param hKeys Hash键集合     * @return Hash对象集合     */    public &lt;T&gt; List&lt;T&gt; getMultiCacheMapValue(final String key, final Collection&lt;Object&gt; hKeys)    &#123;        return redisTemplate.opsForHash().multiGet(key, hKeys);    &#125;    /**     * 获得缓存的基本对象列表     *     * @param pattern 字符串前缀     * @return 对象列表     */    public Collection&lt;String&gt; keys(final String pattern)    &#123;        return redisTemplate.keys(pattern);    &#125;&#125;

实体类
@Data@NoArgsConstructor@AllArgsConstructorpublic class User implements UserDetails, Serializable &#123;    private static final long serialVersionUID = 1L;    @TableId(value = &quot;id&quot;, type = IdType.AUTO)    private Long id;    private String username;    private String password;    private String name;    private Integer sex;    /**     * 医保卡号     */    private String medicalInsuranceCardNumber;    /**     * 身份证号     */    private String idNumber;    private String phone;    private String salt;    private LocalDateTime gmtCreate;    private LocalDateTime gmtModified;    @TableLogic    private Integer isDeleted;&#125;

实现配置工作DROP TABLE IF EXISTS `user`;CREATE TABLE `user` (  `id` bigint(20) NOT NULL AUTO_INCREMENT,  `username` varchar(255) DEFAULT NULL,  `password` varchar(255) DEFAULT NULL,  `name` varchar(255) DEFAULT NULL,  `sex` int(11) DEFAULT NULL,  `medical_insurance_card_number` varchar(255) DEFAULT NULL COMMENT &#x27;医保卡号&#x27;,  `id_number` varchar(255) DEFAULT NULL COMMENT &#x27;身份证号&#x27;,  `phone` varchar(255) DEFAULT NULL,  `salt` varchar(255) DEFAULT NULL,  `gmt_create` datetime DEFAULT NULL,  `gmt_modified` datetime DEFAULT NULL,  `is_deleted` int(11) DEFAULT NULL,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8;

数据库配置信息
spring:  datasource:    url: jdbc:mysql://localhost:3306/smart_reg??useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai    username: root    password: wqeq



定义mapper接口@Repositorypublic interface UserMapper extends BaseMapper&lt;User&gt; &#123;



实体类关于实体类，mapper层自动生成可以看https://lcdzzz.github.io/2022/06/22/mybatisplus/ 的”代码生成器部分“
实体类需要实现UserDetails接口，并实现里面的方法
@Data@NoArgsConstructor@AllArgsConstructorpublic class User implements UserDetails, Serializable &#123;    private static final long serialVersionUID = 1L;    @TableId(value = &quot;id&quot;, type = IdType.AUTO)    private Long id;    private String username;    private String password;    private String name;    private Integer sex;    /**     * 医保卡号     */    private String medicalInsuranceCardNumber;    /**     * 身份证号     */    private String idNumber;    private String phone;    private String salt;    private LocalDateTime gmtCreate;    private LocalDateTime gmtModified;    @TableLogic    private Integer isDeleted;    /**    	先这么写，在授权一块会补全    */    @Override    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;        return null;    &#125;    @Override    public boolean isAccountNonExpired() &#123;        return true;    &#125;    @Override    public boolean isAccountNonLocked() &#123;        return true;    &#125;    @Override    public boolean isCredentialsNonExpired() &#123;        return true;    &#125;    @Override    public boolean isEnabled() &#123;        return true;    &#125;    @TableField(exist = false)//：表示该属性不为数据库表字段，但又是必须使用的。    private List&lt;Role&gt; roles;&#125;

mapper扫描
@MapperScan(&quot;com.qingshan.smartregsystem.mapper&quot;)@SpringBootApplicationpublic class SmartRegSystemApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(SmartRegSystemApplication.class, args);    &#125;&#125;

添加junit依赖
&lt;dependency&gt;          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;          &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;      &lt;/dependency&gt;

 测试MP是否能正常使用
@SpringBootTestpublic class MapperTest &#123;    @Autowired    private UserMapper userMapper;    @Test    public void testUserMapper()&#123;        List&lt;User&gt; users = userMapper.selectList(null);        System.out.println(users);    &#125;&#125;



controller层 @RestController@RequestMapping(&quot;/smartregsystem/user&quot;)public class LoginController &#123;    @Autowired    LoginServcie loginServcie;    @PostMapping(&quot;/login&quot;)    public RespBean login(@RequestBody User user) &#123;        //登录        return loginServcie.login(user);    &#125;

service类（核心代码)@Servicepublic class LoginServiceImpl implements LoginServcie &#123;    @Autowired    private AuthenticationManager authenticationManager;    @Autowired    UserMapper userMapper;    @Autowired    private RedisCache redisCache;    @Override    public RespBean login(User user) &#123;        //AuthenticationManager authenticate进行用户认证        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUsername(),user.getPassword());        Authentication authenticate = authenticationManager.authenticate(authenticationToken);        //如果认证没通过，给出对应的提示        if(Objects.isNull(authenticate))&#123;            throw new RuntimeException(&quot;登录失败&quot;);        &#125;        //如果认证通过了，使用userid生成一个jwt jwt存入ResponseResult返回        User loginUser = (User) authenticate.getPrincipal();        String userid = loginUser.getId().toString();        loginUser.setPassword(null);        String jwt = JwtUtil.createJWT(userid);        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;token&quot;,jwt);        map.put(&quot;userInfo&quot;,loginUser);        //把完整的用户信息存入redis  userid作为key        redisCache.setCacheObject(&quot;login:&quot;+userid,loginUser);        return  RespBean.ok(&quot;登录成功&quot;,map);    &#125;&#125;

执行到Authentication authenticate = authenticationManager.authenticate(authenticationToken);这行时，需要通过UserDetailsService这个接口的实现类去完成用户认证。所以需要一个类去实现UserDetailsService，并实现loadUserByUsername方法。
ps:这里内含最开始没有用springsecurity实现注册的痕迹，可以随便看看，用了MD5加密的方法，不过用了springsecurity以后，就用它自带的BCryptPasswordEncoder了。关于怎么配置，在后面的SecurityConfig配置中会有说明。
user.setRoles(userMapper.getHrRolesById(user.getId()));这行代码可以先不要，这是接下来授权部分的代码。
@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements IUserService, UserDetailsService &#123;    @Autowired    UserMapper userMapper;     @Override    public UserDetails loadUserByUsername(String username)  &#123;        //查询用户信息        QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();        queryWrapper.eq(&quot;username&quot;, username);        User user = userMapper.selectOne(queryWrapper);//        User user = userMapper.selectByUserName(username);        //如果没有查询到用户就抛出异常        if(Objects.isNull(user))&#123;            System.out.println(&quot;没有查到用户！！！&quot;);        &#125;        user.setRoles(userMapper.getHrRolesById(user.getId()));        //把数据封装成UserDetails返回        return user;    &#125;        @Override    public Integer reg(User user) &#123;        String username = user.getUsername();        User result=userMapper.selectAllByUsername(username);        if (result!=null)&#123;            throw new UserRegOrLoginException(&quot;用户名被占用&quot;);        &#125;// 创建当前时间对象        LocalDateTime now = LocalDateTime.now();        /**         * 密码加密处理的实现：md5算法         */        // 补全数据：加密后的密码        String salt = UUID.randomUUID().toString().toUpperCase();        BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();        String encodePassword = encoder.encode(user.getPassword());//        String md5Password = getMd5Password(user.getPassword(), salt);        user.setPassword(encodePassword);        // 补全数据：盐值        user.setSalt(salt);//        // 补全数据：isDelete(0)//        user.setIsDelete(0);        // 补全数据：4项日志属性        user.setGmtCreate(now);        user.setGmtModified(now);        user.setIsDeleted(0);        Integer rows = userMapper.insert(user);        if (rows!=1)&#123;            throw new UserRegOrLoginException(&quot;在用户注册过程中产生了未知异常&quot;);        &#125;        return rows;    &#125;   &#125;

验证完，LoginServiceImpl的login方法就可以继续往下走了


关于密码加密存储实际项目中我们不会把密码明文存储在数据库中。
我们一般使用SpringSecurity为我们提供的BCryptPasswordEncoder。
只需要使用把BCryptPasswordEncoder对象注入Spring容器中，SpringSecurity就会使用该PasswordEncoder来进行密码校验。
可以定义一个SpringSecurity的配置类，SpringSecurity要求这个配置类要继承WebSecurityConfigurerAdapter。
同时这也是非常重要的springsecurity配置类
@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;    @Bean    public PasswordEncoder passwordEncoder()&#123;        return new BCryptPasswordEncoder();    &#125;&#125;

springsecurity配置类在这之前我们自定义登陆接口，所以需要让SpringSecurity对这个接口放行,让用户访问这个接口的时候不用登录也能访问。
在接口中我们通过AuthenticationManager的authenticate方法来进行用户认证,所以也需要在SecurityConfig中配置把AuthenticationManager注入容器。（上面是把BCryptPasswordEncoder注入进容器）
认证成功的话要生成一个jwt，放入响应中返回。并且为了让用户下回请求时能通过jwt识别出具体的是哪个用户，我们需要把用户信息存入redis，可以把用户id作为key。(代码可见上面LoginServiceImpl类的login方法)
ps:这边复制完会在 http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);上报错，别急，继续往下看
@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;    @Autowired    JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;    @Bean    PasswordEncoder passwordEncoder() &#123;        return new BCryptPasswordEncoder();//特点：相同的明文，加密后生成的密文是不一样的        //return NoOpPasswordEncoder.getInstance();   //该密码编码器为字符串匹配，不做加密比较    &#125;    //配置路径的拦截规则    @Override    protected void configure(HttpSecurity http) throws Exception &#123;        http                //关闭csrf                .csrf().disable()                //不通过Session获取SecurityContext                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)                .and()                .authorizeRequests()                // 对于登录接口 允许匿名访问                .antMatchers(&quot;/smartregsystem/user/login&quot;).permitAll()                .antMatchers(&quot;/smartregsystem/user/reg&quot;).permitAll()                .anyRequest().authenticated()                       ;        // 除上面外的所有请求全部需要鉴权认证        //把token校验过滤器添加到过滤器链中        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);        //允许跨域        http.cors();    &#125;       @Bean    @Override    public AuthenticationManager authenticationManagerBean() throws Exception &#123;        return super.authenticationManagerBean();    &#125;&#125;

认证过滤器在上面springsecurity配置类中，我们把token校验过滤器也添加到了过滤器链中 http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class); 
说明：

我们需要自定义一个过滤器，这个过滤器会去获取请求头中的token，对token进行解析取出其中的userid。
使用userid去redis中获取对应的LoginUser对象。
然后封装Authentication对象存入SecurityContextHolder

@Componentpublic class JwtAuthenticationTokenFilter extends OncePerRequestFilter &#123;    @Autowired    private RedisCache redisCache;    @Override    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123;        //获取token        String token = request.getHeader(&quot;token&quot;);        if (!StringUtils.hasText(token)) &#123;            //放行            filterChain.doFilter(request, response);            return;        &#125;        //解析token        String userid;        try &#123;            Claims claims = JwtUtil.parseJWT(token);            userid = claims.getSubject();        &#125; catch (Exception e) &#123;            e.printStackTrace();            throw new RuntimeException(&quot;token非法&quot;);        &#125;        //从redis中获取用户信息        String redisKey = &quot;login:&quot; + userid;        User loginUser = redisCache.getCacheObject(redisKey);        if(Objects.isNull(loginUser))&#123;            throw new RuntimeException(&quot;用户未登录&quot;);        &#125;        //TODO 获取权限信息封装到AuthenticationToken中        //存入SecurityContextHolder        UsernamePasswordAuthenticationToken authenticationToken =                new UsernamePasswordAuthenticationToken(loginUser,null,null);        SecurityContextHolder.getContext().setAuthentication(authenticationToken);        //放行                filterChain.doFilter(request, response);    &#125;&#125;



退出登录我们只需要定义一个退出登录的接口，然后获取SecurityContextHolder中的认证信息，删除redis中对应的数据即可。
@GetMapping(&quot;/logout&quot;)public RespBean logout()&#123;    return loginServcie.logout();&#125;

@Overridepublic RespBean logout() &#123;    //获取SecurityContextHolder中的用户id    UsernamePasswordAuthenticationToken authentication = (UsernamePasswordAuthenticationToken) SecurityContextHolder.getContext().getAuthentication();    User loginUser = (User) authentication.getPrincipal();    Long userid = loginUser.getId();    //删除redis中的值    redisCache.deleteObject(&quot;login:&quot;+userid);    return  RespBean.ok(&quot;注销成功&quot;);&#125;




到这一步，登录和登出代码已经完成，用户登录时输入username（账号），password（密码），就会返回用户信息和token。这里因为功能已经，所以有roles和authorities等信息，可以暂时忽略（接下来会讲）。

运行结果：

  .ghwbypswozhh{width:70%}



  .jeviibobbfvx{width:70%}




授权授权基本流程​	在SpringSecurity中，会使用默认的FilterSecurityInterceptor来进行权限校验。在FilterSecurityInterceptor中会从SecurityContextHolder获取其中的Authentication，然后获取其中的权限信息。当前用户是否拥有访问当前资源所需的权限。
​	所以我们在项目中只需要把当前登录用户的权限信息也存入Authentication。
​	然后设置我们的资源所需要的权限即可。
授权实现封装权限信息之前在在写UserDetailsServiceImpl的时候说过user.setRoles(userMapper.getHrRolesById(user.getId()));这行代码。
它的意思是在查询出用户后还要获取对应的权限信息，封装到UserDetails中返回。
讲到这里有必要说下这边数据库的设计，详细的可以去了解下RBAC（Role Based Access Control，基于角色的访问控制）权限模型，这里就不阐述了。

整个代码的仓库地址会放在文章末尾，里面会附带sql这个项目的整个数据库，数据都是假的，别管


  .pqvgtisrlrrg{width:70%}




sql语句:
&lt;select id=&quot;getHrRolesById&quot; resultType=&quot;com.qingshan.smartregsystem.pojo.Role&quot;&gt;         SELECT r.* FROM role r,user_role ur WHERE ur.`rid`=r.`id` AND ur.`uid`=#&#123;id&#125;&lt;/select&gt;



我们之前定义了UserDetails的实现类User，想要让其能封装权限信息就要对其进行修改。
实体类：
@Data@NoArgsConstructor@AllArgsConstructorpublic class User implements UserDetails, Serializable &#123;    private static final long serialVersionUID = 1L;    @TableId(value = &quot;id&quot;, type = IdType.AUTO)    private Long id;    private String username;    private String password;    private String name;    private Integer sex;    /**     * 医保卡号     */    private String medicalInsuranceCardNumber;    /**     * 身份证号     */    private String idNumber;    private String phone;    private String salt;    private LocalDateTime gmtCreate;    private LocalDateTime gmtModified;    @TableLogic    private Integer isDeleted;    @Override    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;        List&lt;SimpleGrantedAuthority&gt; authorities =new ArrayList&lt;&gt;(roles.size());        for (Role role : roles) &#123;            authorities.add(new SimpleGrantedAuthority(role.getName()));        &#125;        return authorities;    &#125;    @Override    public boolean isAccountNonExpired() &#123;        return true;    &#125;    @Override    public boolean isAccountNonLocked() &#123;        return true;    &#125;    @Override    public boolean isCredentialsNonExpired() &#123;        return true;    &#125;    @Override    public boolean isEnabled() &#123;        return true;    &#125;    @TableField(exist = false)//：表示该属性不为数据库表字段，但又是必须使用的。    private List&lt;Role&gt; roles;&#125;



User修改完后我们就可以在UserDetailsServiceImpl中去把权限信息封装到User中了。

  .yrguvatdfdcg{width:70%}


所必要的配置类CustomFilterInvocationSecurityMetadataSource和CustomUrlDecisionManager，这也是实现权限控制（根据权限对接口进行拦截）的核心。


CustomFilterInvocationSecurityMetadataSource它作用是 根据用户传来的请求地址 分析出请求需要的角色
这里需要把登录的接口、获取动态菜单的接口、注册用户的接口，设置后“特殊”的权限，这样在后面就可以对这些需要“特殊”权限的接口放行。
// 根据用户传来的请求地址 分析出请求需要的角色@Component //注册为组件public class CustomFilterInvocationSecurityMetadataSource implements FilterInvocationSecurityMetadataSource &#123;    @Autowired    IMenuService menuService;    //比对工具，这里用来比对request的url和menu的url    AntPathMatcher antPathMatcher = new AntPathMatcher();    @Autowired    PathMatcher pathMatcher;    @Override    public Collection&lt;ConfigAttribute&gt; getAttributes(Object object) throws IllegalArgumentException &#123;        //当前请求的地址        String requestUrl = ((FilterInvocation) object).getRequestUrl();        if (requestUrl.equals(&quot;/smartregsystem/user/login&quot;)) &#123;            return SecurityConfig.createList(&quot;ROLE_WANT_TO_LOGIN&quot;);        &#125; else if (requestUrl.equals(&quot;/smartregsystem/config/menu&quot;)) &#123;//            System.out.println(&quot;给/smartregsystem/config/menu路径WANT_TO_MENU权限&quot;);            return SecurityConfig.createList(&quot;ROLE_WANT_TO_MENU&quot;);        &#125;else if (requestUrl.equals(&quot;/smartregsystem/user/reg&quot;)) &#123;//            System.out.println(&quot;给/smartregsystem/config/menu路径WANT_TO_MENU权限&quot;);            return SecurityConfig.createList(&quot;ROLE_WANT_TO_REG&quot;);        &#125;        List&lt;Menu&gt; menus = menuService.getAllMenusWithRole();        for (Menu menu : menus) &#123;            //match()中第一个是匹配规则，第二个是需要匹配的对象            if ( pathMatcher.match(menu.getUrl(),requestUrl))&#123;                List&lt;Role&gt; roles = menu.getRoles();                String[] str = new String[roles.size()];                for (int i = 0; i &lt; roles.size(); i++) &#123;                    str[i] = roles.get(i).getName();                &#125;                return SecurityConfig.createList(str);            &#125;        &#125;        //没有匹配上的 登陆后访问           标记 后续判断用        return SecurityConfig.createList(&quot;ROLE_LOGIN&quot;);    &#125;    @Override    public Collection&lt;ConfigAttribute&gt; getAllConfigAttributes() &#123;        return null;    &#125;    @Override    public boolean supports(Class&lt;?&gt; aClass) &#123;        return true;    &#125;&#125;



CustomUrlDecisionManager它的作用是判断当前用户是否具备CustomFilterInvocationSecurityMetadataSource分析出来的角色
在CustomFilterInvocationSecurityMetadataSource的时候，我们已经把登录、菜单、注册这三个接口附上了“需要特殊权限”的这个信息，而在这个类中，我们可以设置：假设用户需要的权限是 那三个特殊的权限，也就是：ROLE_WANT_TO_LOGIN、ROLE_WANT_TO_MENU、ROLE_WANT_TO_REG，就放行。
如果不是那三个特殊的权限，就会继续往下运行。
于是：

  .ybbvuggohhww{width:70%}


贴上代码↓
/** * 判断当前用户是否具备CustomFilterInvocationSecurityMetadataSource分析出来的角色 */@Component   //注册为组件public class CustomUrlDecisionManager implements AccessDecisionManager &#123;    /**     *     * @param authentication 用户的登陆登录信息     * @param object     * @param configAttributes CustomFilterInvocationSecurityMetadataSource分析出来的角色     * @throws AccessDeniedException     * @throws InsufficientAuthenticationException     */    @Override    public void decide(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes)            throws AccessDeniedException, InsufficientAuthenticationException &#123;        for (ConfigAttribute configAttribute : configAttributes) &#123;            //用户所需角色            String needRole = configAttribute.getAttribute();            if (&quot;ROLE_LOGIN&quot;.equals(needRole))&#123;                //判断当前用户是否是匿名用户                if (authentication instanceof AnonymousAuthenticationToken)&#123;                    throw new AccessDeniedException(&quot;尚未登录，请登录！&quot;);                &#125;else &#123;                    return;                &#125;            &#125;            if (&quot;ROLE_WANT_TO_LOGIN&quot;.equals(needRole))&#123;                //当前请求时登录请求，放开                return;            &#125;            if (&quot;ROLE_WANT_TO_MENU&quot;.equals(needRole))&#123;                //当前请求时菜单，放开                return;            &#125;            if (&quot;ROLE_WANT_TO_REG&quot;.equals(needRole))&#123;                //当前请求时菜单，放开                return;            &#125;            //获取当前登录用户的角色//            Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities();            List&lt;Role&gt; authorities= ((User) SecurityContextHolder.getContext().getAuthentication().getPrincipal()).getRoles();            System.out.println(&quot;这里是authentication = &quot; + authentication);            for (Role authority : authorities) &#123;                //假如请求需要的角色是A、B，而我登录的角色是B、C，那也一样可以访问                if (authority.getName().equals(needRole))&#123;//遍历【注意：是双重循环，上面还有一重】，只要判断是否包含configAttributes集合中的任意一项                    return;                &#125;            &#125;        &#125;            throw new AccessDeniedException(&quot;权限不足，请联系管理员&quot;);    &#125;    @Override    public boolean supports(ConfigAttribute configAttribute) &#123;        return true;    &#125;    @Override    public boolean supports(Class&lt;?&gt; aClass) &#123;        return true;    &#125;&#125;





SecurityConfig收尾工作然后，我们需要在configure(HttpSecurity http)方法中，通过withObjectPostProcessor将刚刚创建CustomUrlDecisionManager和CustomFilterInvocationSecurityMetadataSource注入进来
@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;    @Autowired    CustomUrlDecisionManager customUrlDecisionManager;    @Autowired    CustomFilterInvocationSecurityMetadataSource customFilterInvocationSecurityMetadataSource;    @Autowired    JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;    @Bean    PasswordEncoder passwordEncoder() &#123;        return new BCryptPasswordEncoder();//特点：相同的明文，加密后生成的密文是不一样的        //return NoOpPasswordEncoder.getInstance();   //该密码编码器为字符串匹配，不做加密比较    &#125;    //配置路径的拦截规则    @Override    protected void configure(HttpSecurity http) throws Exception &#123;        http                //关闭csrf                .csrf().disable()                //不通过Session获取SecurityContext                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)                .and()                .authorizeRequests()                // 对于登录接口 允许匿名访问                .antMatchers(&quot;/smartregsystem/user/login&quot;).permitAll()                .antMatchers(&quot;/smartregsystem/user/reg&quot;).permitAll()                .anyRequest().authenticated()                .withObjectPostProcessor(new ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123;                    @Override                    public &lt;O extends FilterSecurityInterceptor&gt; O postProcess(O object) &#123;                        object.setAccessDecisionManager(customUrlDecisionManager);                        object.setSecurityMetadataSource(customFilterInvocationSecurityMetadataSource);                        return object;                    &#125;                &#125;)        ;        // 除上面外的所有请求全部需要鉴权认证        //把token校验过滤器添加到过滤器链中        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);        //允许跨域        http.cors();    &#125;    @Bean    @Override    public AuthenticationManager authenticationManagerBean() throws Exception &#123;        return super.authenticationManagerBean();    &#125;&#125;



自定义失败处理我们还希望在认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的json，这样可以让前端能对响应进行统一的处理。要实现这个功能我们需要知道SpringSecurity的异常处理机制。
​	在SpringSecurity中，如果我们在认证或者授权的过程中出现了异常会被ExceptionTranslationFilter捕获到。在ExceptionTranslationFilter中会去判断是认证失败还是授权失败出现的异常。

对ExceptionTranslationFilter原理感兴趣的可以看这篇博客的第三部分https://blog.csdn.net/weixin_52834606/article/details/126729690

​	如果是认证过程中出现的异常会被封装成AuthenticationException然后调用AuthenticationEntryPoint对象的方法去进行异常处理。
​	如果是授权过程中出现的异常会被封装成AccessDeniedException然后调用AccessDeniedHandler对象的方法去进行异常处理。
​	所以如果我们需要自定义异常处理，我们只需要自定义AuthenticationEntryPoint和AccessDeniedHandler然后配置给SpringSecurity即可。

自定义实现类
@Componentpublic class AccessDeniedHandlerImpl implements AccessDeniedHandler &#123;    @Override    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException &#123;        RespBean result = new RespBean(HttpStatus.FORBIDDEN.value(),&quot;您的权限不足&quot;);        String json = JSON.toJSONString(result);        //处理异常        WebUtils.renderString(response,json);    &#125;&#125;

@Componentpublic class AuthenticationEntryPointImpl implements AuthenticationEntryPoint &#123;    @Override    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException &#123;        RespBean result = new RespBean(HttpStatus.UNAUTHORIZED.value(),&quot;用户认证失败请查询登录&quot;);        String json = JSON.toJSONString(result);        //处理异常        WebUtils.renderString(response,json);    &#125;&#125;

配置给SpringSecurity
先注入对应的处理器
@Autowired   private AuthenticationEntryPoint authenticationEntryPoint;      @Autowired   private AccessDeniedHandler accessDeniedHandler;



然后可以使用HttpSecurity对象的方法去配置。
ps: 注释掉的是之前没有把两个实现类分离出来的写法，可以参考参考，当然更优雅的写法还是注释外的那种。
.and().exceptionHandling()               /*.authenticationEntryPoint((request, response, authenticationException) -&gt; &#123;                   Map&lt;String, Object&gt; rs = new HashMap&lt;&gt;();                   rs.put(&quot;code&quot;, 401);//注销以后再用直接的token去访问，就是这个异常                   rs.put(&quot;msg&quot;, &quot;尚未认证!&quot;);                   ObjectMapper objectMapper = new ObjectMapper();                   String json = objectMapper.writeValueAsString(rs);                   response.setStatus(200);                   response.setContentType(MediaType.APPLICATION_JSON_UTF8_VALUE);                   response.getWriter().println(json);                  &#125;)               .accessDeniedHandler((request, response, accessDeniedException) -&gt; &#123;                   Map&lt;String, Object&gt; rs = new HashMap&lt;&gt;();                   rs.put(&quot;code&quot;, 403);                   rs.put(&quot;msg&quot;, &quot;没有权限!&quot;);                   ObjectMapper objectMapper = new ObjectMapper();                   String json = objectMapper.writeValueAsString(rs);                   response.setStatus(200);                   response.setContentType(MediaType.APPLICATION_JSON_UTF8_VALUE);                   response.getWriter().println(json);               &#125;)*/               .authenticationEntryPoint(authenticationEntryPoint).               accessDeniedHandler(accessDeniedHandler)



结尾源码地址
写本博客时，参考了
spring Security 异常处理
SpringSecurity框架教程
最后还要感谢 http://www.javaboy.org/ 松哥的各种文章，没有他的指导，我没法在暑假写出动态权限的功能
还有关于springsecurity的其他细节，可以看↓
一个案例演示 Spring Security 中粒度超细的权限控制 
Spring Security 中最流行的权限管理模型
Spring Security 权限管理的投票器与表决机制 
]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>springboot</tag>
        <tag>springsecurity</tag>
        <tag>项目实战</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2022/01/20/Redis%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[RedisRedis入门启动redis

redis的默认安装路径/usr/local/bin  ，注意：usr目录不是user的缩写，是Unix Software Resource的缩写

通过指定的配置文件启动服务



  .anhckvbgqxqe{width:70%}



使用redis-cli进行连接测试
redis-cli -h localhost -p 6379
h默认的是主机(localhost&#x2F;127.0.0.1，可以省略



  .xeuxcquygsml{width:70%}

   

  .blzmlhvmyplo{width:70%}



  .jobtzkjxggnh{width:70%}



  .ifhhsbyulviu{width:70%}


基础的知识redis默认有16个数据库
默认使用第0个
可以使用select进行切换数据库
localhost:6379[3]&gt; select 4 #切换数据库OKlocalhost:6379[4]&gt; dbsize(integer) 0

localhost:6379[3]&gt; set name zhoudianOKlocalhost:6379[3]&gt; get name &quot;zhoudian&quot;localhost:6379[3]&gt; keys *1) &quot;name&quot;localhost:6379[3]&gt; 



清除当前数据库flushdb  清空全部flushall
localhost:6379[3]&gt; flushdbOKlocalhost:6379[3]&gt; keys *(empty array)





五大数据类型Redis-key127.0.0.1:6379&gt; keys *  #查看所有的key(empty array)127.0.0.1:6379&gt; set name zhoudian #	 set keyOK127.0.0.1:6379&gt; keys *1) &quot;name&quot;127.0.0.1:6379&gt; set age 1OK127.0.0.1:6379&gt; key *(error) ERR unknown command `key`, with args beginning with: `*`, 127.0.0.1:6379&gt; keys*(error) ERR unknown command `keys*`, with args beginning with: 127.0.0.1:6379&gt; keys *1) &quot;name&quot;2) &quot;age&quot;127.0.0.1:6379&gt; exists name  #判断当前的key是否存在(integer) 1127.0.0.1:6379&gt; exists name1(integer) 0127.0.0.1:6379&gt; move name 1  #把key为“name”的数据移动到数据库1中(integer) 1127.0.0.1:6379&gt; keys *1) &quot;age&quot;127.0.0.1:6379&gt; set name zhoudianOK127.0.0.1:6379&gt; keys *1) &quot;name&quot;2) &quot;age&quot;127.0.0.1:6379&gt; get name&quot;zhoudian&quot;127.0.0.1:6379&gt; expire name 10  #设置key的过期时间，单位是秒(integer) 1127.0.0.1:6379&gt; ttl name(integer) 5127.0.0.1:6379&gt; ttl name(integer) 4127.0.0.1:6379&gt; ttl name(integer) 3127.0.0.1:6379&gt; ttl name(integer) 2127.0.0.1:6379&gt; ttl name(integer) 1127.0.0.1:6379&gt; ttl name(integer) 1127.0.0.1:6379&gt; ttl name(integer) -2127.0.0.1:6379&gt; ttl name(integer) -2127.0.0.1:6379&gt; expire name 10(integer) 0127.0.0.1:6379&gt; get name(nil)127.0.0.1:6379&gt; keys *1) &quot;age&quot;127.0.0.1:6379&gt; type namenone127.0.0.1:6379&gt; type age  # 查看当前key的类型string



String （字符串）############################################################################127.0.0.1:6379&gt; set key1 b1  #设置值OK127.0.0.1:6379&gt; get key1     #获得值&quot;b1&quot;127.0.0.1:6379&gt; keys *       #获得所以的key1) &quot;key1&quot;2) &quot;age&quot;127.0.0.1:6379&gt; del age      (integer) 1127.0.0.1:6379&gt; keys *1) &quot;key1&quot;127.0.0.1:6379&gt; exists key1  #判断某个key是否存在(integer) 1127.0.0.1:6379&gt; append key1 &quot;hello&quot;  #追加字符串，如果key不存在，就相当于set key(integer) 7127.0.0.1:6379&gt; get key1&quot;b1hello&quot;127.0.0.1:6379&gt; strlen key1  #获取字符串长度(integer) 7127.0.0.1:6379&gt; append key1 &quot;,zhoudian&quot;(integer) 16127.0.0.1:6379&gt; strlen key1(integer) 16127.0.0.1:6379&gt; get key1&quot;b1hello,zhoudian&quot;#############################################################################i++#步长 i+=127.0.0.1:6379&gt; set views 0  #初始浏览量为0OK127.0.0.1:6379&gt; get views&quot;0&quot;127.0.0.1:6379&gt; incr view    #自增1(integer) 1127.0.0.1:6379&gt; incr view(integer) 2127.0.0.1:6379&gt; get view&quot;2&quot;127.0.0.1:6379&gt; decr view    #自减(integer) 1127.0.0.1:6379&gt; decr view(integer) 0127.0.0.1:6379&gt; decr view(integer) -1127.0.0.1:6379&gt; incrby view 10(integer) 9127.0.0.1:6379&gt; incrby view 10(integer) 19127.0.0.1:6379&gt; decrby view 5(integer) 14#############################################################################字符串范围range127.0.0.1:6379&gt; set key1 &quot;hello,zhoudian&quot;   #设置初始值OK127.0.0.1:6379&gt; get key1&quot;hello,zhoudian&quot;127.0.0.1:6379&gt; getrange key1 0 3   #截取字符串&quot;hell&quot;127.0.0.1:6379&gt; getrange key1 0 -1  #获取全部的字符串，和get key是一样的&quot;hello,zhoudian&quot;#替换！127.0.0.1:6379&gt; set key2 abcdefgOK127.0.0.1:6379&gt; get key2&quot;abcdefg&quot;127.0.0.1:6379&gt; setrange key2 1 xx  #替换指定位置开始的字符串(integer) 7127.0.0.1:6379&gt; get key2&quot;axxdefg&quot;#############################################################################setex(set with expire)   #设置过期时间#setnx(set if not exist)  #不存在在设置（在分布式锁中会常常使用）127.0.0.1:6379&gt; setex key3 30 &quot;hello&quot;  #设置key3的值为hello  30秒后过期OK127.0.0.1:6379&gt; ttl key3(integer) 18127.0.0.1:6379&gt; get key3&quot;hello&quot;127.0.0.1:6379&gt; setnx mykey &quot;redis&quot;  #如果mykey 不存在，创建mykey(integer) 1127.0.0.1:6379&gt; keys *1) &quot;view&quot;2) &quot;key1&quot;3) &quot;views&quot;4) &quot;kye1&quot;5) &quot;key2&quot;6) &quot;mykey&quot;127.0.0.1:6379&gt; ttl keys(integer) -2127.0.0.1:6379&gt; setnx mykey &quot;MongoDB&quot;   #如果mykey存在，创建失败！(integer) 0127.0.0.1:6379&gt; get mykey&quot;redis&quot;###########################################################################msetmget127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3  #  同时设置多个值OK127.0.0.1:6379&gt; keys *1) &quot;k2&quot;2) &quot;k1&quot;3) &quot;k3&quot;127.0.0.1:6379&gt; mget k1 k2 k3          #   同时获取多个值1) &quot;v1&quot;2) &quot;v2&quot;3) &quot;v3&quot;127.0.0.1:6379&gt; msetnx k1 v1 k4 v4     #   msetnx 是一个原子性的操作，要么一起成功，要么一起失败( integer) 0127.0.0.1:6379&gt; get k4(nil)#对象set user:1 &#123;name:zhangsan,age:3&#125;  #设置一个user:1 对象 值为json字符来保存一个对象#这里的key是一个巧妙的设计： user:&#123;id&#125;:&#123;filed&#125;,如此设计在Redis中是完全ok了！127.0.0.1:6379&gt; mset user01:name lisi user02:age 22OK127.0.0.1:6379&gt; mget user01:name user02:age1) &quot;lisi&quot;2) &quot;22&quot;##########################################################################getset #先get然后再set127.0.0.1:6379&gt; getset db redis  #如果不存在值，则返回nil(nil)127.0.0.1:6379&gt; get db&quot;redis&quot;127.0.0.1:6379&gt; getset db mongodb  #如果存在值，获取原来的值，并设置新的值&quot;redis&quot;127.0.0.1:6379&gt; get db&quot;mongodb&quot;

数据结构是相同的！
String 类似的使用常见，value除了我们的字符串还可以是数字！

计数器
统计多单位的数量
粉丝数
对象缓存存储

List基本数据类型，列表
在redis里面，我们可以把list完成，栈，队列，阻塞队列！
所有的list命令都是用l开头的
##########################################################################127.0.0.1:6379&gt; lpush list  #将一个值或多个值插入列表头部(integer) 1127.0.0.1:6379&gt; lpush list two(integer) 2127.0.0.1:6379&gt; lpush list three(integer) 3127.0.0.1:6379&gt; lrange list 0 -11) &quot;three&quot;2) &quot;two&quot;3) &quot;one&quot;127.0.0.1:6379&gt; lrange list 0 11) &quot;three&quot;2) &quot;two&quot;127.0.0.1:6379&gt; rpush list right  #将一个值或多个值插入列表尾部(integer) 4127.0.0.1:6379&gt; lrange list 0 -11) &quot;three&quot;2) &quot;two&quot;3) &quot;one&quot;4) &quot;right&quot;##########################################################################LPOPRPOP127.0.0.1:6379&gt; lrange list 0 -11) &quot;three&quot; 2) &quot;two&quot;3) &quot;one&quot;4) &quot;right&quot;127.0.0.1:6379&gt; lpop list   #移除list的第一个元素&quot;three&quot;127.0.0.1:6379&gt; lrange list 0 -11) &quot;two&quot;2) &quot;one&quot;3) &quot;right&quot;127.0.0.1:6379&gt; rpop list   #移除list的最后一个元素&quot;right&quot;127.0.0.1:6379&gt; lrange list 0 -11) &quot;two&quot;2) &quot;one&quot;##########################################################################Lindex127.0.0.1:6379&gt; lrange list 0 -11) &quot;two&quot;2) &quot;one&quot;127.0.0.1:6379&gt; lindex list 1  #通过下标获得list的某一个值&quot;one&quot;127.0.0.1:6379&gt; lindex list 0&quot;two&quot;##########################################################################Llen127.0.0.1:6379&gt; lpush list one(integer) 1127.0.0.1:6379&gt; lpush list two(integer) 2127.0.0.1:6379&gt; lpush list three(integer) 3127.0.0.1:6379&gt; llen list(integer) 3##########################################################################移除指定的值取关 uidLrem127.0.0.1:6379&gt; lrange list 0 -11) &quot;three&quot;2) &quot;three&quot;3) &quot;two&quot;4) &quot;one&quot;127.0.0.1:6379&gt; lrem list 1 one   #移除list集合中指定个数的value，精准匹配(integer) 1127.0.0.1:6379&gt; lrange list 0 -11) &quot;three&quot;2) &quot;three&quot;3) &quot;two&quot;127.0.0.1:6379&gt; lrem list 1 three(integer) 1127.0.0.1:6379&gt; lrange list 0 -11) &quot;three&quot;2) &quot;two&quot;127.0.0.1:6379&gt; lpush list three(integer) 3127.0.0.1:6379&gt; lrem list 2 three(integer) 2127.0.0.1:6379&gt; lrange list 0 -11) &quot;two&quot;##########################################################################trim 修建：list截断！127.0.0.1:6379&gt; rpush mylist &quot;hello&quot;(integer) 1127.0.0.1:6379&gt; rpush mylist &quot;hello1&quot;(integer) 2127.0.0.1:6379&gt; rpush mylist &quot;hello2&quot;(integer) 3127.0.0.1:6379&gt; rpush mylist &quot;hello3&quot;(integer) 4127.0.0.1:6379&gt; ltrim mylist 1 2  #通过下标截取指定的长度，这个list已经改变了，截断了只剩下截取得元素OK127.0.0.1:6379&gt; lrange mylist 0 -11) &quot;hello1&quot;2) &quot;hello2&quot;##########################################################################rpoplpush #移除列表最后一个元素127.0.0.1:6379&gt; lrange mylist 0 -11) &quot;hello1&quot;2) &quot;hello2&quot;3) &quot;hello3&quot;127.0.0.1:6379&gt; rpoplpush mylist myotherlist  #移除列表的最后一个元素，将他移动到新的列表中&quot;hello3&quot;127.0.0.1:6379&gt; lrange mylist 0 -1 1) &quot;hello1&quot;2) &quot;hello2&quot;127.0.0.1:6379&gt; lrange myotherlist 0 -11) &quot;hello3&quot;##########################################################################lset 将列表中指定下标的值替换成另外一个值，更新操作127.0.0.1:6379&gt; exists list  #判断这个列表是否存在(integer) 0127.0.0.1:6379&gt; lset list 0 item  #如果不存在列表我们去更新就会报错(error) ERR no such key127.0.0.1:6379&gt; lpush list value1(integer) 1127.0.0.1:6379&gt; lrange list 0 01) &quot;value1&quot;127.0.0.1:6379&gt; lset list 0 item  #如果存在，更新当前下标的值OK127.0.0.1:6379&gt; lrange list 0 01) &quot;item&quot;127.0.0.1:6379&gt; lset list 1 other  #如果不存在，就会报错(error) ERR index out of range##########################################################################linset  #将某个具体的value插入到列表中某个元素的前面或者后面127.0.0.1:6379&gt; rpush mylist &quot;hello&quot;(integer) 1127.0.0.1:6379&gt; rpush mylist &quot;world&quot;(integer) 2127.0.0.1:6379&gt; linsert mylist before &quot;world&quot; &quot;other&quot;(integer) 3127.0.0.1:6379&gt; lrange mylist 0 -11) &quot;hello&quot;2) &quot;other&quot;3) &quot;world&quot;127.0.0.1:6379&gt; linsert mylist after &quot;other&quot; &quot;mew&quot;(integer) 4127.0.0.1:6379&gt; lrange mylist 0 -11) &quot;hello&quot;2) &quot;other&quot;3) &quot;mew&quot;4) &quot;world&quot;


小结


他实际上是一个链表，before node after left right都可以插入值
如果key不存在，则创建新的链表
如果key存在，新增内容
如果移除了所有值，空链表，也代表不存在
在量变插入欧哲该冬至，效率最高，中间元素，相对来说效率会低一点

消息排队！消息队列（Lpush Rpop）  栈（Lpush，Lpop）
Setset的值是不能重读的！
##########################################################################127.0.0.1:6379&gt; sadd myset &quot;hello&quot;(integer) 1127.0.0.1:6379&gt; sadd myset &quot;zhoudian&quot;(integer) 1127.0.0.1:6379&gt; sadd myset nihaolcdzzz(integer) 1127.0.0.1:6379&gt; smembers myset  #查看指定set的所有值  遍历1) &quot;hello&quot;2) &quot;nihaolcdzzz&quot;3) &quot;zhoudian&quot;127.0.0.1:6379&gt; sismember myset hello  #判断某一个值是否在set集合中！(integer) 1127.0.0.1:6379&gt; sismember myset world(integer) 0##########################################################################127.0.0.1:6379&gt; scard myset  #获取set集合中的内容元素个数(integer) 3##########################################################################rem127.0.0.1:6379&gt; smembers myset  #移除set集合中的指定元素（删除）1) &quot;hello&quot;2) &quot;nihaolcdzzz&quot;3) &quot;zhoudian&quot;127.0.0.1:6379&gt; srem myset hello(integer) 1127.0.0.1:6379&gt; scard myset(integer) 2127.0.0.1:6379&gt; smembers myset1) &quot;nihaolcdzzz&quot;2) &quot;zhoudian&quot;##########################################################################set 无序不重复集合127.0.0.1:6379&gt; srandmember myset&quot;zhoudian&quot;127.0.0.1:6379&gt; srandmember myset&quot;zhoudian&quot;127.0.0.1:6379&gt; srandmember myset&quot;nihaolcdzzz&quot;127.0.0.1:6379&gt; srandmember myset 2 #随机抽选出指定个数的元素1) &quot;nihaolcdzzz&quot;2) &quot;zhoudian&quot;##########################################################################随记删除key127.0.0.1:6379&gt; smembers myset1) &quot;hello&quot;2) &quot;nihaolcdzzz&quot;3) &quot;zhoudian&quot;4) &quot;world&quot;127.0.0.1:6379&gt; spop myset  #随机删除&quot;nihaolcdzzz&quot;127.0.0.1:6379&gt; spop myset&quot;zhoudian&quot;##########################################################################将一个指定的值，移动到另一个set集合！127.0.0.1:6379&gt; sadd myset &quot;hello&#x27;Invalid argument(s)127.0.0.1:6379&gt; sadd myset &quot;hello&quot;(integer) 1127.0.0.1:6379&gt; sadd myset world(integer) 1127.0.0.1:6379&gt; sadd myset zhoudian(integer) 1127.0.0.1:6379&gt; sadd myset2 set2(integer) 1127.0.0.1:6379&gt; smove myset myset2 zhoudian(integer) 1127.0.0.1:6379&gt; smembers myset1) &quot;hello&quot;2) &quot;world&quot;127.0.0.1:6379&gt; smembers myset21) &quot;zhoudian&quot;2) &quot;set2&quot;############################################################################微博，B站，共同关注！（并集）数字集合类127.0.0.1:6379&gt; sadd key1 a(integer) 1127.0.0.1:6379&gt; sadd key1 b(integer) 1127.0.0.1:6379&gt; sadd key1 c(integer) 1127.0.0.1:6379&gt; sadd key2 c(integer) 1127.0.0.1:6379&gt; sadd key2 d(integer) 1127.0.0.1:6379&gt; sadd key2 e(integer) 1127.0.0.1:6379&gt; sdiff key1 key2 #差集（key有1) &quot;a&quot;2) &quot;b&quot;127.0.0.1:6379&gt; SINTER key1 key2 #交集1) &quot;c&quot;127.0.0.1:6379&gt; sunion key1 key2 #并集2) &quot;c&quot;3) &quot;a&quot;4) &quot;e&quot;5) &quot;d&quot;

微博，A用户将所有关注的人放在set集合中！将它的粉丝也放在一个集合中
共同关注，共同爱好，二度好友（共同好友）
Hash（哈希）Map集合，key-map！这时候这个值是一个map的集合！本质和String类型没有太大区别，还是一个简单的key-value！
set myhash field zhoudian
127.0.0.1:6379&gt; hset myhash field1 zhoudian #set一个具体的key -value(integer) 1127.0.0.1:6379&gt; hget myhash(error) ERR wrong number of arguments for &#x27;hget&#x27; command127.0.0.1:6379&gt; hget myhash field1&quot;zhoudian&quot;127.0.0.1:6379&gt; hmset myhash field1 hello field2 world #set多个具体的key -valueOK127.0.0.1:6379&gt; hmget myhash field1 field21) &quot;hello&quot;2) &quot;world&quot;127.0.0.1:6379&gt; hset myhash field1 zhoudian(integer) 0127.0.0.1:6379&gt; hmget myhash field1 field2  #获取多个字段值（字段值）1) &quot;zhoudian&quot;2) &quot;world&quot;127.0.0.1:6379&gt; hgetall myhash  #获取全部的数据（遍历）【展示形式就是：key-value]1) &quot;field1&quot;2) &quot;zhoudian&quot;3) &quot;field2&quot;4) &quot;world&quot;127.0.0.1:6379&gt; hgetall myhash1) &quot;field1&quot;2) &quot;zhoudian&quot;3) &quot;field2&quot;4) &quot;world&quot;127.0.0.1:6379&gt; hdel myhash field1 #删除hash指定的key字段！对应的value值也没了(integer) 1127.0.0.1:6379&gt; hgetall myhash1) &quot;field2&quot;2) &quot;world&quot;############################################################################hlen127.0.0.1:6379&gt; hdel myhash field1(integer) 1127.0.0.1:6379&gt; hgetall myhash1) &quot;field2&quot;2) &quot;world&quot;127.0.0.1:6379&gt;  hlen myhash  #获取hash表的字段数量(integer) 1############################################################################127.0.0.1:6379&gt; hexists myhash field1 #获取hash中指定的字段是否存在(integer) 0127.0.0.1:6379&gt; hexists myhash field2(integer) 1############################################################################只获取所有field只获取所有的value127.0.0.1:6379&gt; hkeys myhash  #只获取所有的field1) &quot;field2&quot;2) &quot;field1&quot;127.0.0.1:6379&gt; hvals myhash  #只获取所有的value1) &quot;world&quot;2) &quot;zhoudian&quot;############################################################################incr decr127.0.0.1:6379&gt; hset myhash field3 5   #指定增量(integer) 1127.0.0.1:6379&gt; hincrby myhash field3 1(integer) 6127.0.0.1:6379&gt; hincrby myhash field3 1(integer) 7127.0.0.1:6379&gt; hincrby myhash field3 -1(integer) 6127.0.0.1:6379&gt; hget myhash field3&quot;6&quot;127.0.0.1:6379&gt; hsetnx myhash field4 hello #如果不存在则可以设置(integer) 1127.0.0.1:6379&gt; hsetnx myhash field4 world #如果存在则不可以设置(integer) 0

hash变更的数据 user name age，尤其是用户信息的保存更换，和经常变动的信息！hash更适合存对象，String更适合存储字符
127.0.0.1:6379&gt; mset user1:name zhoudian user1:age 22OK127.0.0.1:6379&gt; mget user1:name user1:age1) &quot;zhoudian&quot;2) &quot;22&quot;127.0.0.1:6379&gt; hset user1 name zhoudian age 22(integer) 1127.0.0.1:6379&gt; hget user1 name&quot;zhoudian&quot;127.0.0.1:6379&gt; hget user1 age&quot;22&quot;127.0.0.1:6379&gt; hgetall user11) &quot;name&quot;2) &quot;zhoudian&quot;3) &quot;age&quot;4) &quot;22&quot;127.0.0.1:6379&gt; hget user1 name age(error) ERR wrong number of arguments for &#x27;hget&#x27; command





Zset（有序集合）在set基础上，增加了一个值，set k1 v1    zset k1 score1 v1
127.0.0.1:6379&gt; zadd myset 1 one  #添加一个值(integer) 1127.0.0.1:6379&gt; zadd myset 2 two 3 three  #添加多个值(integer) 2127.0.0.1:6379&gt; zrange myset 0 -11) &quot;one&quot;2) &quot;two&quot;3) &quot;three&quot;############################################################################排序实现127.0.0.1:6379&gt; zadd salary 2500 xiaohong  #添加三个用户(integer) 1127.0.0.1:6379&gt; zadd salary 5000 zhangsan(integer) 1127.0.0.1:6379&gt; zadd salary 500 zhoudian(integer) 1#ZRANGEBYSCORE key min max127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf  #显示全部用户，从小到大排序（遍历，升序）1) &quot;zhoudian&quot;2) &quot;xiaohong&quot;3) &quot;zhangsan&quot;127.0.0.1:6379&gt; zrevrange salary 0 -1  #从打到小排序（遍历，降序）1) &quot;zhangsan&quot;2) &quot;zhoudian&quot;127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf withscores  #显示全部用户，从小到大排序（遍历）并且附带成绩&quot;2) &quot;500&quot;3) &quot;xiaohong&quot;4) &quot;2500&quot;5) &quot;zhangsan&quot;6) &quot;5000&quot;127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf 2500 withscores #显示工资小于等于2500员工的升序排序1) &quot;zhoudian&quot;2) &quot;500&quot;3) &quot;xiaohong&quot;4) &quot;2500&quot;127.0.0.1:6379&gt; zrevrange salary 0 -1 withscores  #降序1) &quot;zhangsan&quot;2) &quot;5000&quot;3) &quot;xiaohong&quot;4) &quot;2500&quot;5) &quot;zhoudian&quot;6) &quot;500&quot;############################################################################rem 删除127.0.0.1:6379&gt; zcard salary  #获取有序集合中的个数(integer) 3127.0.0.1:6379&gt; zrem salary xiaohong  #移除有序集合中的指定元素(integer) 1127.0.0.1:6379&gt; zcard salary(integer) 2############################################################################127.0.0.1:6379&gt; zadd myset 1 hello(integer) 1127.0.0.1:6379&gt; zadd myset 2 world 3 zhoudian(integer) 2127.0.0.1:6379&gt; zcount myset 1 3  #获取指定区间的成员变量(integer) 3127.0.0.1:6379&gt; zcount myset 1 2(integer) 2

案例思路： set排序 、存储班级成绩表 、工资表排序！
普通信息 1  ，重要信息 2  。带权进行判断！
排行榜引用实现，取TOP N测试！
三种特殊数据类型geospatial 地理位置朋友的定位，附近的人，打车距离计算
Redis 的Geo仔redis3.2版本就退出了！这个功能可以推算地理位置的信息，两地之间的距离，方圆几里的人
可以查询一些测试数据：http://www.jsons.cn/lngcode/
只有6个命令

  .uwfzkmsgxlxj{width:70%}


官方文档：https://www.redis.net.cn/order/3685.html

getadd

#getadd 添加地理位置#规则：两级无法直接添加，我们一般会下载城市数据，直接通过java程序一次行导入#有效经度从-180到180度#有效纬度从-85.05112878度到85.05112878度	#参数 key  值（纬度，经度，名称）127.0.0.1:6379&gt; geoadd china:city 116.40 39.90 beijing(integer) 1127.0.0.1:6379&gt; geoadd china:city 121.47 31.23 shanghai(integer) 1127.0.0.1:6379&gt; geoadd china:city 106.50 29.53 chongqing 114.05 22.52 shenzhen(integer) 2127.0.0.1:6379&gt; geoadd china:city 120.16 30.24 hangzhou 108.96 34.26 xian(integer) 2




getpos

获得当前定位：一定是坐标值
127.0.0.1:6379&gt; geopos china:city beijing  # 获取指定的城市的经度和纬度1) 1) &quot;116.39999896287918091&quot;   2) &quot;39.90000009167092543&quot;127.0.0.1:6379&gt; geopos china:city beijing chongqing1) 1) &quot;116.39999896287918091&quot;   2) &quot;39.90000009167092543&quot;2) 1) &quot;106.49999767541885376&quot;   2) &quot;29.52999957900659211&quot;





geodist

两人之间的距离！
单位：

m表示单位为米
km&#x3D;&#x3D;&#x3D;&#x3D;千米
mi&#x3D;&#x3D;&#x3D;&#x3D;英里
ft&#x3D;&#x3D;&#x3D;&#x3D;英尺

127.0.0.1:6379&gt; geodist china:city beijing shanghai  #查看北京到上海的直线距离&quot;1067378.7564&quot;127.0.0.1:6379&gt; geodist china:city beijing shanghai km&quot;1067.3788&quot;127.0.0.1:6379&gt; geodist china:city beijing shanghai ft&quot;3501898.8071&quot;




georadius以给定的经纬度为中心，找出某一半径内的元素

我附近的人？（获取所有附近的人的地址，定位！）通过半径来查询
127.0.0.1:6379&gt; georadius china:city 110 30 1000 km  #以110，30这个经纬度为中心，寻找方圆1000km内的城市1) &quot;chongqing&quot;2) &quot;xian&quot;3) &quot;shenzhen&quot;4) &quot;hangzhou&quot;127.0.0.1:6379&gt; georadius china:city 110 30 500 km1) &quot;chongqing&quot;2) &quot;xian&quot;127.0.0.1:6379&gt; georadius china:city 110 30 500 km withdist  #显示到中心位置的距离1) 1) &quot;chongqing&quot;   2) &quot;341.9374&quot;2) 1) &quot;xian&quot;   2) &quot;483.8340&quot;127.0.0.1:6379&gt; georadius china:city 110 30 500 km withcoord  #显示他人的定位信息（也是经度纬度）1) 1) &quot;chongqing&quot;   2) 1) &quot;106.49999767541885376&quot;      2) &quot;29.52999957900659211&quot;2) 1) &quot;xian&quot;   2) 1) &quot;108.96000176668167114&quot;      2) &quot;34.25999964418929977&quot;127.0.0.1:6379&gt; georadius china:city 110 30 500 km withcoord count 1  #筛选出指定的数量1) 1) &quot;chongqing&quot;   2) 1) &quot;106.49999767541885376&quot;      2) &quot;29.52999957900659211&quot;127.0.0.1:6379&gt; georadius china:city 110 30 500 km withcoord count 21) 1) &quot;chongqing&quot;   2) 1) &quot;106.49999767541885376&quot;      2) &quot;29.52999957900659211&quot;2) 1) &quot;xian&quot;   2) 1) &quot;108.96000176668167114&quot;      2) &quot;34.25999964418929977&quot;




georadiusbymember

#找出位于指定元素周围的其他元素！127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city beijing 1000 km1) &quot;beijing&quot;2) &quot;xian&quot;127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city shanghai 400 km1) &quot;hangzhou&quot;2) &quot;shanghai&quot;




geohash命令 - 返回一个或多个位置元素的geohash表示

该命令将返回11个字符的geohash！
#将二维的经纬度转换为一维的字符串，如果两个字符串越接近，则距离也就越接近127.0.0.1:6379&gt; geohash china:city beijing chongqing1) &quot;wx4fbxxfke0&quot;2) &quot;wm5xzrybty0&quot;




GEO 底层是实现原理就是Zset！我们可以用Zset命令来操作geo！

#查看地图中全部的元素127.0.0.1:6379&gt; zrange china:city 0 -11) &quot;chongqing&quot;2) &quot;xian&quot;3) &quot;shenzhen&quot;4) &quot;hangzhou&quot;5) &quot;shanghai&quot;6) &quot;beijing&quot;127.0.0.1:6379&gt; zrem china:city beijing(integer) 1127.0.0.1:6379&gt; zrange china:city 0 -11) &quot;chongqing&quot;2) &quot;xian&quot;3) &quot;shenzhen&quot;4) &quot;hangzhou&quot;5) &quot;shanghai&quot;



hyperloglog
什么是基数？

A{1,3,5,7,8,7}    B{1,3,5,7,8}
基数（不重复的元素） &#x3D; 5  

简介

Redis2.8.9版本就更新了这个数据结构
Redis Hyperloglog 基数统计的算法
优点：占用的内存是固定的，2^64不同的元素的计数，只需要12KB内存，如果要从内存角度来比较的话Hypeloglog是首选！
网页的UV(一个人访问一个网站多次，但是还是算作一个人！）
传统的方式，用set保存用户的id，然后就可以统计set中的元素数量作为标准判断
这个方式如果保存大量的用户id，就会比较麻烦！我们的目的是基数，而不是保存用户id；
有0.81%的错误率，统计UV任务，这个是可以忽略不计的！

测试使用

127.0.0.1:6379&gt; PFadd mykey a b c b e f g h  #创建第一组元素 mykey(integer) 1127.0.0.1:6379&gt; pfcount mykey  #统计mykey元素的基数数量(integer) 7127.0.0.1:6379&gt; pfadd mykey2 a v e f g a f g  #创建第二组元素mykey2(integer) 1127.0.0.1:6379&gt; pfcount mykey2(integer) 5127.0.0.1:6379&gt; pfmerge mykey3 mykey mykey2  合并两组取并集 mykey + mykey2 =&gt; mykey3OK127.0.0.1:6379&gt; pfcount mykey3  #看并集的数量(integer) 8



Bitmap
位存储

统计疫情感染数，统计用户信息，活跃，不活跃！登录，不登录！打卡，365打卡！表示两个状态的，都可以使用Bitmaps
Bitmaps位图，数据结构！都是操作二进制位来进行记录，就只有0和1两个状态 

实例：使用bitmap来记录周一到周日的打卡！

127.0.0.1:6379&gt; setbit sign 0 1(integer) 0127.0.0.1:6379&gt; setbit sign 1 0(integer) 0127.0.0.1:6379&gt; setbit sign 2 0(integer) 0127.0.0.1:6379&gt; setbit sign 3 1(integer) 0127.0.0.1:6379&gt; setbit sign 4 1(integer) 0127.0.0.1:6379&gt; setbit sign 5 0(integer) 0127.0.0.1:6379&gt; setbit sign 6 0  #录用打卡信息(integer) 0127.0.0.1:6379&gt; getbit sign 3    #(integer) 1127.0.0.1:6379&gt; getbit sign 6(integer) 0127.0.0.1:6379&gt; bitcount sign  #统计这周打卡天数(integer) 3











事务Redis事务本质：一组命令的集合！一个事务中的所有命令都会被序列化，在事务执行过程中，会按照顺序执行！一次性、顺序性、排他性！执行一系列命令！
---------队列 set set set执行---------



&#x3D;&#x3D;Redis事务没有隔离级别的概念&#x3D;&#x3D;
所有的命令在事务中，并没有直接被执行！只有发起执行命令的之后才会执行！Exec
&#x3D;&#x3D;Redis单条命令是保证原子性的，但是事务不保证原子性！&#x3D;&#x3D;
redis的事务：

开启事务（multi）
命令入队（…）
执行事务（exec）


正常执行事务！

127.0.0.1:6379&gt; multi  #开启事务OK#命令入队127.0.0.1:6379(TX)&gt; set k1 v1QUEUED127.0.0.1:6379(TX)&gt; set k2 v2QUEUED127.0.0.1:6379(TX)&gt; get k2QUEUED127.0.0.1:6379(TX)&gt; set k3 v3QUEUED127.0.0.1:6379(TX)&gt; exec  #执行事务1) OK2) OK3) &quot;v2&quot;4) OK




放弃事务！  

127.0.0.1:6379&gt; multi  #开启事务OK127.0.0.1:6379(TX)&gt; set k1 v1QUEUED127.0.0.1:6379(TX)&gt; set k2 v2QUEUED127.0.0.1:6379(TX)&gt; set k4 v4QUEUED127.0.0.1:6379(TX)&gt; discard  #取消事务OK127.0.0.1:6379&gt; get k4  #事务队列中命令都不会被执行(nil)  




编译型异常（代码有问题！命令有错！），事务中的所有命令都不会被执行！

127.0.0.1:6379&gt; multiOK127.0.0.1:6379(TX)&gt; set k1 v1QUEUED127.0.0.1:6379(TX)&gt; set k2 v2QUEUED127.0.0.1:6379(TX)&gt; set k3 v3QUEUED127.0.0.1:6379(TX)&gt; getset k3(error) ERR wrong number of arguments for &#x27;getset&#x27; command127.0.0.1:6379(TX)&gt; set k4 v4QUEUED127.0.0.1:6379(TX)&gt; set k5 v5QUEUED127.0.0.1:6379(TX)&gt; exec(error) EXECABORT Transaction discarded because of previous errors.127.0.0.1:6379&gt; get k5(nil)






运行时异常（1&#x2F;0），如果事务队列中存在与发行，name执行命令的时候，其他命令是可以正常执行的，错误命令抛出异常！

127.0.0.1:6379&gt; set k1 &quot;v1&quot;OK127.0.0.1:6379&gt; multiOK127.0.0.1:6379(TX)&gt; incr k1  #执行的时候失败QUEUED127.0.0.1:6379(TX)&gt; set k2 v2QUEUED127.0.0.1:6379(TX)&gt; set k3 v3QUEUED127.0.0.1:6379(TX)&gt; get k3QUEUED127.0.0.1:6379(TX)&gt; exec1) (error) ERR value is not an integer or out of range #虽然第一条命令报错了，但是依旧正常执行成功！2) OK3) OK4) &quot;v3&quot;127.0.0.1:6379&gt; get k2&quot;v2&quot;127.0.0.1:6379&gt; get k3&quot;v3&quot;




监控！ Watch

悲观锁：

很悲观，认为什么时候都会出问题，无论做什么都会加锁

乐观锁：

很乐观，认为什么时候都不会出问题，所以不会加锁！更新数据的时候去判断下，在此期间是否有人修改过这个数据
获取version
更新的时候比较version


Redis的监视测试

正常执行成功！
127.0.0.1:6379&gt; set money 100OK127.0.0.1:6379&gt; set out 0OK127.0.0.1:6379&gt; watch money  #监视 money对象OK127.0.0.1:6379&gt; multi  #事务正常结束，数据期间没有发生变动，这个时候救护正常执行成功OK127.0.0.1:6379(TX)&gt; decrby money 20QUEUED127.0.0.1:6379(TX)&gt; incrby out 20QUEUED127.0.0.1:6379(TX)&gt; exec1) (integer) 802) (integer) 20



测试多线程修改值，使用watch可以当做redis的乐观锁操作！
127.0.0.1:6379&gt; watch money   #监视 money OK127.0.0.1:6379&gt; multiOK127.0.0.1:6379(TX)&gt; decrby money 10QUEUED127.0.0.1:6379(TX)&gt; incrby out 10QUEUED127.0.0.1:6379(TX)&gt;   #	执行之前，另外一个线程修改了我们的值，这个时候就会导致事务执行失败(nil)

如果修改失败，获取最新的值就好

  .dkkpoutkernx{width:70%}




Jedis我们要使用java来操作Redis

Jedis是Redis官方推荐的java连接开发工具！使用java操作Redis中间件！如果你要使用java操作redis，那么一定要对jedis十分的熟悉


测试

1、导入对应的依赖
&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;      &lt;dependency&gt;          &lt;groupId&gt;redis.clients&lt;/groupId&gt;          &lt;artifactId&gt;jedis&lt;/artifactId&gt;          &lt;version&gt;3.2.0&lt;/version&gt;      &lt;/dependency&gt;      &lt;!--fastjson--&gt;      &lt;dependency&gt;          &lt;groupId&gt;com.alibaba&lt;/groupId&gt;          &lt;artifactId&gt;fastjson&lt;/artifactId&gt;          &lt;version&gt;1.2.62&lt;/version&gt;      &lt;/dependency&gt;



2、编码测试：

连接数据库
操作命令
断开连接！

package com.lcdzzz;import redis.clients.jedis.Jedis;public class TestPing &#123;    public static void main(String[] args) &#123;        //new Jedis对象即可        Jedis jedis = new Jedis(&quot;127.0.0.1&quot;,6379);        //jedis 所有的命令就是我们之前学习的所有指令！        System.out.println(jedis.ping());    &#125;&#125;



常用的APIString 
List
Set
Hash
Zset

  .qennyumidmce{width:70%}



  .sbstldfqndij{width:70%}



  .nssrvsswwprx{width:70%}



  .rbkgibvlpovq{width:70%}



  .vhzmryyktkec{width:70%}



  .pbxrgijciiqf{width:70%}



  .lhtrgkjrvebs{width:70%}


Springboot整合SpringBoot操作数据：spring-daya jpa jdbc mongodb redis!
SpringData 也是和springboot齐名的项目！
说明：在springboot2.x之后，原来使用的jedis被替换成了lettuce？
jedis：采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全的，使用jedis pool连接池更像BIO
lettuce：采用netty，实例可以在多个线程中进行共享，不存在线程不安全的情况！可以减少线程数据了！更像NIO

整合测试一下

1、导入依赖
&lt;!--操作redis--&gt;		&lt;dependency&gt;			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;			&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;		&lt;/dependency&gt;



2、配置连接
spring.redis.host=127.0.0.1spring.redis.port=6379

3、测试！
package com.kuang;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.redis.connection.RedisConnection;import org.springframework.data.redis.core.RedisTemplate;@SpringBootTestclass Redis02SpringbootApplicationTests &#123;	@Autowired	private RedisTemplate redisTemplate;	@Test	void contextLoads() &#123;		//redisTemplate  操作不同的数据类型，api和指令是一样的		//opsForValue 操作字符串，类似String		//opsForList  操作List		//opsForSet		//opsForHash		//opsForZSet		//opsForGeo		//opsForHyperLogLog		//除了基本的操作，常用的方法都可以通过redisTemplate操作，比如事务，和基本的crud		//获取redis的链接对象		RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();		connection.flushDb();		connection.flushAll();		redisTemplate.opsForValue().set(&quot;mykey&quot;,&quot;zhoudianchenglongnihao&quot;);		System.out.println(redisTemplate.opsForValue().get(&quot;mykey&quot;));	&#125;&#125;



关于对象的保存

  .grgjyrmuxjop{width:70%}




Redis.conf详解Redis持久化Redis发布订阅Redis主从复制]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBootWMM</title>
    <url>/2022/01/20/SpringBootwmm/</url>
    <content><![CDATA[SpringBoot这个是动力节点王鹤老师讲课时候的笔记，我放上来纯属为了自己看这方便
第一章  JavaConfig
为什么要使用 Spring Boot
因为Spring， SpringMVC 需要使用的大量的配置文件 （xml文件）
还需要配置各种对象，把使用的对象放入到spring容器中才能使用对象
需要了解其他框架配置规则。

SpringBoot 就相当于 不需要配置文件的Spring+SpringMVC。 常用的框架和第三方库都已经配置好了。
拿来就可以使用了。

SpringBoot开发效率高，使用方便多了


1.1 JavaConfigJavaConfig: 使用java类作为xml配置文件的替代， 是配置spring容器的纯java的方式。 在这个java类这可以创建java对象，把对象放入spring容器中（注入到容器）， 
使用两个注解：
1）@Configuration ： 放在一个类的上面，表示这个类是作为配置文件使用的。
2）@Bean：声明对象，把对象注入到容器中。
例子：package com.bjpowernode.config;import com.bjpowernode.vo.Student;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * Configuration:表示当前类是作为配置文件使用的。 就是用来配置容器的 *       位置：在类的上面 * *  SpringConfig这个类就相当于beans.xml */@Configurationpublic class SpringConfig &#123;    /**     * 创建方法，方法的返回值是对象。 在方法的上面加入@Bean     * 方法的返回值对象就注入到容器中。     *     * @Bean: 把对象注入到spring容器中。 作用相当于&lt;bean&gt;     *     *     位置：方法的上面     *     *     说明：@Bean,不指定对象的名称，默认是方法名是 id     *     */    @Bean    public Student createStudent()&#123;        Student s1  = new Student();        s1.setName(&quot;张三&quot;);        s1.setAge(26);        s1.setSex(&quot;男&quot;);        return s1;    &#125;    /***     * 指定对象在容器中的名称（指定&lt;bean&gt;的id属性）     * @Bean的name属性，指定对象的名称（id）     */    @Bean(name = &quot;lisiStudent&quot;)    public Student makeStudent()&#123;        Student s2  = new Student();        s2.setName(&quot;李四&quot;);        s2.setAge(22);        s2.setSex(&quot;男&quot;);        return s2;    &#125;&#125;



1.2 @ImporResource@ImportResource 作用导入其他的xml配置文件， 等于 在xml 
&lt;import resources=&quot;其他配置文件&quot;/&gt;



例如：
@Configuration@ImportResource(value =&#123; &quot;classpath:applicationContext.xml&quot;,&quot;classpath:beans.xml&quot;&#125;)public class SpringConfig &#123;&#125;







1.3 @PropertyResource@PropertyResource: 读取properties属性配置文件。 使用属性配置文件可以实现外部化配置 ，
在程序代码之外提供数据。
步骤：

在resources目录下，创建properties文件， 使用k&#x3D;v的格式提供数据
在PropertyResource 指定properties文件的位置
使用@Value（value&#x3D;”${key}”）

@Configuration@ImportResource(value =&#123; &quot;classpath:applicationContext.xml&quot;,&quot;classpath:beans.xml&quot;&#125;)@PropertySource(value = &quot;classpath:config.properties&quot;)@ComponentScan(basePackages = &quot;com.bjpowernode.vo&quot;)public class SpringConfig &#123;&#125;



第二 章 Spring Boot2.1 介绍SpringBoot是Spring中的一个成员， 可以简化Spring，SpringMVC的使用。 他的核心还是IOC容器。
特点：

Create stand-alone Spring applications
 创建spring应用

Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files)
内嵌的tomcat， jetty ， Undertow 

Provide opinionated ‘starter’ dependencies to simplify your build configuration
提供了starter起步依赖，简化应用的配置。   
比如使用MyBatis框架 ， 需要在Spring项目中，配置MyBatis的对象 SqlSessionFactory ， Dao的代理对象
在SpringBoot项目中，在pom.xml里面, 加入一个 mybatis-spring-boot-starter依赖

Automatically configure Spring and 3rd party libraries whenever possible
尽可能去配置spring和第三方库。叫做自动配置（就是把spring中的，第三方库中的对象都创建好，放到容器中， 开发人员可以直接使用）

Provide production-ready features such as metrics, health checks, and externalized configuration
 提供了健康检查， 统计，外部化配置

Absolutely no code generation and no requirement for XML configuration
不用生成代码， 不用使用xml，做配置


2.2 创建Spring Boot项目2.2.1 第一种方式， 使用Spring提供的初始化器， 就是向导创建SpringBoot应用使用的地址： https://start.spring.io
SpringBoot项目的结构：
	
2.2.1  使用国内的地址https://start.springboot.io
	
2.3  注解的使用@SpringBootApplication符合注解：由@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan        1.@SpringBootConfiguration    @Configurationpublic @interface SpringBootConfiguration &#123;    @AliasFor(        annotation = Configuration.class    )    boolean proxyBeanMethods() default true;&#125;说明：使用了@SpringBootConfiguration注解标注的类，可以作为配置文件使用的，    可以使用Bean声明对象，注入到容器

2.@EnableAutoConfiguration
启用自动配置， 把java对象配置好，注入到spring容器中。例如可以把mybatis的对象创建好，放入到容器中
3.@ComponentScan
@ComponentScan 扫描器，找到注解，根据注解的功能创建对象，给属性赋值等等。默认扫描的包： @ComponentScan所在的类所在的包和子包。    



2.4 SpringBoot的配置文件配置文件名称： application
扩展名有： properties( k&#x3D;v) ;  yml ( k: v)
使用application.properties,   application.yml
例1：application.properties设置 端口和上下文
#设置端口号server.port=8082#设置访问应用上下文路径， contextpathserver.servlet.context-path=/myboot



例2： application.yml
server:  port: 8083  servlet:    context-path: /myboot2



2.5 多环境配置有开发环境， 测试环境， 上线的环境。
每个环境有不同的配置信息， 例如端口， 上下文件， 数据库url，用户名，密码等等
使用多环境配置文件，可以方便的切换不同的配置。
使用方式： 创建多个配置文件， 名称规则： application-环境名称.properties(yml)
创建开发环境的配置文件： application-dev.properties(  application-dev.yml )
创建测试者使用的配置： application-test.properties
2.6 @ConfigurationProperties@ConfigurationProperties: 把配置文件的数据映射为java对象。
属性：prefix 配置文件中的某些key的开头的内容。
@Component@ConfigurationProperties(prefix = &quot;school&quot;)public class SchoolInfo &#123;    private String name;    private String website;    private String address;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getWebsite() &#123;        return website;    &#125;    public void setWebsite(String website) &#123;        this.website = website;    &#125;    public String getAddress() &#123;        return address;    &#125;    public void setAddress(String address) &#123;        this.address = address;    &#125;    @Override    public String toString() &#123;        return &quot;SchoolInfo&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +                &quot;, website=&#x27;&quot; + website + &#x27;\&#x27;&#x27; +                &quot;, address=&#x27;&quot; + address + &#x27;\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;



application.properties
#配置端口号server.port=8082#context-pathserver.servlet.context-path=/myboot#自定义key=valueschool.name=动力节点school.website=www.bjpowernode.comschool.address=北京的大兴区site=www.bjpowernode.com





2.7  使用jspSpringBoot不推荐使用jsp ，而是使用模板技术代替jsp
使用jsp需要配置：
1） 加入一个处理jsp的依赖。 负责编译jsp文件
&lt;dependency&gt;    &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;    &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;&lt;/dependency&gt;




如果需要使用servlet， jsp，jstl的功能

&lt;dependency&gt;	&lt;groupId&gt;javax.servlet&lt;/groupId&gt;	&lt;artifactId&gt;jstl&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;	&lt;groupId&gt;javax.servlet&lt;/groupId&gt;	&lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;	&lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt;	&lt;version&gt;2.3.1&lt;/version&gt;&lt;/dependency&gt;




创建一个存放jsp的目录，一般叫做webapp

​    index.jsp

需要在pom.xml指定jsp文件编译后的存放目录。

  META-INF&#x2F;resources
5）创建Controller， 访问jsp
6）在application.propertis文件中配置视图解析器
2.8 使用容器你想通过代码，从容器中获取对象。
通过SpringApplication.run(Application.class, args); 返回值获取容器。
public static ConfigurableApplicationContext run(Class&lt;?&gt; primarySource, String... args) &#123;        return run(new Class[]&#123;primarySource&#125;, args);&#125;ConfigurableApplicationContext : 接口，是ApplicationContext的子接口public interface ConfigurableApplicationContext extends ApplicationContext



2.9 ComnandLineRunner 接口 ，  ApplcationRunner接口这两个接口都 有一个run方法。 执行时间在容器对象创建好后， 自动执行run（）方法。
可以完成自定义的在容器对象创建好的一些操作。
@FunctionalInterfacepublic interface CommandLineRunner &#123;    void run(String... args) throws Exception;&#125;@FunctionalInterfacepublic interface ApplicationRunner &#123;    void run(ApplicationArguments args) throws Exception;&#125;





第三章 Web组件讲三个内容： 拦截器， Servlet ，Filter
3.1 拦截器拦截器是SpringMVC中一种对象，能拦截器对Controller的请求。
拦截器框架中有系统的拦截器， 还可以自定义拦截器。  实现对请求预先处理。
实现自定义拦截器：

创建类实现SpringMVC框架的HandlerInterceptor接口
public interface HandlerInterceptor &#123;    default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        return true;    &#125;    default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception &#123;    &#125;    default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception &#123;    &#125;&#125;

2.需在SpringMVC的配置文件中，声明拦截器
&lt;mvc:interceptors&gt;	&lt;mvc:interceptor&gt;    	&lt;mvc:path=&quot;url&quot; /&gt;        &lt;bean class=&quot;拦截器类全限定名称&quot;/&gt;    &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;



SpringBoot中注册拦截器：
@Configurationpublic class MyAppConfig implements WebMvcConfigurer &#123;    //添加拦截器对象， 注入到容器中    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        //创建拦截器对象        HandlerInterceptor interceptor = new LoginInterceptor();        //指定拦截的请求uri地址        String path []= &#123;&quot;/user/**&quot;&#125;;        //指定不拦截的地址        String excludePath  [] = &#123;&quot;/user/login&quot;&#125;;        registry.addInterceptor(interceptor)                .addPathPatterns(path)                .excludePathPatterns(excludePath);    &#125;&#125;



3.2  Servlet在SpringBoot框架中使用Servlet对象。
使用步骤：

创建Servlet类。 创建类继承HttpServlet
注册Servlet ，让框架能找到Servlet

 例子：
1.创建自定义Servlet
//创建Servlet类public class MyServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        doPost(req,resp);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;       //使用HttpServletResponse输出数据，应答结果        resp.setContentType(&quot;text/html;charset=utf-8&quot;);        PrintWriter out  = resp.getWriter();        out.println(&quot;===执行的是Servlet==&quot;);        out.flush();        out.close();    &#125;&#125;




注册Servlet

@Configurationpublic class WebApplictionConfig &#123;    //定义方法， 注册Servlet对象    @Bean    public ServletRegistrationBean servletRegistrationBean()&#123;        //public ServletRegistrationBean(T servlet, String... urlMappings)        //第一个参数是 Servlet对象， 第二个是url地址        //ServletRegistrationBean bean =                //new ServletRegistrationBean( new MyServlet(),&quot;/myservlet&quot;);        ServletRegistrationBean bean = new ServletRegistrationBean();        bean.setServlet( new MyServlet());        bean.addUrlMappings(&quot;/login&quot;,&quot;/test&quot;); // &lt;url-pattern&gt;        return bean;    &#125;&#125;



3.3 过滤器FilterFilter是Servlet规范中的过滤器，可以处理请求， 对请求的参数， 属性进行调整。 常常在过滤器中处理字符编码
在框架中使用过滤器：

创建自定义过滤器类
注册Filter过滤器对象

例子：
// 自定义过滤器public class MyFilter implements Filter &#123;    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;        System.out.println(&quot;执行了MyFilter，doFilter &quot;);        filterChain.doFilter(servletRequest,servletResponse);    &#125;&#125;



注册Filter
@Configurationpublic class WebApplicationConfig &#123;    @Bean    public FilterRegistrationBean filterRegistrationBean()&#123;        FilterRegistrationBean bean  = new FilterRegistrationBean();        bean.setFilter( new MyFilter());        bean.addUrlPatterns(&quot;/user/*&quot;);        return bean;    &#125;&#125;



3.4 字符集过滤器CharacterEncodingFilter : 解决post请求中乱码的问题
在SpringMVC框架， 在web.xml 注册过滤器。 配置他的属性。 
第一种方式：
使用步骤：

配置字符集过滤器
@Configurationpublic class WebSystemConfig &#123;    //注册Servlet    @Bean    public ServletRegistrationBean servletRegistrationBean()&#123;        MyServlet myServlet = new MyServlet();        ServletRegistrationBean reg = new ServletRegistrationBean(myServlet,&quot;/myservlet&quot;);        return reg;    &#125;    //注册Filter    @Bean    public FilterRegistrationBean filterRegistrationBean()&#123;        FilterRegistrationBean reg = new FilterRegistrationBean();        //使用框架中的过滤器类        CharacterEncodingFilter filter  = new CharacterEncodingFilter();        //指定使用的编码方式        filter.setEncoding(&quot;utf-8&quot;);        //指定request ， response都使用encoding的值        filter.setForceEncoding(true);        reg.setFilter(filter);        //指定 过滤的url地址        reg.addUrlPatterns(&quot;/*&quot;);        return reg;    &#125;&#125;

修改application.properties文件， 让自定义的过滤器起作用


#SpringBoot中默认已经配置了CharacterEncodingFilter。 编码默认ISO-8859-1#设置enabled=false 作用是关闭系统中配置好的过滤器， 使用自定义的CharacterEncodingFilterserver.servlet.encoding.enabled=false



第二种方式
修改application.properties文件
server.port=9001server.servlet.context-path=/myboot#让系统的CharacterEncdoingFilter生效server.servlet.encoding.enabled=true#指定使用的编码方式server.servlet.encoding.charset=utf-8#强制request，response都使用charset属性的值server.servlet.encoding.force=true



第四章 ORM 操作 MySQL使用MyBatis框架操作数据，  在SpringBoot框架集成MyBatis
使用步骤：

mybatis起步依赖 ： 完成mybatis对象自动配置， 对象放在容器中

pom.xml 指定把src&#x2F;main&#x2F;java目录中的xml文件包含到classpath中

创建实体类Student

创建Dao接口 StudentDao , 创建一个查询学生的方法 

创建Dao接口对应的Mapper文件， xml文件， 写sql语句

创建Service层对象， 创建StudentService接口和他的实现类。 去dao对象的方法。完成数据库的操作

创建Controller对象，访问Service。

写application.properties文件
配置数据库的连接信息。


第一种方式 ： @Mapper@Mapper：放在dao接口的上面， 每个接口都需要使用这个注解。
/** * @Mapper：告诉MyBatis这是dao接口，创建此接口的代理对象。 *     位置：在类的上面 */@Mapperpublic interface StudentDao &#123;    Student selectById(@Param(&quot;stuId&quot;) Integer id);&#125;





第二种方式  @MapperScan/** * @MapperScan: 找到Dao接口和Mapper文件 *     basePackages：Dao接口所在的包名 */@SpringBootApplication@MapperScan(basePackages = &#123;&quot;com.bjpowernode.dao&quot;,&quot;com.bjpowernode.mapper&quot;&#125;)public class Application &#123;&#125;



第三种方式： Mapper文件和Dao接口分开管理 现在把Mapper文件放在resources目录下
1）在resources目录中创建子目录 （自定义的） ， 例如mapper
2）把mapper文件放到 mapper目录中
3）在application.properties文件中，指定mapper文件的目录
#指定mapper文件的位置mybatis.mapper-locations=classpath:mapper/*.xml#指定mybatis的日志mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl


在pom.xml中指定 把resources目录中的文件 ， 编译到目标目录中

&lt;!--resources插件--&gt;&lt;resources&gt;   &lt;resource&gt;      &lt;directory&gt;src/main/resources&lt;/directory&gt;      &lt;includes&gt;         &lt;include&gt;**/*.*&lt;/include&gt;      &lt;/includes&gt;   &lt;/resource&gt;&lt;/resources&gt;





第四个  事务Spring框架中的事务：
1） 管理事务的对象： 事务管理器（接口， 接口有很多的实现类）
​      例如：使用Jdbc或mybatis访问数据库，使用的事务管理器：DataSourceTransactionManager
2 ) 声明式事务：  在xml配置文件或者使用注解说明事务控制的内容
​     控制事务： 隔离级别，传播行为， 超时时间
3）事务处理方式：
​      1） Spring框架中的@Transactional
​      2)    aspectj框架可以在xml配置文件中，声明事务控制的内容
​    
SpringBoot中使用事务： 上面的两种方式都可以。
1）在业务方法的上面加入@Transactional ,  加入注解后，方法有事务功能了。
2）明确的在 主启动类的上面 ，加入@EnableTransactionManager
例子：
/** * @Transactional: 表示方法的有事务支持 *       默认：使用库的隔离级别， REQUIRED 传播行为； 超时时间  -1 *       抛出运行时异常，回滚事务 */@Transactional@Overridepublic int addStudent(Student student) &#123;    System.out.println(&quot;业务方法addStudent&quot;);    int rows  =  studentDao.insert(student);    System.out.println(&quot;执行sql语句&quot;);    //抛出一个运行时异常， 目的是回滚事务    //int m   = 10 / 0 ;    return rows;&#125;





第五章 接口架构风格 —RESTful接口： API（Application Programming Interface，应用程序接口）是一些预先定义的接口（如函数、HTTP接口），或指软件系统不同组成部分衔接的约定。 用来提供应用程序与开发人员基于某软件或硬件得以访问的一组例程，而又无需访问源码，或理解内部工作机制的细节。
接口（API）： 可以指访问servlet， controller的url，   调用其他程序的 函数
架构风格： api组织方式（样子）
   就是一个传统的：    http://localhost:9002/mytrans/addStudent?name=lisi&amp;age=26 
​                                      在地址上提供了 访问的资源名称addStudent, 在其后使用了get方式传递参数。
5.1  RESTRESTful架构风格
1)REST :  （英文： Representational State Transfer , 中文： 表现层状态转移)。
   REST：是一种接口的架构风格和设计的理念，不是标准。
   优点： 更简洁，更有层次
   表现层状态转移: 
​         表现层就是视图层， 显示资源的， 通过视图页面，jsp等等显示操作资源的结果。
​          状态： 资源变化
​         转移： 资源可以变化的。 资源能创建，new状态，  资源创建后可以查询资源， 能看到资源的内容，
这个资源内容 ，可以被修改， 修改后资源 和之前的不一样。  
2）REST中的要素：
   用REST表示资源和对资源的操作。  在互联网中，表示一个资源或者一个操作。 
   资源使用url表示的， 在互联网， 使用的图片，视频， 文本，网页等等都是资源。
   资源是用名词表示。
  对资源： 
​        查询资源： 看，通过url找到资源。 
​        创建资源： 添加资源
​        更新资源：更新资源 ，编辑
​        删除资源： 去除
​       
 资源使用url表示，通过名词表示资源。
​     在url中，使用名词表示资源， 以及访问资源的信息,  在url中，使用“ &#x2F; “ 分隔对资源的信息
​     http://localhost:8080/myboot/student/1001
 使用http中的动作（请求方式）， 表示对资源的操作（CURD）
   GET:  查询资源  –  sql select
​                 处理单个资源： 用他的单数方式
​                  http://localhost:8080/myboot/student/1001
​                 http://localhost:8080/myboot/student/1001/1
​                处理多个资源：使用复数形式
​                  http://localhost:8080/myboot/students/1001/1002
​                
   POST: 创建资源  – sql insert
​                http://localhost:8080/myboot/student
​                在post请求中传递数据
&lt;form action=&quot;http://localhost:8080/myboot/student&quot; method=&quot;post&quot;&gt;	姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;    年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot; /&gt;  &lt;/form&gt;


   PUT： 更新资源  –  sql  update
   &lt;form action=&quot;http://localhost:8080/myboot/student/1&quot; method=&quot;post&quot;&gt;	姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;    年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot; /&gt;         &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot; /&gt;  &lt;/form&gt;



   DELETE: 删除资源  – sql delete
&lt;a href=&quot;http://localhost:8080/myboot/student/1&quot;&gt;删除1的数据&lt;/a&gt;






 需要的分页，  排序等参数，依然放在  url的后面， 例如 
 http://localhost:8080/myboot/students?page=1&amp;pageSize=20
   &#96;
3） 一句话说明REST： 
​    使用url表示资源 ，使用http动作操作资源。

注解

  @PathVariable :  从url中获取数据
  @GetMapping:    支持的get请求方式，  等同于 @RequestMapping( method&#x3D;RequestMethod.GET)
  @PostMapping:  支持post请求方式 ，等同于 @RequestMapping( method&#x3D;RequestMethod.POST)
  @PutMapping:  支持put请求方式，  等同于 @RequestMapping( method&#x3D;RequestMethod.PUT)
   @DeleteMapping: 支持delete请求方式，  等同于 @RequestMapping( method&#x3D;RequestMethod.DELETE)
  @RestController:  符合注解， 是@Controller 和@ResponseBody组合。
​               在类的上面使用@RestController ， 表示当前类者的所有方法都加入了 @ResponseBody

Postman : 测试工具
使用Postman : 可以测试 get ，post ， put ，delete 等请求


5.2  在页面中或者ajax中，支持put，delete请求在SpringMVC中 有一个过滤器， 支持post请求转为put ,delete
过滤器： org.springframework.web.filter.HiddenHttpMethodFilter
作用： 把请求中的post请求转为 put ， delete
实现步骤：

application.properties(yml) : 开启使用 HiddenHttpMethodFilter 过滤器
在请求页面中，包含 _method参数， 他的值是 put， delete  ，  发起这个请求使用的post方式

第六章 RedisRedis ： 一个NoSQL数据库，  常用作 缓存使用 （cache）
Redis的数据类型： string  ,  hash  ,set  ,zset , list
Redis是一个中间件： 是一个独立的服务器。
java中著名的客户端： Jedis ，  lettuce ， Redisson
Spring,SpringBoot中有 一个RedisTemplate（StringRedisTemplate） ，处理和redis交互  
6.1  配置Windows版本的redisRedis-x64-3.2.100.rar 解压缩到一个 非中文 的目录
redis-server.exe：服务端， 启动后，不要关闭
redis-cli.exe：客户端， 访问redis中的数据
redisclient-win32.x86_64.2.0.jar : Redis图形界面客户端
执行方式： 在这个文件所在的目录，  执行 java -jar redisclient-win32.x86_64.2.0.jar
RedisTemplate 使用的  lettuce 客户端库
&lt;!--redis起步依赖： 直接在项目中使用RedisTemplate(StringRedisTemplate)--&gt;&lt;dependency&gt;   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;data-redis使用的   lettuce 客户端库在程序中使用RedisTemplate类的方法 操作redis数据， 实际就是调用的lettuce 客户端的中的方法





6.2 对比 StringRedisTemplate 和 RedisTemplateStringRedisTemplate ： 把k，v 都是作为String处理， 使用的是String的序列化 ， 可读性好
RedisTemplate ： 把k，v 经过了序列化存到redis。 k，v 是序列化的内容， 不能直接识别.
​                                 默认使用的jdk序列化， 可以修改为前提的序列化
 序列化：把对象转化为可传输的字节序列过程称为序列化。
反序列化：把字节序列还原为对象的过程称为反序列化。
为什么需要序列化
序列化最终的目的是为了对象可以跨平台存储，和进行网络传输。而我们进行跨平台存储和网络传输的方式就是IO，而我们的IO支持的数据格式就是字节数组。我们必须在把对象转成字节数组的时候就制定一种规则（序列化），那么我们从IO流里面读出数据的时候再以这种规则把对象还原回来（反序列化）。
什么情况下需要序列化
通过上面我想你已经知道了凡是需要进行“跨平台存储”和”网络传输”的数据，都需要进行序列化。
本质上存储和网络传输 都需要经过 把一个对象状态保存成一种跨平台识别的字节格式，然后其他的平台才可以通过字节信息解析还原对象信息。
序列化的方式
序列化只是一种拆装组装对象的规则，那么这种规则肯定也可能有多种多样，比如现在常见的序列化方式有：
JDK（不支持跨语言）、JSON、XML、Hessian、Kryo（不支持跨语言）、Thrift、Protofbuff、
Student( name&#x3D;zs, age&#x3D;20)   —-  { “name”:”zs”, “age”:20 }
java的序列化： 把java对象转为byte[], 二进制数据
json序列化：json序列化功能将对象转换为 JSON 格式或从 JSON 格式转换对象。例如把一个Student对象转换为JSON字符串{“name”:”李四”, “age”:29} )，反序列化(将JSON字符串 {“name”:”李四”, “age”:29} 转换为Student对象)
设置key或者value的序列化方式
// 使用RedisTemplate ，在存取值之前，设置序列化// 设置 key 使用String的序列化redisTemplate.setKeySerializer( new StringRedisSerializer());// 设置 value 的序列化redisTemplate.setValueSerializer( new StringRedisSerializer());redisTemplate.opsForValue().set(k,v);





第七章 SpringBoot集成Dubbo7.1  看 SpringBoot继承Dubbo的文档 https://github.com/apache/dubbo-spring-boot-project/blob/master/README_CN.md
7.2  公共项目独立的maven项目： 定义了接口和数据类
public class Student implements Serializable &#123;    private static final long serialVersionUID = 1901229007746699151L;    private Integer id;    private String name;    private Integer age;&#125;public interface StudentService &#123;    Student queryStudent(Integer id);&#125;



7.3  提供者创建SpringBoot项目
1） pom.xml
&lt;dependencies&gt;   &lt;!--加入公共项目的gav--&gt;   &lt;dependency&gt;      &lt;groupId&gt;com.bjpowernode&lt;/groupId&gt;      &lt;artifactId&gt;022-interface-api&lt;/artifactId&gt;      &lt;version&gt;1.0.0&lt;/version&gt;   &lt;/dependency&gt;   &lt;!--dubbo依赖--&gt;   &lt;dependency&gt;      &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;      &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;      &lt;version&gt;2.7.8&lt;/version&gt;   &lt;/dependency&gt;   &lt;!--zookeeper依赖--&gt;   &lt;dependency&gt;      &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;      &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;/artifactId&gt;      &lt;version&gt;2.7.8&lt;/version&gt;      &lt;type&gt;pom&lt;/type&gt;      &lt;exclusions&gt;         &lt;!-- 排除log4j依赖 --&gt;         &lt;exclusion&gt;            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;         &lt;/exclusion&gt;      &lt;/exclusions&gt;   &lt;/dependency&gt;&lt;/dependencies&gt;



2）实现接口
/** * 使用dubbo中的注解暴露服务 * @Component 可以不用加 */@DubboService(interfaceClass = StudentService.class,version = &quot;1.0&quot;,timeout = 5000)public class StudentServiceImpl implements StudentService &#123;    @Override    public Student queryStudent(Integer id) &#123;        Student student  = new Student();        if( 1001 == id)&#123;            student.setId(1001);            student.setName(&quot;------1001-张三&quot;);            student.setAge(20);        &#125; else if(1002  == id)&#123;            student.setId(1002);            student.setName(&quot;#######1002-李四&quot;);            student.setAge(22);        &#125;        return student;    &#125;&#125;



3）application.properties
#配置服务名称 dubbo:application name=&quot;名称&quot;spring.application.name=studentservice-provider#配置扫描的包， 扫描的@DubboServicedubbo.scan.base-packages=com.bjpowernode.service#配置dubbo协议#dubbo.protocol.name=dubbo#dubbo.protocol.port=20881#注册中心dubbo.registry.address=zookeeper://localhost:2181



4)在启动类的上面
@SpringBootApplication@EnableDubbopublic class ProviderApplication &#123;   public static void main(String[] args) &#123;      SpringApplication.run(ProviderApplication.class, args);   &#125;&#125;



7.4消费者创建SpringBoot项目
1） pom.xml
&lt;dependencies&gt;   &lt;!--加入公共项目的gav--&gt;   &lt;dependency&gt;      &lt;groupId&gt;com.bjpowernode&lt;/groupId&gt;      &lt;artifactId&gt;022-interface-api&lt;/artifactId&gt;      &lt;version&gt;1.0.0&lt;/version&gt;   &lt;/dependency&gt;   &lt;!--dubbo依赖--&gt;   &lt;dependency&gt;      &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;      &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;      &lt;version&gt;2.7.8&lt;/version&gt;   &lt;/dependency&gt;   &lt;!--zookeeper依赖--&gt;   &lt;dependency&gt;      &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;      &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;/artifactId&gt;      &lt;version&gt;2.7.8&lt;/version&gt;      &lt;type&gt;pom&lt;/type&gt;      &lt;exclusions&gt;         &lt;!-- 排除log4j依赖 --&gt;         &lt;exclusion&gt;            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;         &lt;/exclusion&gt;      &lt;/exclusions&gt;   &lt;/dependency&gt;&lt;/dependencies&gt;


创建了Controller 或者 Service都可以

@RestControllerpublic class DubboController &#123;    /**     * 引用远程服务， 把创建好的代理对象，注入给studentService     */    //@DubboReference(interfaceClass = StudentService.class,version = &quot;1.0&quot;)    /**     * 没有使用interfaceClass，默认的就是 引用类型的 数据类型      */    @DubboReference(version = &quot;1.0&quot;)    private StudentService studentService;    @GetMapping(&quot;/query&quot;)    public String queryStudent(Integer id)&#123;        Student student   = studentService.queryStudent(id);        return &quot;调用远程接口，获取对象：&quot;+student;    &#125;&#125;



3）application.properties
#指定服务名称spring.application.name=consumer-application#指定注册中心dubbo.registry.address=zookeeper://localhost:2181





7.5 练习使用的技术： SpringBoot ,Dubbo, Redis, MyBatis
Student表：
	
CREATE TABLE student (  id int(11) NOT NULL AUTO_INCREMENT,  name varchar(255) COLLATE utf8_bin DEFAULT NULL,  phone varchar(11) COLLATE utf8_bin DEFAULT NULL,  age int(11) DEFAULT NULL,  PRIMARY KEY (id)) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;6 DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_bin;

注册学生

​     phone必须唯一， 如果已经存在了手机号， 注册失败的。 
​                 int addStudent(Student student);
​                返回值：int
​                 1： 注册成功
​                 2 ： 手机号已经存在  
​                                    
​      name至少两个字符，
​      age 必须 大于 0 
2） 查询学生，根据id查询，此学生。 
​        先到redis查询学生， 如果redis没有此学生，从数据库查询， 把查询到的学生放入到redis。
​      后面再次查询这个学生应该从redis就能获取到。
​        Student  queryStudent(Integer id);

使用Dubbo框架，    addStudent, queryStudent 是有服务提供者实现的。

​    消费者可以是一个Controller ， 调用提供者的两个方法。  实现注册和查询。
4）页面使用html和ajax，jquery。
​       在html页面中提供 form 注册学生， 提供文本框输入id，进行查询。
​      注册和查询都使用ajax技术。
​    html，jquery.js都放到resources&#x2F;static目录中
第八章  打包8.1 打包war1.创建了一个jsp应用
2.修改pom.xml
 1)指定打包后的文件名称
&lt;build&gt;   &lt;!--打包后的文件名称--&gt;   &lt;finalName&gt;myboot&lt;/finalName&gt;&lt;/build&gt;



2)指定jsp编译目录
&lt;!--resources插件， 把jsp编译到指定的目录--&gt;&lt;resources&gt;   &lt;resource&gt;      &lt;directory&gt;src/main/webapp&lt;/directory&gt;      &lt;targetPath&gt;META-INF/resources&lt;/targetPath&gt;      &lt;includes&gt;         &lt;include&gt;**/*.*&lt;/include&gt;      &lt;/includes&gt;   &lt;/resource&gt;   &lt;!--使用了mybatis ，而且mapper文件放在src/main/java目录--&gt;   &lt;resource&gt;      &lt;directory&gt;src/main/java&lt;/directory&gt;      &lt;includes&gt;         &lt;include&gt;**/*.xml&lt;/include&gt;      &lt;/includes&gt;   &lt;/resource&gt;   &lt;!--把src/main/resources下面的所有文件，都包含到classes目录--&gt;   &lt;resource&gt;      &lt;directory&gt;src/main/resources&lt;/directory&gt;      &lt;includes&gt;         &lt;include&gt;**/*.*&lt;/include&gt;      &lt;/includes&gt;   &lt;/resource&gt;&lt;/resources&gt;



3）执行打包是war
&lt;!--打包类型--&gt;&lt;packaging&gt;war&lt;/packaging&gt;



4）主启动类继承SpringBootServletInitializer
/** * SpringBootServletInitializer: 继承这个类， 才能使用独立tomcat服务器 */@SpringBootApplicationpublic class JspApplication  extends SpringBootServletInitializer  &#123;   public static void main(String[] args) &#123;      SpringApplication.run(JspApplication.class, args);   &#125;   @Override   protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123;      return builder.sources(JspApplication.class);   &#125;&#125;



5）部署war
 把war放到tomcat等服务器的发布目录中。  tomcat为例， myboot.war放到tomcat&#x2F;webapps目录。
8.2 打包为jar1.创建了一个包含了jsp的项目
2.修改pom.xml
​     1) 指定打包后的文件名称
&lt;build&gt;   &lt;!--打包后的文件名称--&gt;   &lt;finalName&gt;myboot&lt;/finalName&gt;&lt;/build&gt;




指定springboot-maven-plugin版本

&lt;plugins&gt;   &lt;plugin&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;      &lt;!--打包jar， 有jsp文件时，必须指定maven-plugin插件的版本是 1.4.2.RELEASE--&gt;      &lt;version&gt;1.4.2.RELEASE&lt;/version&gt;   &lt;/plugin&gt;&lt;/plugins&gt;



3）最后执行 maven clean package
​       在target目录中，生成jar 文件， 例子是myboot.jar
​       执行独立的springboot项目  在cmd中 java  -jar  myboot.jar
第九章 Thymeleaf 模板引擎Thymeleaf： 是使用java开发的模板技术， 在服务器端运行。 把处理后的数据发送给浏览器。
​         模板是作视图层工作的。  显示数据的。  Thymeleaf是基于Html语言。 Thymleaf语法是应用在
​        html标签中 。 SpringBoot框架集成Thymealeaf,  使用Thymeleaf代替jsp 。
Thymeleaf 的官方网站：http://www.thymeleaf.orgThymeleaf 官方手册：https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html
9.1 表达式
标准变量表达式 
语法：  ${key} 
作用： 获取key对于的文本数据，  key 是request作用域中的key ， 使用request.setAttribute(), model.addAttribute()
在页面中的 html标签中， 使用 th:text&#x3D;”${key}”


&lt;div style=&quot;margin-left: 400px&quot;&gt;    &lt;h3&gt;标准变量表达式:  $&#123;key&#125;&lt;/h3&gt;    &lt;p th:text=&quot;$&#123;site&#125;&quot;&gt;key不存在&lt;/p&gt;    &lt;br/&gt;    &lt;p&gt;获取SysUser对象 属性值&lt;/p&gt;    &lt;p th:text=&quot;$&#123;myuser.id&#125;&quot;&gt;id&lt;/p&gt;    &lt;p th:text=&quot;$&#123;myuser.name&#125;&quot;&gt;姓名&lt;/p&gt;    &lt;p th:text=&quot;$&#123;myuser.sex&#125;&quot;&gt;姓名：m男&lt;/p&gt;    &lt;p th:text=&quot;$&#123;myuser.age&#125;&quot;&gt;年龄&lt;/p&gt;    &lt;p th:text=&quot;$&#123;myuser.getName()&#125;&quot;&gt;获取姓名使用getXXX&lt;/p&gt;&lt;/div&gt;




选择变量表达式（ 星号变量表达式）
语法：  *{key}
作用： 获取这个key对应的数据，   *{key}需要和th:object 这个属性一起使用。
目的是简单获取对象的属性值。
&lt;p&gt;使用 *&#123;&#125; 获取SysUser的属性值&lt;/p&gt;&lt;div th:object=&quot;$&#123;myuser&#125;&quot;&gt;    &lt;p th:text=&quot;*&#123;id&#125;&quot;&gt;&lt;/p&gt;    &lt;p th:text=&quot;*&#123;name&#125;&quot;&gt;&lt;/p&gt;    &lt;p th:text=&quot;*&#123;sex&#125;&quot;&gt;&lt;/p&gt;    &lt;p th:text=&quot;*&#123;age&#125;&quot;&gt;&lt;/p&gt;&lt;/div&gt;&lt;p&gt;使用*&#123;&#125;完成的表示 对象的属性值&lt;/p&gt;&lt;p th:text=&quot;*&#123;myuser.name&#125;&quot; &gt;&lt;/p&gt;

链接表达式
语法： @{url}
作用： 表示链接， 可以
&lt;script src=&quot;...&quot;&gt; , &lt;link href=&quot;...&quot;&gt; &lt;a href=&quot;..&quot;&gt; ,&lt;form action=&quot;...&quot;&gt; &lt;img src=&quot;...&quot;&gt;

9.2  Thymeleaf属性属性是放在html元素中的，就是html元素的属性，加入了th前缀。  属性的作用不变。    加入上th， 属性的值由模板引擎处理了。  在属性可以使用变量表达式
例如：
&lt;form action=&quot;/loginServlet&quot; method=&quot;post&quot;&gt;&lt;/form&gt;&lt;form th:action=&quot;/loginServlet&quot; th:method=&quot;$&#123;methodAttr&#125;&quot;&gt;&lt;/form&gt;





9.3 eacheach循环， 可以循环List，Array
语法：
在一个html标签中，使用th:each
&lt;div th:each=&quot;集合循环成员,循环的状态变量:$&#123;key&#125;&quot;&gt;    &lt;p th:text=&quot;$&#123;集合循环成员&#125;&quot; &gt;&lt;/p&gt;&lt;/div&gt;集合循环成员,循环的状态变量:两个名称都是自定义的。 “循环的状态变量”这个名称可以不定义，默认是&quot;集合循环成员Stat&quot;





each循环Map
在一个html标签中，使用th:each
&lt;div th:each=&quot;集合循环成员,循环的状态变量:$&#123;key&#125;&quot;&gt;    &lt;p th:text=&quot;$&#123;集合循环成员.key&#125;&quot; &gt;&lt;/p&gt;    &lt;p th:text=&quot;$&#123;集合循环成员.value&#125;&quot; &gt;&lt;/p&gt;&lt;/div&gt;集合循环成员,循环的状态变量:两个名称都是自定义的。 “循环的状态变量”这个名称可以不定义，默认是&quot;集合循环成员Stat&quot;key:map集合中的keyvalue：map集合key对应的value值





9.4 th:if“th:if”  : 判断语句， 当条件为true， 显示html标签体内， 反之不显示 没有else语句
语法：&lt;div th:if=&quot; 10 &gt; 0 &quot;&gt; 显示文本内容 &lt;/div&gt;



还有一个 th:unless  和 th:if相反的行为
语法：&lt;div th:unless=&quot; 10 &lt; 0 &quot;&gt; 当条件为false显示标签体内容 &lt;/div&gt;



例子：if
&lt;div style=&quot;margin-left: 400px&quot;&gt;        &lt;h3&gt; if 使用&lt;/h3&gt;        &lt;p th:if=&quot;$&#123;sex==&#x27;m&#x27;&#125;&quot;&gt;性别是男&lt;/p&gt;        &lt;p th:if=&quot;$&#123;isLogin&#125;&quot;&gt;已经登录系统&lt;/p&gt;        &lt;p th:if=&quot;$&#123;age &gt; 20&#125;&quot;&gt;年龄大于20&lt;/p&gt;        &lt;!--&quot;&quot;空字符是true--&gt;        &lt;p th:if=&quot;$&#123;name&#125;&quot;&gt;name是“”&lt;/p&gt;        &lt;!--null是false--&gt;        &lt;p th:if=&quot;$&#123;isOld&#125;&quot;&gt; isOld是null&lt;/p&gt; &lt;/div&gt;



例子： unless
&lt;div style=&quot;margin-left: 400px&quot;&gt;       &lt;h3&gt;unless: 判断条件为false，显示标签体内容&lt;/h3&gt;       &lt;p th:unless=&quot;$&#123;sex==&#x27;f&#x27;&#125;&quot;&gt;性别是男的&lt;/p&gt;       &lt;p th:unless=&quot;$&#123;isLogin&#125;&quot;&gt;登录系统&lt;/p&gt;       &lt;p th:unless=&quot;$&#123;isOld&#125;&quot;&gt; isOld是null &lt;/p&gt;&lt;/div&gt;





9.5  th:switchth:switch 和 java中的swith一样的
语法：&lt;div th:switch=&quot;要比对的值&quot;&gt;    &lt;p th:case=&quot;值1&quot;&gt;        结果1    &lt;/p&gt;    &lt;p th:case=&quot;值2&quot;&gt;        结果2    &lt;/p&gt;    &lt;p th:case=&quot;*&quot;&gt;        默认结果    &lt;/p&gt;    以上的case只有一个语句执行    &lt;/div&gt;





9.6 th:inline
内联text：  在html标签外，获取表达式的值
语法： 
&lt;p&gt;显示姓名是：[[$&#123;key&#125;]]&lt;/p&gt; &lt;div style=&quot;margin-left: 400px&quot;&gt;        &lt;h3&gt;内联 text, 使用内联表达式显示变量的值&lt;/h3&gt;        &lt;div th:inline=&quot;text&quot;&gt;            &lt;p&gt;我是[[$&#123;name&#125;]]，年龄是[[$&#123;age&#125;]]&lt;/p&gt;            我是&lt;span th:text=&quot;$&#123;name&#125;&quot;&gt;&lt;/span&gt;,年龄是&lt;span th:text=&quot;$&#123;age&#125;&quot;&gt;&lt;/span&gt;        &lt;/div&gt;        &lt;div&gt;            &lt;p&gt;使用内联text&lt;/p&gt;            &lt;p&gt;我是[[$&#123;name&#125;]],性别是[[$&#123;sex&#125;]]&lt;/p&gt;        &lt;/div&gt;&lt;/div&gt;



内联javascript


例子： &lt;script type=&quot;text/javascript&quot; th:inline=&quot;javascript&quot;&gt;         var myname = [[$&#123;name&#125;]];         var myage = [[$&#123;age&#125;]];         //alert(&quot;获取的模板中数据 &quot;+ myname + &quot;,&quot;+myage)        function fun()&#123;            alert(&quot;单击事件，获取数据 &quot;+ myname + &quot;,&quot;+ [[$&#123;sex&#125;]])        &#125;    &lt;/script&gt;



9.7  字面量例子：
&lt;div style=&quot;margin-left: 400px&quot;&gt;      &lt;h3&gt;文本字面量: 使用单引号括起来的字符串&lt;/h3&gt;      &lt;p th:text=&quot;&#x27;我是&#x27;+$&#123;name&#125;+&#x27;,我所在的城市&#x27;+$&#123;city&#125;&quot;&gt;数据显示&lt;/p&gt;      &lt;h3&gt;数字字面量&lt;/h3&gt;       &lt;p th:if=&quot;$&#123;20&gt;5&#125;&quot;&gt; 20大于 5&lt;/p&gt;       &lt;h3&gt;boolean字面量&lt;/h3&gt;       &lt;p th:if=&quot;$&#123;isLogin == true&#125;&quot;&gt;用户已经登录系统&lt;/p&gt;       &lt;h3&gt;null字面量&lt;/h3&gt;       &lt;p th:if=&quot;$&#123;myuser != null&#125;&quot;&gt;有myuser数据&lt;/p&gt;   &lt;/div&gt;



9.8  字符串连接连接字符串有两种语法
1） 语法使用 单引号括起来字符串  ， 使用 + 连接其他的 字符串或者表达式
&lt;p th:text=&quot;&#x27;我是&#x27;+$&#123;name&#125;+&#x27;,我所在的城市&#x27;+$&#123;city&#125;&quot;&gt;数据显示&lt;/p&gt;

2）语法：使用双竖线， |字符串和表达式|
&lt;p th:text=&quot;|我是$&#123;name&#125;,我所在城市$&#123;city|&quot;&gt;    显示数据&lt;/p&gt;



例子：
&lt;div style=&quot;margin-left: 400px&quot;&gt;   &lt;h3&gt;字符串连接方式1：使用单引号括起来的字符串&lt;/h3&gt;   &lt;p th:text=&quot;&#x27;我是&#x27;+$&#123;name&#125;+&#x27;,我所在的城市&#x27;+$&#123;city&#125;&quot;&gt;数据显示&lt;/p&gt;    &lt;br/&gt;    &lt;br/&gt;    &lt;h3&gt;字符串连接方式2：|字符串和表达式|&lt;/h3&gt;    &lt;p th:text=&quot;|我是$&#123;name&#125;,所在城市$&#123;city&#125;,其他人$&#123;myuser.name&#125;|&quot;&gt;&lt;/p&gt;&lt;/div&gt;



9.9 运算符算术运 算： + , - - , * , / , %关系比较 : &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le )相等判断： == , != ( eq , ne )&lt;div style=&quot;margin-left: 400px&quot;&gt;        &lt;h3&gt;使用运算符&lt;/h3&gt;        &lt;p th:text=&quot;$&#123;age &gt; 10&#125;&quot;&gt;年龄大于 10 &lt;/p&gt;        &lt;p th:text=&quot;$&#123; 20 + 30 &#125;&quot;&gt;显示运算结果&lt;/p&gt;        &lt;p th:if=&quot;$&#123;myuser == null&#125;&quot;&gt;myuser是null&lt;/p&gt;        &lt;p th:if=&quot;$&#123;myuser eq null&#125;&quot;&gt;myuser是null&lt;/p&gt;        &lt;p th:if=&quot;$&#123;myuser ne null&#125;&quot;&gt;myuser不是null&lt;/p&gt;        &lt;p th:text=&quot;$&#123;isLogin == true ? &#x27;用户已经登录&#x27; : &#x27;用户需要登录&#x27;&#125;&quot;&gt;&lt;/p&gt;        &lt;p th:text=&quot;$&#123;isLogin == true ? ( age &gt; 10 ? &#x27;用户是大于10的&#x27; : &#x27;用户年龄比较小&#x27;) : &#x27;用户需要登录&#x27;&#125;&quot;&gt;&lt;/p&gt;    &lt;/div&gt;三元运算符： 表达式  ？ true的结果 : false的结果三元运算符可以嵌套



9.10 内置对象文档地址：https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#web-context-namespaces-for-requestsession-attributes-etc.
#request 表示 HttpServletRequest
#session 表示 HttpSession对象
session 表示Map对象的， 是#session的简单表示方式， 用来获取session中指定的key的值
​               #session.getAttribute(“loginname”) &#x3D;&#x3D; session.loginname
这些是内置对象，可以在模板文件中直接使用。
例子： &lt;div style=&quot;margin-left: 350px&quot;&gt;        &lt;h3&gt;内置对象#request,#session，session的使用&lt;/h3&gt;        &lt;p&gt;获取作用域中的数据&lt;/p&gt;        &lt;p th:text=&quot;$&#123;#request.getAttribute(&#x27;requestData&#x27;)&#125;&quot;&gt;&lt;/p&gt;        &lt;p th:text=&quot;$&#123;#session.getAttribute(&#x27;sessionData&#x27;)&#125;&quot;&gt;&lt;/p&gt;        &lt;p th:text=&quot;$&#123;session.loginname&#125;&quot;&gt;&lt;/p&gt;        &lt;br/&gt;        &lt;br/&gt;        &lt;h3&gt;使用内置对象的方法&lt;/h3&gt;        getRequestURL=&lt;span th:text=&quot;$&#123;#request.getRequestURL()&#125;&quot;&gt;&lt;/span&gt;&lt;br/&gt;        getRequestURI=&lt;span th:text=&quot;$&#123;#request.getRequestURI()&#125;&quot;&gt;&lt;/span&gt;&lt;br/&gt;        getQueryString=&lt;span th:text=&quot;$&#123;#request.getQueryString()&#125;&quot;&gt;&lt;/span&gt;&lt;br/&gt;        getContextPath=&lt;span th:text=&quot;$&#123;#request.getContextPath()&#125;&quot;&gt;&lt;/span&gt;&lt;br/&gt;        getServerName=&lt;span th:text=&quot;$&#123;#request.getServerName()&#125;&quot;&gt;&lt;/span&gt;&lt;br/&gt;        getServerPort=&lt;span th:text=&quot;$&#123;#request.getServerPort()&#125;&quot;&gt;&lt;/span&gt;&lt;br/&gt;&lt;/div&gt;





9.11 内置工具类内置工具类型： Thymeleaf自己的一些类，提供对string， date ，集合的一些处理方法
#dates: 处理日器的工具类
#numbers:处理数字的
#lists: 处理list集合的
&lt;div style=&quot;margin-left: 350px&quot;&gt;      &lt;h3&gt;日期类对象 #dates&lt;/h3&gt;      &lt;p th:text=&quot;$&#123;#dates.format(mydate )&#125;&quot;&gt;&lt;/p&gt;      &lt;p th:text=&quot;$&#123;#dates.format(mydate,&#x27;yyyy-MM-dd&#x27;)&#125;&quot;&gt;&lt;/p&gt;      &lt;p th:text=&quot;$&#123;#dates.format(mydate,&#x27;yyyy-MM-dd HH:mm:ss&#x27;)&#125;&quot;&gt;&lt;/p&gt;      &lt;p th:text=&quot;$&#123;#dates.year(mydate)&#125;&quot;&gt;&lt;/p&gt;      &lt;p th:text=&quot;$&#123;#dates.month(mydate)&#125;&quot;&gt;&lt;/p&gt;      &lt;p th:text=&quot;$&#123;#dates.monthName(mydate)&#125;&quot;&gt;&lt;/p&gt;      &lt;p th:text=&quot;$&#123;#dates.createNow()&#125;&quot;&gt;&lt;/p&gt;      &lt;br/&gt;      &lt;h3&gt;内置工具类#numbers，操作数字的&lt;/h3&gt;      &lt;p th:text=&quot;$&#123;#numbers.formatCurrency(mynum)&#125;&quot;&gt;&lt;/p&gt;      &lt;p th:text=&quot;$&#123;#numbers.formatDecimal(mynum,5,2)&#125;&quot;&gt;&lt;/p&gt;      &lt;br/&gt;      &lt;h3&gt;内置工具类#strings,操作字符串&lt;/h3&gt;      &lt;p th:text=&quot;$&#123;#strings.toUpperCase(mystr)&#125;&quot;&gt;&lt;/p&gt;      &lt;p th:text=&quot;$&#123;#strings.indexOf(mystr,&#x27;power&#x27;)&#125;&quot;&gt;&lt;/p&gt;      &lt;p th:text=&quot;$&#123;#strings.substring(mystr,2,5)&#125;&quot;&gt;&lt;/p&gt;      &lt;p th:text=&quot;$&#123;#strings.substring(mystr,2)&#125;&quot;&gt;&lt;/p&gt;      &lt;p th:text=&quot;$&#123;#strings.concat(mystr,&#x27;---java开发的黄埔军校---&#x27;)&#125;&quot;&gt;&lt;/p&gt;      &lt;p th:text=&quot;$&#123;#strings.length(mystr)&#125;&quot;&gt;&lt;/p&gt;      &lt;p th:text=&quot;$&#123;#strings.length(&#x27;hello&#x27;)&#125;&quot;&gt;&lt;/p&gt;      &lt;p th:unless=&quot;$&#123;#strings.isEmpty(mystr)&#125;&quot;&gt; mystring 不是 空字符串  &lt;/p&gt;      &lt;br/&gt;      &lt;h3&gt;内置工具类#lists,操作list集合&lt;/h3&gt;      &lt;p th:text=&quot;$&#123;#lists.size(mylist)&#125;&quot;&gt;&lt;/p&gt;      &lt;p th:if=&quot;$&#123;#lists.contains(mylist,&#x27;a&#x27;)&#125;&quot;&gt;有成员a&lt;/p&gt;      &lt;p th:if=&quot;!$&#123;#lists.isEmpty(mylist)&#125;&quot;&gt; list 集合有多个成员&lt;/p&gt;      &lt;br/&gt;      &lt;h3&gt;处理null&lt;/h3&gt;      &lt;p th:text=&quot;$&#123;zoo?.dog?.name&#125;&quot;&gt;&lt;/p&gt;  &lt;/div&gt;



9.12 自定义模板模板是内容复用， 定义一次，在其他的模板文件中多次使用。
模板使用：
1.定义模板
2.使用模板
模板定义语法：
th:fragment=&quot;模板自定义名称&quot;例如：&lt;div th:fragment=&quot;head&quot;&gt;    &lt;p&gt;        动力节点-java开发    &lt;/p&gt;    &lt;p&gt;        www.bjpowernode.com    &lt;/p&gt;&lt;/div&gt;



引用模板语法：
1) ~&#123;templatename :: selector&#125;   templatename:  文件名称   selector： 自定义模板名称2）templatename :: selector   templatename:  文件名称   selector： 自定义模板名称对于使用模板：有包含模板（th:include）， 插入模板(th:insert)



第十章 总结10.1 注解Spring + SpringMVC + SpringBoot 
创建对象的：@Controller: 放在类的上面，创建控制器对象，注入到容器中@RestController: 放在类的上面，创建控制器对象，注入到容器中。             作用：复合注解是@Controller , @ResponseBody, 使用这个注解类的，里面的控制器方法的返回值                   都是数据@Service ： 放在业务层的实现类上面，创建service对象，注入到容器@Repository : 放在dao层的实现类上面，创建dao对象，放入到容器。 没有使用这个注解，是因为现在使用MyBatis框               架，  dao对象是MyBatis通过代理生成的。 不需要使用@Repository、 所以没有使用。@Component:  放在类的上面，创建此类的对象，放入到容器中。 赋值的：@Value ： 简单类型的赋值， 例如 在属性的上面使用@Value(&quot;李四&quot;) private String name          还可以使用@Value,获取配置文件者的数据（properties或yml）。           @Value(&quot;$&#123;server.port&#125;&quot;) private Integer port@Autowired: 引用类型赋值自动注入的，支持byName, byType. 默认是byType 。 放在属性的上面，也可以放在构造             方法的上面。 推荐是放在构造方法的上面@Qualifer:  给引用类型赋值，使用byName方式。               @Autowird, @Qualifer都是Spring框架提供的。@Resource ： 来自jdk中的定义， javax.annotation。 实现引用类型的自动注入， 支持byName, byType.             默认是byName, 如果byName失败， 再使用byType注入。 在属性上面使用其他：@Configuration ： 放在类的上面，表示这是个配置类，相当于xml配置文件@Bean：放在方法的上面， 把方法的返回值对象，注入到spring容器中。@ImportResource ： 加载其他的xml配置文件， 把文件中的对象注入到spring容器中@PropertySource ： 读取其他的properties属性配置文件@ComponentScan： 扫描器 ，指定包名，扫描注解的@ResponseBody: 放在方法的上面，表示方法的返回值是数据， 不是视图@RequestBody : 把请求体中的数据，读取出来， 转为java对象使用。@ControllerAdvice:  控制器增强， 放在类的上面， 表示此类提供了方法，可以对controller增强功能。@ExceptionHandler : 处理异常的，放在方法的上面@Transcational :  处理事务的， 放在service实现类的public方法上面， 表示此方法有事务SpringBoot中使用的注解    @SpringBootApplication ： 放在启动类上面， 包含了@SpringBootConfiguration                          @EnableAutoConfiguration， @ComponentScan    MyBatis相关的注解@Mapper ： 放在类的上面 ， 让MyBatis找到接口， 创建他的代理对象    @MapperScan :放在主类的上面 ， 指定扫描的包， 把这个包中的所有接口都创建代理对象。 对象注入到容器中@Param ： 放在dao接口的方法的形参前面， 作为命名参数使用的。    Dubbo注解@DubboService: 在提供者端使用的，暴露服务的， 放在接口的实现类上面@DubboReference:  在消费者端使用的， 引用远程服务， 放在属性上面使用。@EnableDubbo : 放在主类上面， 表示当前引用启用Dubbo功能。                        



]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>2022springboot自学笔记</title>
    <url>/2022/01/26/2022springboot%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[Spring Boot 整合 Web 开发Jsonweb中JSON框架的大致介绍
三大主流框架
jackson
gson
fastjson


序列化和反序列化
序列化：对象-&gt;JSON(响应JSON)
反序列化：JSON-&gt;对象(请求参数是JSON)


springmvc框架中，jackson和gson都已经自动配置好了,只需要添加依赖就能使用。Fastjson则需要开发者手动配置HttpMessageConverter
HttpMessageConverter：
这是个接口
是个转换器：对象-&gt;JSON,JSON-&gt;对象
所有的JSON工具都会提供各自的HttpMessageConverter
jackson:MappingJackson2HtttpMessageConverter
gson:GsonHttpMessageConverter
fastjson:






第一个例子
创建一个User实体类、
public class User &#123;    private Integer id;    private String username;    private String address;//    @JsonFormat(pattern = &quot;yyyy-MM-dd&quot;)    private Date birthday;      @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;id=&quot; + id +                &quot;, username=&#x27;&quot; + username + &#x27;\&#x27;&#x27; +                &quot;, address=&#x27;&quot; + address + &#x27;\&#x27;&#x27; +                &quot;, birthday=&quot; + birthday +                &#x27;&#125;&#x27;;    &#125;    public Date getBirthday() &#123;        return birthday;    &#125;    public void setBirthday(Date birthday) &#123;        this.birthday = birthday;    &#125;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public String getAddress() &#123;        return address;    &#125;    public void setAddress(String address) &#123;        this.address = address;    &#125;&#125;

创建一个UserController
//@Controller@RestController//==Controller+ResponseBodypublic class UserController &#123;//    @ResponseBody    @GetMapping(&quot;/user&quot;)    public List&lt;User&gt; getAllUser()&#123;        List&lt;User&gt; users=new ArrayList&lt;&gt;();        for (int i =0;i&lt;10;i++)&#123;            User user = new User();            user.setAddress(&quot;www.lcdzzz.com&gt;&gt;&quot;+i);            user.setUsername(&quot;lcdzzz&gt;&gt;&quot;+i);            user.setId(i);            user.setBirthday(new Date());            users.add(user);        &#125;        return users;    &#125;&#125;

运行结果：



  .eewhgowcndon{width:70%}



其中，User类中可以有@JsonProperty()这个注解，用来指定属性序列化或反序列化时的名称，默认名称就是属性名。value改变显示的值，index（优先级）改变显示的顺序。
@JsonProperty(value = &quot;aaaage&quot;,index = 99)//指定属性序列化或反序列化时的名称，默认名称就是属性名   private Integer id;   @JsonProperty(index = 98)   private String username;   @JsonProperty(index = 97)   private String address;   @JsonProperty(index = 96)   private Date birthday;


  .vqxwzeudaqmh{width:70%}



反序列化例子   默认是以key，value形式传递，如果想让它以json格式传递，则需要加@RequstBody，这样前端传递参数的时候就会以字符串的形式传递参数
@PostMapping(&quot;/user&quot;)    public void addUser(@RequestBody User user)&#123;        System.out.println(user);    &#125;

测试:

  .zrayazszlnmw{width:70%}



  .fwctzqjhuyab{width:70%}



序列化或反序列化是忽略某个字段
@JsonIgnore
@JsonIgnore   private String address;

@JsonIgnoreProperties批量忽略字段，写在类之上
@JsonIgnoreProperties(&#123;&quot;birthday&quot;,&quot;address&quot;&#125;)public class User &#123;


@JsonFormat//    @JsonProperty(index = 96)    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;,timezone = &quot;Asia/Shanghai&quot;)    private Date birthday;

测试：(注意时区问题)

  .lvdvigyqivos{width:70%}



全局配置创建一个WebMvcConfig类，定义一个ObjectMapper
@Configurationpublic class WebMvcConfig &#123;   @Bean    ObjectMapper objectMapper()&#123;       ObjectMapper om = new ObjectMapper();       om.setDateFormat(new SimpleDateFormat(&quot;yyyy//MM//dd HH:mm:ss&quot;));       return om;   &#125;&#125;


处理静态资源默认的静态资源优先级：都是在

META-INF&#x2F;resources
resources
static
public
webapp


  .frtalhbyhdoi{width:70%}



静态资源位置两种配置方法:
第一种

spring.web.resources.static-locations




  .yupikarqpvvi{width:70%}



  .kvfqjojgfhdy{width:70%}



  .vryeoaqfmumd{width:70%}



spring.web.resources.static-locations+spring.web.resources.static-locations


  .glgupydrgjtu{width:70%}



  .nixuixjcplws{width:70%}



第二种，自定义一个java类去继承 WebMvcConfigurer


  .ppusmwxsslpm{width:70%}





文件上传单文件上传
先在static下面写一个index.html,注意：以submit方式提交的字段必须有name属性，不然会忽略。

关于enctype=&quot;multipart/form-data&quot;的解释：

enctype就是encodetype就是编码类型的意思。
multipart&#x2F;form-data是指表单数据有多部分构成，既有文本数据，又有文件等二进制数据的意思。
需要注意的是：默认情况下，enctype的值是application&#x2F;x-www-form-urlencoded，不能用于文件上传，只有使用了multipart&#x2F;form-data，才能完整的传递文件数据。
application&#x2F;x-www-form-urlencoded不是不能上传文件，是只能上传文本格式的文件，multipart&#x2F;form-data是将文件以二进制的形式上传，这样可以实现多种类型的文件上传。

&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;


这里为了方便起见，把上传的文件放到了项目的临时目录里。（每当项目重启，临时目录里的文件就会消失）

接着创建文件上传接口
注意：public String upload(MultipartFile file, HttpServletRequest req) &#123;中的**“file”文件名必须和html中的&lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;的name**属性一一对应！！！
@RestControllerpublic class FileUploadController &#123;    SimpleDateFormat sdf = new SimpleDateFormat(&quot;/yyyy/MM/dd/&quot;);//按日期来分类。因为等会要扮演一个目录的角色，所以必须有斜杠！    @PostMapping(&quot;/upload&quot;)    public String upload(MultipartFile file, HttpServletRequest req) &#123;        String format = sdf.format(new Date());        String realPath = req.getServletContext().getRealPath(&quot;/img&quot;) + format;//字符串拼接，形成最终的路径！        File folder = new File(realPath);//文件夹        if (!folder.exists()) &#123;            folder.mkdirs();//如果不存在，那就创建        &#125;        String oldName = file.getOriginalFilename();//原本的文件名        String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(&quot;.&quot;));//oldName.substring(oldName.lastIndexOf(&quot;.&quot;)截取字符串，比如一个abc.png,那就截取abc        try &#123;            file.transferTo(new File(folder, newName));//第一个参数是地址，第二个参数是文件名            String url = req.getScheme() + &quot;://&quot; + req.getServerName() + &quot;:&quot; + req.getServerPort() + &quot;/img&quot; + format + newName;            //getScheme:获取请求协议            //getServerName：比如localhost            //getServerPort：请求端口            return url;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        return &quot;&quot;;    &#125;&#125;


多文件上传&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/uploads&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;input type=&quot;file&quot; name=&quot;files&quot; multiple&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;

对应的接口如下
@PostMapping(&quot;/uploads&quot;)   public String uploads(MultipartFile[] files, HttpServletRequest req) &#123;       String format = sdf.format(new Date());       String realPath = req.getServletContext().getRealPath(&quot;/img&quot;) + format;       File folder = new File(realPath);       if (!folder.exists()) &#123;           folder.mkdirs();       &#125;       try &#123;           for (MultipartFile file : files) &#123;               String oldName = file.getOriginalFilename();               String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(&quot;.&quot;));               file.transferTo(new File(folder, newName));               String url = req.getScheme() + &quot;://&quot; + req.getServerName() + &quot;:&quot; + req.getServerPort() + &quot;/img&quot; + format + newName;               System.out.println(url);           &#125;       &#125; catch (IOException e) &#123;           e.printStackTrace();       &#125;       return &quot;success&quot;;   &#125;


上传到指定目录（相对路径）html页面大同小异
controller接口如下：
@RestControllerpublic class FileUploadController &#123;    private static  final Logger logger = LoggerFactory.getLogger(FileUploadController.class);    // 项目根路径下的目录  -- SpringBoot static 目录相当于是根路径下（SpringBoot 默认）    public final static String UPLOAD_PATH_PREFIX = &quot;static/uploadFile/&quot;;    @PostMapping(&quot;/upload&quot;)    public String upload(MultipartFile uploadFile, HttpServletRequest request)&#123;        if(uploadFile.isEmpty())&#123;            //返回选择文件提示            return &quot;请选择上传文件&quot;;        &#125;        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy/MM/dd/&quot;);        //构建文件上传所要保存的&quot;文件夹路径&quot;--这里是相对路径，保存到项目根路径的文件夹下        String realPath = new String(&quot;src/main/resources/&quot; + UPLOAD_PATH_PREFIX);        System.out.println(&quot;-----------上传文件保存的路径【&quot;+ realPath +&quot;】-----------&quot;);        String format = sdf.format(new Date());        //存放上传文件的文件夹        File file = new File(realPath + format);        System.out.println(&quot;-----------存放上传文件的文件夹【&quot;+ file +&quot;】-----------&quot;);        System.out.println(&quot;-----------输出文件夹绝对路径 -- 这里的绝对路径是相当于当前项目的路径而不是“容器”路径【&quot;+ file.getAbsolutePath() +&quot;】-----------&quot;);        if(!file.isDirectory())&#123;            //递归生成文件夹            file.mkdirs();        &#125;        //获取原始的名字  original:最初的，起始的  方法是得到原来的文件名在客户机的文件系统名称        String oldName = uploadFile.getOriginalFilename();        System.out.println(&quot;-----------文件原始的名字【&quot;+ oldName +&quot;】-----------&quot;);        String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(&quot;.&quot;),oldName.length());        System.out.println(&quot;-----------文件要保存后的新名字【&quot;+ newName +&quot;】-----------&quot;);        try &#123;            //构建真实的文件路径            File newFile = new File(file.getAbsolutePath() + File.separator + newName);            //转存文件到指定路径，如果文件名重复的话，将会覆盖掉之前的文件,这里是把文件上传到 “绝对路径”            uploadFile.transferTo(newFile);            String filePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + &quot;/uploadFile/&quot; + format + newName;            System.out.println(&quot;-----------【&quot;+ filePath +&quot;】-----------&quot;);            return filePath;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        return &quot;上传失败!&quot;;    &#125;&#125;

结果：

  .wvwdkflkxhai{width:70%}



限制上传文件的大小spring.servlet.multipart.max-file-size=1MB=


Spring Boot+@ControllerAdvice全局异常处理捕获一个MaxUploadSizeExceededException异常，因为在上面，我们限制了上传文件的大小为1MB，如果上传的文件超过MB就会有异常
@RestControllerAdvicepublic class MyGlobalException &#123;    @ExceptionHandler(MaxUploadSizeExceededException.class)    public String customException(MaxUploadSizeExceededException e)&#123;        return &quot;上传文件大小超出限制&quot;;    &#125;&#125;

测试：

  .ndrvmqlngzct{width:70%}



全局数据绑定用@Controller去定义全局数据，只要定义好，在任何一个Controller下都可以拿到它

MyGlobalData:
@ModelAttribute(&quot;info&quot;)中，默认的key是map。这里指定了，所以是info
@ControllerAdvicepublic class MyGlobalData &#123;    @ModelAttribute(&quot;info&quot;)    public Map&lt;String,String&gt; mydata() &#123;        Map&lt;String, String&gt; info = new HashMap&lt;&gt;();        info.put(&quot;username&quot;, &quot;lcdzzz&quot;);        info.put(&quot;address&quot;, &quot;lcdzzz.github.io&quot;);        return info;    &#125;&#125;



HelloController    第6行的asMap.get(“info”)和上面的 @ModelAttribute(“info”)相对应
@RestControllerpublic class HelloController &#123;    @GetMapping(&quot;/hello&quot;)    public void hello(Model model) &#123;        Map&lt;String, Object&gt; asMap = model.asMap();        Map&lt;String, String&gt; info = (Map&lt;String, String&gt;) asMap.get(&quot;info&quot;);        Set&lt;String&gt; keySet = info.keySet();        for (String s : keySet) &#123;            System.out.println(s + &quot;----&quot; + info.get(s));        &#125;    &#125;&#125;

测试：

  .tmalqtkjssup{width:70%}





全局数据预处理
实体类：【tostring方法和getset方法省略】
public class Author &#123;        private String name;        private Integer age;&#125;

public class Book &#123;    private String name;    private Double price;&#125;

BookController
@RestControllerpublic class BookController &#123;    @PostMapping(&quot;/book&quot;)    public void addBook(@ModelAttribute(&quot;b&quot;) Book book, @ModelAttribute(&quot;a&quot;) Author author) &#123;        System.out.println(&quot;book = &quot; + book);        System.out.println(&quot;author = &quot; + author);    &#125;&#125;

MyGlobalData
@ControllerAdvicepublic class MyGlobalData &#123;    @InitBinder(&quot;b&quot;)    public void b(WebDataBinder binder) &#123;        binder.setFieldDefaultPrefix(&quot;b.&quot;);    &#125;    @InitBinder(&quot;a&quot;)    public void a(WebDataBinder binder) &#123;        binder.setFieldDefaultPrefix(&quot;a.&quot;);    &#125;&#125;

异常处理异常页面定义静态页面一定要按图中的规则来定义异常页面，路径不能变，文件名和异常状态码一一对应。注意：在templates路径下的优先级更高（动态高于静态，精确高于模糊）

  .whbjeuqtjyxl{width:70%}




动态页面&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=&quot;1&quot;&gt;    &lt;tr&gt;        &lt;td&gt;path&lt;/td&gt;        &lt;td th:text=&quot;$&#123;path&#125;&quot;&gt;&lt;/td&gt;&lt;!--异常路径 --&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;error&lt;/td&gt;        &lt;td th:text=&quot;$&#123;error&#125;&quot;&gt;&lt;/td&gt;&lt;!--错误信息--&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;message&lt;/td&gt;        &lt;td th:text=&quot;$&#123;message&#125;&quot;&gt;&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;timestamp&lt;/td&gt;        &lt;td th:text=&quot;$&#123;timestamp&#125;&quot;&gt;&lt;/td&gt;&lt;!--异常发生的时间--&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;status&lt;/td&gt;        &lt;td th:text=&quot;$&#123;status&#125;&quot;&gt;&lt;/td&gt;&lt;!--状态码--&gt;    &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;


  .nfondmgucfmq{width:70%}



自定义异常处理自定义异常数据
  .lqpnmbqhuinn{width:70%}



创建一个MyErrorAtributes来继承DefaultErrorAttributes
@Componentpublic class MyErrorAtributes extends DefaultErrorAttributes &#123;    @Override    public Map&lt;String, Object&gt; getErrorAttributes(WebRequest webRequest, ErrorAttributeOptions options) &#123;        Map&lt;String, Object&gt; map = super.getErrorAttributes(webRequest, options);//这个就是服务端返回的数据        if ((Integer) map.get(&quot;status&quot;) == 404) &#123;            map.put(&quot;message&quot;, &quot;页面不存在&quot;);        &#125;        return map;    &#125;&#125;

测试：



  .zapcnyntdevd{width:70%}


   ps：↓↓↓999是因为定义了异常视图999.html ↓↓↓


自定义异常视图：
创建一个MyErrorViewResolver来继承DefaultErrorViewResolver【这中方法既可以定义视图也可以定义数据，但是定义数据建议使用上面的一个方法。这里Map&lt;String, Object&gt; model是不可修改的，所以要重新放数据的话必须定义一个map。 	
@Componentpublic class MyErrorViewResolver extends DefaultErrorViewResolver &#123;    public MyErrorViewResolver(ApplicationContext applicationContext, WebProperties.Resources resources) &#123;        super(applicationContext, resources);    &#125;    @Override    public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) &#123;        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.putAll(model);        if ((Integer) model.get(&quot;status&quot;) == 500) &#123;            map.put(&quot;message&quot;, &quot;服务器内部错误&quot;);        &#125;        ModelAndView view = new ModelAndView(&quot;lcdzzz/999&quot;,map);        return view;    &#125;&#125;

创建999.html【名字自定义】
&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;999.html&lt;/h1&gt;&lt;table border=&quot;1&quot;&gt;    &lt;tr&gt;        &lt;td&gt;path&lt;/td&gt;        &lt;td th:text=&quot;$&#123;path&#125;&quot;&gt;&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;error&lt;/td&gt;        &lt;td th:text=&quot;$&#123;error&#125;&quot;&gt;&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;message&lt;/td&gt;        &lt;td th:text=&quot;$&#123;message&#125;&quot;&gt;&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;timestamp&lt;/td&gt;        &lt;td th:text=&quot;$&#123;timestamp&#125;&quot;&gt;&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;status&lt;/td&gt;        &lt;td th:text=&quot;$&#123;status&#125;&quot;&gt;&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;


  .denbemtwxxix{width:70%}



测试


  .kyvtsdxgqsaf{width:70%}





跨域CORS: Cross-Origi Resource Sharing

域： 协议+域名&#x2F;IP+duan端口  ，只要这三个其中有一个是不一样的，就是跨域了
资源：一个url对应一个内容。图片，html，json数据等
同源策略：浏览器客户端仅请求当前页面或来自同一个域的资源

提前准备好两个工程
cors01 端口：8080
cors02 端口：8081

第一种跨域方式
在cors01中创建一个接口
public class HelloController &#123;    @GetMapping(&quot;/hello&quot;)    public String hello() &#123;        return &quot;hello cors&quot;;    &#125;&#125;



在cors02建一个名为01.html的静态页面，发送ajax请求
&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script src=&quot;https://code.jquery.com/jquery-3.5.1.js&quot; integrity=&quot;sha256-QWo7LDvxbWT2tbbQ97B53yJnYU3WhH/C8ycbRAkjPDc=&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; onclick=&quot;getData()&quot; value=&quot;get&quot;&gt;&lt;script&gt;    function getData() &#123;        $.get(&quot;http://localhost:8080/hello&quot;,function (msg) &#123;            alert(msg);        &#125;)    &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;

测试：



  .xjnygfwoxlds{width:70%}



因为同源策略，我们拿不到服务端的响应

怎么办呢，第一种方法就是在cors01的HelloController加一个@CrossOrigin。这个注解可以加在方法上也可以加在类上。哪个方法&#x2F;类想支持跨域，就加那个方法&#x2F;类上。关于探测请求，接下来会说
@RestController@CrossOrigin(value = &quot;http://localhost:8081&quot;,maxAge = 1800)/*第一个参数：表示允许来自&quot;http://localhost:8081&quot;这个地址访问第二个参数：过期时间（s），在有效期内，第一次探测结束后不需要再次探测*/public class HelloController &#123;    @GetMapping(&quot;/hello&quot;)    public String hello() &#123;        return &quot;hello cors&quot;;    &#125;&#125;

测试



  .xmlvlyfjegwo{width:70%}




探测get请求不需要探测，但是put需要，这边以put请求为例

在cors01中的controller上，加一个put
@RestController@CrossOrigin(value = &quot;http://localhost:8081&quot;,maxAge = 1800)/*表示允许来自&quot;http://localhost:8081&quot;这个地址访问*/public class HelloController &#123;    @GetMapping(&quot;/hello&quot;)    public String hello() &#123;        return &quot;hello cors&quot;;    &#125;    @PutMapping(&quot;/hello&quot;)    public String hello2() &#123;        return &quot;hello cors put!&quot;;    &#125;&#125;

在cors02中的01.html上
&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script src=&quot;https://code.jquery.com/jquery-3.5.1.js&quot; integrity=&quot;sha256-QWo7LDvxbWT2tbbQ97B53yJnYU3WhH/C8ycbRAkjPDc=&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; onclick=&quot;getData()&quot; value=&quot;get&quot;&gt;&lt;input type=&quot;button&quot; onclick=&quot;putData()&quot; value=&quot;put&quot;&gt;&lt;script&gt;    function getData() &#123;        $.get(&quot;http://localhost:8080/hello&quot;,function (msg) &#123;/*第一个参数：请求的地址                                                              第二个参数：服务端返回的信息*/            alert(msg);        &#125;)    &#125;    function putData() &#123;        $.ajax(&#123;            url:&#x27;http://localhost:8080/hello&#x27;,            type:&#x27;put&#x27;,            success:function (msg) &#123;                alert(msg);            &#125;        &#125;)    &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;

测试：



  .erijpdgqepof{width:70%}




第二种跨域方式
创建一个类继承WebMvcConfigurer
@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123;    @Override    public void addCorsMappings(CorsRegistry registry) &#123;        registry.addMapping(&quot;/**&quot;)//要拦截的地址                .allowedHeaders(&quot;*&quot;)//是否允许的头                .allowedMethods(&quot;*&quot;)//允许的方法                .allowedOrigins(&quot;http://localhost:8081&quot;)//允许的域，也可以写“ * ”                .maxAge(1800);    &#125;&#125;





第三种跨域方式提供一个corsFilter实例，把它注册到spring容器里面去
package org.javaboy.cors01;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;import org.springframework.web.filter.CorsFilter;@Configurationpublic class WebMvcConfig  &#123;    @Bean    CorsFilter corsFilter() &#123;        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();        CorsConfiguration cfg = new CorsConfiguration();        cfg.addAllowedOrigin(&quot;http://localhost:8081&quot;);        cfg.addAllowedMethod(&quot;*&quot;);//允许的请求        source.registerCorsConfiguration(&quot;/**&quot;,cfg);        return new CorsFilter(source);    &#125;&#125;





拦截器
配置拦截器：
public class MyInterceptor implements HandlerInterceptor &#123;    //该方法返回 false，请求将不再继续往下走。在请求处理之前被调用    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        System.out.println(&quot;preHandle&quot;);        return true;    &#125;    //Controller 执行之后被调用。    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;        System.out.println(&quot;postHandle&quot;);    &#125;    //preHandle 方法返回 true，afterCompletion 才会执行。也就是在整个请求结束之后才会执行，可以做一些资源的清理工作    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;        System.out.println(&quot;afterCompletion&quot;);    &#125;&#125;

使拦截器生效
@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123;//为了让拦截器生效    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;//这个方法是用来配拦截器的        registry.addInterceptor(new MyInterceptor()).addPathPatterns(&quot;/**&quot;).excludePathPatterns(&quot;/hello&quot;);//拦截哪些请求，哪些请求不拦截    &#125;&#125;

测试类Controller
@RestControllerpublic class HelloController &#123;    @GetMapping(&quot;/hello&quot;)    public String hello() &#123;        System.out.println(&quot;hello&quot;);        return &quot;hello&quot;;    &#125;    @GetMapping(&quot;/hello2&quot;)    public String hello2() &#123;        System.out.println(&quot;hello2&quot;);        return &quot;hello2&quot;;    &#125;&#125;

测试



  .hqqaqrqtskpk{width:70%}



  .nprvfgcvmjru{width:70%}


   

系统启动任务CommandLineRunner
MyCommandLineRunner01
@Component@Order(100)public class MyCommandLineRunner01 implements CommandLineRunner &#123;    //当系统启动时，run 方法会被触发，方法参数就是 main 方法所传入的参数    @Override    public void run(String... args) throws Exception &#123;        System.out.println(&quot;args1 = &quot; + Arrays.toString(args));    &#125;&#125;

MyCommandLineRunner02
@Component@Order(99)public class MyCommandLineRunner02 implements CommandLineRunner &#123;    //当系统启动时，run 方法会被触发，方法参数就是 main 方法所传入的参数    @Override    public void run(String... args) throws Exception &#123;        System.out.println(&quot;args2 = &quot; + Arrays.toString(args));    &#125;&#125;

配置：



  .xbwkwkiuqiyf{width:70%}



测试：


  .tfobomxngxcy{width:70%}


   
ApplicationRunner
MyApplicationRunner
@Component@Order(98)public class MyApplicationRunner implements ApplicationRunner &#123;    @Override    public void run(ApplicationArguments args) throws Exception &#123;        //获取没有键的参数，获取到的值和 commandlinerunner 一致        List&lt;String&gt; nonOptionArgs = args.getNonOptionArgs();        System.out.println(&quot;nonOptionArgs1 = &quot; + nonOptionArgs);        Set&lt;String&gt; optionNames = args.getOptionNames();        for (String optionName : optionNames) &#123;            System.out.println(optionName + &quot;-1-&gt;&quot; + args.getOptionValues(optionName));        &#125;        //获取命令行中的所有参数        String[] sourceArgs = args.getSourceArgs();//不管有没有key，统统获取到数组里去        System.out.println(&quot;sourceArgs1 = &quot; + Arrays.toString(sourceArgs));    &#125;&#125;

MyApplicationRunner2
@Component@Order(97)public class MyApplicationRunner2 implements ApplicationRunner &#123;    @Override    public void run(ApplicationArguments args) throws Exception &#123;        //获取没有键的参数，获取到的值和 commandlinerunner 一致        List&lt;String&gt; nonOptionArgs = args.getNonOptionArgs();        System.out.println(&quot;nonOptionArgs2 = &quot; + nonOptionArgs);        Set&lt;String&gt; optionNames = args.getOptionNames();        for (String optionName : optionNames) &#123;            System.out.println(optionName + &quot;-2-&gt;&quot; + args.getOptionValues(optionName));        &#125;        //获取命令行中的所有参数        String[] sourceArgs = args.getSourceArgs();        System.out.println(&quot;sourceArgs2 = &quot; + Arrays.toString(sourceArgs));    &#125;&#125;

配置



  .reqxignidvcv{width:70%}



测试


  .ktswhjutmuid{width:70%}





SpringBoot整合web基础组件
MyFilter
@WebFilter(urlPatterns = &quot;/*&quot;)public class MyFilter implements Filter &#123;    @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;        System.out.println(&quot;MyFilter&quot;);        chain.doFilter(request,response);    &#125;&#125;

MyListener
@WebListenerpublic class MyListener extends RequestContextListener &#123;    @Override    public void requestInitialized(ServletRequestEvent requestEvent) &#123;        System.out.println(&quot;requestInitialized&quot;);    &#125;    @Override    public void requestDestroyed(ServletRequestEvent requestEvent) &#123;        System.out.println(&quot;requestDestroyed&quot;);    &#125;&#125;

MyServlet
@WebServlet(urlPatterns = &quot;/hello&quot;)public class MyServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        doPost(req,resp);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        System.out.println(&quot;MyServlet&quot;);    &#125;&#125;

扫描，让组件生效
启动类：@ServletComponentScan(&quot;org.javaboy.webcomponent&quot;)是那三个组件所在的包
@SpringBootApplication@ServletComponentScan(&quot;org.javaboy.webcomponent&quot;)public class WebcomponentApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(WebcomponentApplication.class, args);    &#125;&#125;

测试：



  .qtfudemkrlda{width:70%}









SpringBoot注册过滤器的n种方式第一种 @WebFilter
在启动类上扫描包

@SpringBootApplication@ServletComponentScan(&quot;org.javaboy.filter&quot;)public class FilterApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(FilterApplication.class, args);    &#125;&#125;


这个可以设置拦截谁，没法设置优先级

@WebFilter(urlPatterns = &quot;/*&quot;)public class MyFilter01 implements Filter &#123;    @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;        System.out.println(&quot;MyFilter01&quot;);        chain.doFilter(request, response);    &#125;&#125;


第二种 @Component把它当成普通的组件这个可以设置优先级，但是不能设置拦截谁
@Component@Order(101)public class MyFilter02 implements Filter &#123;    @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;        System.out.println(&quot;MyFilter02&quot;);        chain.doFilter(request, response);    &#125;&#125;


第三种 FilterRegistrationBeanpublic class MyFilter04 implements Filter &#123;    @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;        System.out.println(&quot;MyFilter04&quot;);        chain.doFilter(request, response);    &#125;&#125;

public class MyFilter05 implements Filter &#123;    @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;        System.out.println(&quot;MyFilter05&quot;);        chain.doFilter(request, response);    &#125;&#125;

@Configurationpublic class FilterConfiguration &#123;    @Bean        //用@Bean注册成一个bean    FilterRegistrationBean&lt;MyFilter04&gt; filter04FilterRegistrationBean04() &#123;        FilterRegistrationBean&lt;MyFilter04&gt; bean = new FilterRegistrationBean&lt;&gt;();        bean.setOrder(90);        bean.setFilter(new MyFilter04());        bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;));        return bean;    &#125;    @Bean    FilterRegistrationBean&lt;MyFilter05&gt; filter04FilterRegistrationBean05() &#123;        FilterRegistrationBean&lt;MyFilter05&gt; bean = new FilterRegistrationBean&lt;&gt;();        bean.setOrder(89);        bean.setFilter(new MyFilter05());        bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;));        return bean;    &#125;&#125;

测试全部：

  .mhykitwivpsl{width:70%}



路径映射这个方法有个局限性：就是这个页面没有需要渲染的数据。作为一个控制器实现简单的跳转
@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123;     @Override //实现无业务逻辑跳转    public void addViewControllers(ViewControllerRegistry registry) &#123;        registry.addViewController(&quot;/&quot;).setViewName(&quot;redirect:/managebooks/login&quot;);//forward和redirect区别在导航栏上        registry.setOrder(Ordered.HIGHEST_PRECEDENCE);//order的值越小，优先级越高    &#125;&#125;

对上面代码这呢个的redirect的解释：
使用servlet重定向有两种方式

一种是forward，另一种就是redirect。forward是服务器内部重定向，客户端并不知道服务器把你当前请求重定向到哪里去了，地址栏的url与你之前访问的url保持不变。
redirect则是客户端重定向，是服务器将你当前请求返回，然后给个状态标示给你，告诉你应该去重新请求另外一个url，具体表现就是地址栏的url变成了新的url。


参数类型转换问题描述
代码：
/**以下省略tostring和getset方法**/public class User &#123;    private String username;    private Date birthday;&#125;

@RestControllerpublic class UserController &#123;    @PostMapping(&quot;/user1&quot;)    public void addUser(User user) &#123;        System.out.println(&quot;user = &quot; + user);    &#125;&#125;

测试会报错，因为框架不知道如何把字符串转换成对象



  .ekkvntgyqlwo{width:70%}



解决方法类型转换器@Component//注册到容器中，注册成一个组件public class MyDateConverter implements Converter&lt;String, Date&gt; &#123;//意思是把String类型转换成Date类型    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);    @Override    public Date convert(String source) &#123;        try &#123;            return sdf.parse(source);        &#125; catch (ParseException e) &#123;            e.printStackTrace();        &#125;        return null;    &#125;&#125;




另一种情况@RestControllerpublic class UserController &#123;    @PostMapping(&quot;/user2&quot;)    public void addUser2(@RequestBody User user) &#123;//用了@RequestBody，代码参数以json字符串的方式传递        System.out.println(&quot;user = &quot; + user);    &#125;&#125;

这个以json字符换的形式传递参数，不会报错，就算没有类型转换器

总结POST请求，参数可以是key&#x2F;value形式，也可以是JSON形式
自定义的类型转换器对key&#x2F;value形式的参数有效
JSON形式的参数，不需要类型转换器。JSON字符串是通过&#x3D;&#x3D;HttpMessageConverter&#x3D;&#x3D;转换为User对象的

自定义首页与浏览器脚标@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123;    @Override    public void addViewControllers(ViewControllerRegistry registry) &#123;        registry.addViewController(&quot;/index&quot;).setViewName(&quot;index&quot;);    &#125;&#125;


  .fkmqepgcxsis{width:70%}


favicon制作网址:https://tool.lu/favicon/
SpringBoot整合AOP
添加依赖：
&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt;

代码：
@Component@Aspect//表示当前这个类是一个切面public class LogAspect &#123;    /**     *  execution中的第一个 * 表示方法返回值是任意的     *  这里表示service包下的所有类中的所有方法都要拦截下来     */    @Pointcut(&quot;execution(* org.javaboy.aop.service.*.*(..))&quot;)//表示这是个切点    public void pc1() &#123;    &#125;    @Before(&quot;pc1()&quot;)//pc1指定拦截规则    public void before(JoinPoint jp) &#123;        String name = jp.getSignature().getName();        System.out.println(name + &quot; 方法开始执行了...&quot;);    &#125;    @After(&quot;pc1()&quot;)    public void after(JoinPoint jp) &#123;        String name = jp.getSignature().getName();        System.out.println(name + &quot; 方法执行结束了...&quot;);    &#125;    @AfterReturning(value = &quot;pc1()&quot;, returning = &quot;s&quot;)    public void afterReturning(JoinPoint jp, String s) &#123;        String name = jp.getSignature().getName();        System.out.println(name + &quot; 方法的返回值是 &quot; + s);    &#125;    @AfterThrowing(value = &quot;pc1()&quot;, throwing = &quot;e&quot;)    public void afterThrowing(JoinPoint jp, Exception e) &#123;        String name = jp.getSignature().getName();        System.out.println(name + &quot; 方法抛出了异常 &quot; + e.getMessage());    &#125;    @Around(&quot;pc1()&quot;)    public Object around(ProceedingJoinPoint pjp) &#123;        try &#123;            //类似于反射中的 invoke 方法            Object proceed = pjp.proceed();            return proceed;        &#125; catch (Throwable throwable) &#123;            throwable.printStackTrace();        &#125;        return null;    &#125;&#125;

service类
@Servicepublic class UserService &#123;    public String getUserById(Integer id) &#123;        System.out.println(&quot;getUserById&quot;);        int i = 1 / 0;        return &quot;user&quot;;    &#125;    public void deleteUserById(Integer id) &#123;        System.out.println(&quot;delete id:&quot; + id);    &#125;&#125;

测试
@SpringBootTestclass AopApplicationTests &#123;    @Autowired    UserService userService;    @Test    void contextLoads() &#123;        userService.getUserById(99);    &#125;&#125;

结果：



  .yoxiuuluofmf{width:70%}



Spring Boot整合视图层Thymeleaf配置参考资料：https://mp.weixin.qq.com/s/Uvv1q3iQn2IwAB1crHWS1g
这部分的内容基本照搬了松哥的微信公众号，主要用于自己学习
基本配置

所需要的依赖
&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;      &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;

命名空间
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;!--默认导入的名称空间不对，应该是这个←--&gt;

手动渲染

前端页面
&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Hello，欢迎 &lt;span th:text=&quot;$&#123;username&#125;&quot;&gt;&lt;/span&gt; 加入 XXX 公司！您的入职信息如下：&lt;/p&gt;&lt;table border=&quot;1&quot;&gt;    &lt;tr&gt;        &lt;td&gt;职位&lt;/td&gt;        &lt;td th:text=&quot;$&#123;position&#125;&quot;&gt;&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;薪水&lt;/td&gt;        &lt;td th:text=&quot;$&#123;salary&#125;&quot;&gt;&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;

单元测试
@SpringBootTestclass ThymeleafApplicationTests &#123;    @Autowired    TemplateEngine templateEngine;    @Test    void contextLoads() &#123;        Context ctx = new Context();        ctx.setVariable(&quot;username&quot;,&quot;javaboy&quot;);        ctx.setVariable(&quot;position&quot;,&quot;Java 高工&quot;);        ctx.setVariable(&quot;salary&quot;,&quot;30000&quot;);        String mail = templateEngine.process(&quot;mail&quot;, ctx);//和hello一样，自动加上前缀和后缀，定位到文件        System.out.println(mail);    &#125;&#125;

测试结果



  .snhcdpthacbp{width:70%}


Thymeleaf 细节标准表达式语法简单表达式后端controller的数据定义

  .cpdhvarwnjwp{width:70%}



$&#123;...&#125;
直接使用 th:xx = &quot;$&#123;&#125;&quot; 获取对象属性。这个在前面的案例中已经演示过了，不再赘述。

*&#123;...&#125;
可以像 $&#123;...&#125; 一样使用，也可以通过 th:object 获取对象，然后使用 th:xx = &quot;*&#123;&#125;&quot; 获取对象属性，这种简写风格极为清爽，推荐大家在实际项目中使用。
&lt;table border=&quot;1&quot; th:object=&quot;$&#123;user&#125;&quot;&gt;&lt;tr&gt;    &lt;td&gt;用户名&lt;/td&gt;    &lt;td th:text=&quot;*&#123;username&#125;&quot;&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;    &lt;td&gt;地址&lt;/td&gt;    &lt;td th:text=&quot;*&#123;address&#125;&quot;&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

#&#123;...&#125;
通常的国际化属性：#&#123;...&#125; 用于获取国际化语言翻译值。
在 resources 目录下新建两个文件：messages.properties 和 messages_zh_CN.properties，内容如下：
messages.properties：
message = javaboy

messages_zh_CN.properties：
message = 周大侠

然后在 thymeleaf 中引用 message，系统会根据浏览器的语言环境显示不同的值：
&lt;div th:text=&quot;#&#123;message&#125;&quot;&gt;&lt;/div&gt;

结果：



  .widilcpcouqc{width:70%}

  

@&#123;...&#125;

引用绝对 URL：
&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;http://localhost:8080/hello.js&#125;&quot;&gt;&lt;/script&gt;

等价于：
&lt;script type=&quot;text/javascript&quot; src=&quot;http://localhost:8080/hello.js&quot;&gt;&lt;/script&gt;

上下文相关的 URL：
首先在 application.properties 中配置 Spring Boot 的上下文，以便于测试：
server.servlet.context-path=/myapp

引用路径：注意{}里面的斜杠
&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/hello.js&#125;&quot;&gt;&lt;/script&gt;

等价于：
&lt;script type=&quot;text/javascript&quot; src=&quot;/myapp/hello.js&quot;&gt;&lt;/script&gt;

应用程序的上下文 &#x2F;myapp 将被忽略。
结果测试：





  .revusblqpgdw{width:70%}


字面量这些是一些可以直接写在表达式中的字符，主要有如下几种：

文本字面量：’one text’, ‘Another one!’,…
数字字面量：0, 34, 3.0, 12.3,…
布尔字面量：true, false
Null字面量：null
字面量标记：one, sometext, main,…

&lt;div th:text=&quot;&#x27;这是 文本字面量(有空格)&#x27;&quot;&gt;&lt;/div&gt;&lt;div th:text=&quot;javaboy&quot;&gt;&lt;/div&gt;&lt;div th:text=&quot;99&quot;&gt;&lt;/div&gt;&lt;div th:text=&quot;true&quot;&gt;&lt;/div&gt;

如果文本是英文，并且不包含空格、逗号等字符，可以不用加单引号。
文本运算文本可以使用 + 进行拼接。
&lt;div th:text=&quot;&#x27;hello &#x27;+&#x27;javaboy&#x27;&quot;&gt;&lt;/div&gt;&lt;div th:text=&quot;&#x27;hello &#x27;+$&#123;user.username&#125;&quot;&gt;&lt;/div&gt;

如果字符串中包含变量，也可以使用另一种简单的方式，叫做字面量置换，用 | 代替 &#39;...&#39; + &#39;...&#39;，如下：
&lt;div th:text=&quot;|hello $&#123;user.username&#125;|&quot;&gt;&lt;/div&gt;&lt;div th:text=&quot;&#x27;hello &#x27;+$&#123;user.username&#125;+&#x27; &#x27;+|Go $&#123;user.address&#125;|&quot;&gt;&lt;/div&gt;

算术运算算术运算有：+, -, *, / 和 %
&lt;div th:with=&quot;age=(99*99/99+99-1)&quot;&gt;    &lt;div th:text=&quot;$&#123;age&#125;&quot;&gt;&lt;/div&gt;&lt;/div&gt;

th:with 定义了一个局部变量 age，在其所在的 div 中可以使用该局部变量。
布尔运算
二元运算符：and, or
布尔非（一元运算符）：!, not

&lt;div th:with=&quot;age=(99*99/99+99-1)&quot;&gt;    &lt;div th:text=&quot;9 eq 9 or 8 ne 8&quot;&gt;&lt;/div&gt;    &lt;div th:text=&quot;!(9 eq 9 or 8 ne 8)&quot;&gt;&lt;/div&gt;    &lt;div th:text=&quot;not(9 eq 9 or 8 ne 8)&quot;&gt;&lt;/div&gt;&lt;/div&gt;

比较和相等表达式里的值可以使用 &gt;, &lt;, &gt;= 和 &lt;= 符号比较。== 和 != 运算符用于检查相等（或者不相等）。注意 XML规定 &lt; 和 &gt; 标签不能用于属性值，所以应当把它们转义为 &lt; 和 &gt;。(数学运算符及转义写法)


如果不想转义，也可以使用别名：gt (&gt;)；lt (&lt;)；ge (&gt;&#x3D;)；le (&lt;&#x3D;)；not (!)。还有 eq (&#x3D;&#x3D;), neq&#x2F;ne (!&#x3D;)。
&lt;div th:with=&quot;age=(99*99/99+99-1)&quot;&gt;    &lt;div th:text=&quot;$&#123;age&#125; eq 197&quot;&gt;&lt;/div&gt;    &lt;div th:text=&quot;$&#123;age&#125; ne 197&quot;&gt;&lt;/div&gt;    &lt;div th:text=&quot;$&#123;age&#125; ge 197&quot;&gt;&lt;/div&gt;    &lt;div th:text=&quot;$&#123;age&#125; gt 197&quot;&gt;&lt;/div&gt;    &lt;div th:text=&quot;$&#123;age&#125; le 197&quot;&gt;&lt;/div&gt;    &lt;div th:text=&quot;$&#123;age&#125; lt 197&quot;&gt;&lt;/div&gt;&lt;/div&gt;

条件运算符类似于 Java 中的三目运算符。
&lt;div th:with=&quot;age=(99*99/99+99-1)&quot;&gt;    &lt;div th:text=&quot;($&#123;age&#125; ne 197)?&#x27;yes&#x27;:&#x27;no&#x27;&quot;&gt;&lt;/div&gt;&lt;/div&gt;

内置对象基本内置对象：

#ctx：上下文对象。
#vars: 上下文变量。
#locale：上下文区域设置。
#request：（仅在 Web 上下文中）HttpServletRequest 对象。
#response：（仅在 Web 上下文中）HttpServletResponse 对象。
#session：（仅在 Web 上下文中）HttpSession 对象。
#servletContext：（仅在 Web 上下文中）ServletContext 对象。

在页面可以访问到上面这些内置对象，举个简单例子：
&lt;div th:text=&#x27;$&#123;#session.getAttribute(&quot;name&quot;)&#125;&#x27;&gt;&lt;/div&gt;

实用内置对象：

#execInfo：有关正在处理的模板的信息。
#messages：在变量表达式中获取外部化消息的方法，与使用＃{…}语法获得的方式相同。
#uris：转义URL &#x2F; URI部分的方法
#conversions：执行配置的转换服务（如果有）的方法。
#dates：java.util.Date对象的方法：格式化，组件提取等
#calendars：类似于#dates但是java.util.Calendar对象。
#numbers：用于格式化数字对象的方法。
#strings：String对象的方法：contains，startsWith，prepending &#x2F; appending等
#objects：一般对象的方法。
#bools：布尔评估的方法。
#arrays：数组方法。
#lists：列表的方法。
#sets：集合的方法。
#maps：地图方法。
#aggregates：在数组或集合上创建聚合的方法。
#ids：处理可能重复的id属性的方法（例如，作为迭代的结果）。

这是一些内置对象以及工具方法，使用方式也都比较容易，如果使用的是 IntelliJ IDEA，都会自动提示对象中的方法，很方便。
举例：
&lt;div th:text=&quot;$&#123;#execInfo.getProcessedTemplateName()&#125;&quot;&gt;&lt;/div&gt;&lt;div th:text=&quot;$&#123;#arrays.length(#request.getAttribute(&#x27;names&#x27;))&#125;&quot;&gt;&lt;/div&gt;



设置属性值这个是给 HTML 元素设置属性值。可以一次设置多个，多个之间用 , 分隔开。
例如：
&lt;img th:attr=&quot;src=@&#123;/1.png&#125;,title=$&#123;user.username&#125;,alt=$&#123;user.username&#125;&quot;&gt;

会被渲染成：
&lt;img src=&quot;/myapp/1.png&quot; title=&quot;javaboy&quot; alt=&quot;javaboy&quot;&gt;

当然这种设置方法不太美观，可读性也不好。Thymeleaf 还支持在每一个原生的 HTML 属性前加上 th: 前缀的方式来使用动态值，像下面这样：【可以在所有原生属性前面加一个th:，让他变成一个thymeleaf属性】
&lt;img th:src=&quot;@&#123;/1.png&#125;&quot; th:alt=&quot;$&#123;user.username&#125;&quot; th:title=&quot;$&#123;user.username&#125;&quot;&gt;

这种写法看起来更清晰一些，渲染效果和前面一致。
上面案例中的 alt 和 title 则是两个特殊的属性，可以一次性设置，像下面这样：
&lt;img th:src=&quot;@&#123;/1.png&#125;&quot; th:alt-title=&quot;$&#123;user.username&#125;&quot;&gt;

这个等价于前文的设置。
遍历数组&#x2F;集合&#x2F;Map&#x2F;Enumeration&#x2F;Iterator 等的遍历也算是一个非常常见的需求，Thymeleaf 中通过 th:each 来实现遍历，像下面这样：
&lt;table border=&quot;1&quot;&gt;    &lt;tr th:each=&quot;u : $&#123;users&#125;&quot;&gt;        &lt;td th:text=&quot;$&#123;u.username&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;u.address&#125;&quot;&gt;&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;

users 是要遍历的集合&#x2F;数组，u 则是集合中的单个元素。
遍历的时候，我们可能需要获取遍历的状态，Thymeleaf 也对此提供了支持：

index：当前的遍历索引，从0开始。
count：当前的遍历索引，从1开始。
size：被遍历变量里的元素数量。
current：每次遍历的遍历变量。
even&#x2F;odd：当前的遍历是偶数次还是奇数次。
first：当前是否为首次遍历。
last：当前是否为最后一次遍历。

u 后面的 state 表示遍历状态，通过遍历状态可以引用上面的属性。
&lt;table border=&quot;1&quot;&gt;    &lt;tr th:each=&quot;u,state : $&#123;users&#125;&quot;&gt;        &lt;td th:text=&quot;$&#123;u.username&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;u.address&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;state.index&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;state.count&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;state.size&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;state.current&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;state.even&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;state.odd&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;state.first&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;state.last&#125;&quot;&gt;&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;

分支语句只显示奇数次的遍历，可以使用 th:if，如下：
&lt;table border=&quot;1&quot;&gt;    &lt;tr th:each=&quot;u,state : $&#123;users&#125;&quot; th:if=&quot;$&#123;state.odd&#125;&quot;&gt;        &lt;td th:text=&quot;$&#123;u.username&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;u.address&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;state.index&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;state.count&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;state.size&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;state.current&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;state.even&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;state.odd&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;state.first&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;state.last&#125;&quot;&gt;&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;

th:if 不仅仅只接受布尔值，也接受其他类型的值，例如如下值都会判定为 true：

如果值是布尔值，并且为 true。
如果值是数字，并且不为 0。
如果值是字符，并且不为 0。
如果值是字符串，并且不为 “false”， “off” 或者 “no”。
如果值不是布尔值，数字，字符或者字符串。

但是如果值为 null，th:if 会求值为 false。
th:unless 的判定条件则与 th:if 完全相反。
&lt;table border=&quot;1&quot;&gt;    &lt;tr th:each=&quot;u,state : $&#123;users&#125;&quot; th:unless=&quot;$&#123;state.odd&#125;&quot;&gt;        &lt;td th:text=&quot;$&#123;u.username&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;u.address&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;state.index&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;state.count&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;state.size&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;state.current&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;state.even&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;state.odd&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;state.first&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;state.last&#125;&quot;&gt;&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;

这个显示效果则与上面的完全相反。
当可能性比较多的时候，也可以使用 switch：
&lt;table border=&quot;1&quot;&gt;    &lt;tr th:each=&quot;u,state : $&#123;users&#125;&quot;&gt;        &lt;td th:text=&quot;$&#123;u.username&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;u.address&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;state.index&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;state.count&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;state.size&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;state.current&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;state.even&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;state.odd&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;state.first&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;state.last&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:switch=&quot;$&#123;state.odd&#125;&quot;&gt;            &lt;span th:case=&quot;true&quot;&gt;odd&lt;/span&gt;            &lt;span th:case=&quot;*&quot;&gt;even&lt;/span&gt;        &lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;

th:case=&quot;*&quot; 则表示默认选项。
本地变量这个我们前面已经涉及到了，使用 th:with 可以定义一个本地变量。
内联我们可以使用属性将数据放入页面模版中，但是很多时候，内联的方式看起来更加直观一些，像下面这样：
&lt;div&gt;hello [[$&#123;user.username&#125;]]&lt;/div&gt;

用内联的方式去做拼接也显得更加自然。
[[...]] 对应于 th:text （结果会是转义的 HTML），[(...)]对应于 th:utext，它不会执行任何的 HTML 转义。
像下面这样：【注意：通过 th:with 定义的变量，是在标签里生效的，所以第一种写法是错误的，没法显示不执行转义的html表情】
&lt;div th:with=&quot;str=&#x27;hello &lt;strong&gt;javaboy&lt;/strong&gt;&#x27;&quot;&gt;&lt;/div&gt;    &lt;div&gt;[[$&#123;str&#125;]]&lt;/div&gt;    &lt;div&gt;[($&#123;str&#125;)]&lt;/div&gt;

↑↑↑以上写法错误↑↑↑
↓↓↓以下写法正确↓↓↓
&lt;div th:with=&quot;str=&#x27;hello &lt;strong&gt;javaboy&lt;/strong&gt;&#x27;&quot;&gt;    &lt;div&gt;[[$&#123;str&#125;]]&lt;/div&gt;    &lt;div&gt;[($&#123;str&#125;)]&lt;/div&gt;&lt;/div&gt;

最终的显示效果如下：

  .ukjhsdpuxosy{width:70%}


不过内联方式有一个问题。我们使用 Thymeleaf 的一大优势在于不用动态渲染就可以直接在浏览器中看到显示效果，当我们使用属性配置的时候确实是这样，但是如果我们使用内联的方式，各种表达式就会直接展示在静态网页中。
也可以在 js 或者 css 中使用内联，以 js 为例，使用方式如下：
&lt;script th:inline=&quot;javascript&quot;&gt;    var username=[[$&#123;user.username&#125;]]    console.log(username)&lt;/script&gt;

js 中需要通过 th:inline=&quot;javascript&quot; 开启内联。
通过这种“手段”，就可以在js代码里面直获取到服务端传过来的数据（比如在js里面获取request或者httpsession里边的东西）
&#x2F;&#x2F;本人在“照搬文章内容”基础上加了一些自学过程中自己的理解，这模块的内容仅用于学习，再次感谢松哥写的文章。

Freemarker简介这是一个相当老牌的开源的免费的模版引擎，基于Apache许可证2.0版本发布。
通过 Freemarker 模版，我们可以将数据渲染成 HTML 网页、电子邮件、配置文件以及源代码等。Freemarker 不是面向最终用户的，而是一个 Java 类库，我们可以将之作为一个普通的组件嵌入到我们的产品中。
来看一张来自 Freemarker 官网的图片：

  .rblotkqpvfvz{width:70%}


可以看到，Freemarker 可以将模版和数据渲染成 HTML 。
Freemarker 模版后缀为 .ftlh(FreeMarker Template Language)。FTL 是一种简单的、专用的语言，它不是像 Java 那样成熟的编程语言。在模板中，你可以专注于如何展现数据， 而在模板之外可以专注于要展示什么数据。
整合 Spring Boot&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;

创建类User类
public class User &#123;    private Long id;    private String username;    private String address;    //省略 getter/setter&#125;

UserController
@Controllerpublic class UserController &#123;    @GetMapping(&quot;/hello&quot;)    public String index(Model model) &#123;        List&lt;User&gt; users = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; 10; i++) &#123;            User user = new User();            user.setId((long) i);            user.setUsername(&quot;javaboy&gt;&gt;&gt;&gt;&quot; + i);            user.setAddress(&quot;www.javaboy.org&gt;&gt;&gt;&gt;&quot; + i);            users.add(user);        &#125;        model.addAttribute(&quot;users&quot;, users);        return &quot;index&quot;;    &#125;&#125;

在 freemarker 中渲染数据：
&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=&quot;1&quot;&gt;    &lt;tr&gt;        &lt;td&gt;用户编号&lt;/td&gt;        &lt;td&gt;用户名称&lt;/td&gt;        &lt;td&gt;用户地址&lt;/td&gt;    &lt;/tr&gt;    &lt;#list users as user&gt;        &lt;tr&gt;            &lt;td&gt;$&#123;user.id&#125;&lt;/td&gt;            &lt;td&gt;$&#123;user.username&#125;&lt;/td&gt;            &lt;td&gt;$&#123;user.address&#125;&lt;/td&gt;        &lt;/tr&gt;    &lt;/#list&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;

结果：

  .nvryelfyftsl{width:70%}


其他配置如果我们要修改模版文件位置等，可以在 application.properties 中进行配置：
spring.freemarker.allow-request-override=falsespring.freemarker.allow-session-override=falsespring.freemarker.cache=falsespring.freemarker.charset=UTF-8spring.freemarker.check-template-location=truespring.freemarker.content-type=text/htmlspring.freemarker.expose-request-attributes=falsespring.freemarker.expose-session-attributes=falsespring.freemarker.suffix=.ftlspring.freemarker.template-loader-path=classpath:/templates/

配置文件按照顺序依次解释如下：

HttpServletRequest的属性是否可以覆盖controller中model的同名项
HttpSession的属性是否可以覆盖controller中model的同名项
是否开启缓存
模板文件编码
是否检查模板位置
Content-Type的值
是否将HttpServletRequest中的属性添加到Model中
是否将HttpSession中的属性添加到Model中
模板文件后缀
模板文件位置

Freemarker使用细节插值与表达式直接输出值字符串
可以直接输出一个字符串：
&lt;div&gt;$&#123;&quot;hello，我是直接输出的字符串&quot;&#125;&lt;/div&gt;&lt;div&gt;$&#123;&quot;我的文件保存在C:\\盘&quot;&#125;&lt;/div&gt;

\ 需要进行转义。
如果感觉转义太麻烦，可以在目标字符串的引号前增加 r 标记,在 r 标记后的文本内容将会直接输出，像下面这样：
&lt;div&gt;$&#123;r&quot;我的文件保存在C:\盘&quot;&#125;&lt;/div&gt;


  .ixqknmunohlm{width:70%}


数字
在 FreeMarker 中使用数值需要注意以下几点:

数值不能省略小数点前面的0，所以”.5”是错误的写法。
数值 8 , +8 , 8.00 都是相同的。

数字还有一些其他的玩法：

将数字以钱的形式展示

&lt;#assign num=99&gt;&lt;div&gt;$&#123;num?string.currency&#125;&lt;/div&gt;

&lt;#assign num=99&gt; 表示定义了一个变量 num，值为 99。最终的展示形式是在数字前面出现了一个人民币符号：

将数字以百分数的形式展示

&lt;div&gt;$&#123;num?string.percent&#125;&lt;/div&gt;

布尔
布尔类型可以直接定义，不需要引号，像下面这样：
&lt;#assign flag=true&gt;&lt;div&gt;$&#123;flag?string(&quot;a&quot;,&quot;b&quot;)&#125;&lt;/div&gt;

首先使用 &lt;#assign flag=true&gt; 定义了一个 Boolean 类型的变量，然后在 div 中展示，如果 flag 为 true，则输出 a，否则输出 b。
集合
集合也可以现场定义现场输出，例如如下方式定义一个 List 集合并显示出来：
&lt;#list [&quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;, &quot;星期天&quot;] as x&gt;    $&#123;x&#125;&lt;br/&gt;&lt;/#list&gt;


  .lwjfoiwhgede{width:70%}


集合中的元素也可以是一个表达式：
&lt;#list [2+2,&quot;javaboy&quot;] as x&gt;    $&#123;x&#125; &lt;br/&gt;&lt;/#list&gt;

集合中的第一个元素就是 2+2 的结果，即 4。
也可以用 1..5 表示 1 到 5，5..1 表示 5 到 1，例如：
&lt;#list 5..1 as x&gt;    $&#123;x&#125; &lt;br/&gt;&lt;/#list&gt;&lt;#list 1..5 as x&gt;    $&#123;x&#125; &lt;br/&gt;&lt;/#list&gt;


  .ynmdcykfvien{width:70%}


也可以定义 Map 集合，Map 集合用一个 &#123;&#125; 来描述：
&lt;hr&gt;&lt;#assign userinfo=&#123;&quot;name&quot;:&quot;javaboy&quot;,&quot;address&quot;:&quot;www.javaboy.org&quot;&#125;&gt;&lt;#list userinfo?keys as key&gt;&lt;#--意思是拿到userinfo这个map里面所有的key命名为key，并展示出来--&gt;    &lt;div&gt;$&#123;key&#125;-$&#123;userinfo[key]&#125;&lt;/div&gt;&lt;/#list&gt;&lt;hr&gt;&lt;#list userinfo?values as value&gt;    &lt;div&gt;$&#123;value&#125;&lt;/div&gt;&lt;/#list&gt;&lt;hr&gt;&lt;div&gt;$&#123;userinfo.name&#125;&lt;/div&gt;&lt;div&gt;$&#123;userinfo[&#x27;address&#x27;]&#125;&lt;/div&gt;

最上面两个循环分别表示遍历 Map 中的 key+values 和 values。
下面的 .name和[&#39;name&#39;]两种写法是等价的

  .njzgwmdtqnyq{width:70%}


输出变量创建一个 HelloController，然后添加如下方法：
@Controllerpublic class UserController &#123;    @GetMapping(&quot;/hello&quot;)    public String hello(Model model) &#123;        List&lt;User&gt; users = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; 10; i++) &#123;            User u = new User();            u.setId((long) i);            u.setUsername(&quot;javaboy:&quot; + i);            u.setAddress(&quot;www.javaboy.org:&quot; + i);            users.add(u);        &#125;        model.addAttribute(&quot;users&quot;, users);        Map&lt;String, Object&gt; info = new HashMap&lt;&gt;();        info.put(&quot;name&quot;, &quot;江南一点雨&quot;);        info.put(&quot;age&quot;, 99);        model.addAttribute(&quot;info&quot;, info);        model.addAttribute(&quot;name&quot;, &quot;javaboy&quot;);        model.addAttribute(&quot;birthday&quot;, new Date());        return &quot;hello&quot;;    &#125;&#125;

普通变量
普通变量的展示很容易，如下：
&lt;div&gt;$&#123;name&#125;&lt;/div&gt;

集合
集合的展示就有很多不同的玩法了。
直接遍历：
&lt;div&gt;  &lt;table border=&quot;1&quot;&gt;    &lt;#list users as u&gt;        &lt;tr&gt;            &lt;td&gt;$&#123;u.id&#125;&lt;/td&gt;            &lt;td&gt;$&#123;u.username&#125;&lt;/td&gt;            &lt;td&gt;$&#123;u.address&#125;&lt;/td&gt;        &lt;/tr&gt;    &lt;/#list&gt;&lt;/table&gt;&lt;/div&gt;

输出集合中第三个元素：
&lt;div&gt;$&#123;users[1].address&#125;&lt;/div&gt;

输出集合中第 4-6 个元素，即子集合：
&lt;div&gt;  &lt;table border=&quot;1&quot;&gt;    &lt;#list users[3..5] as u&gt;        &lt;tr&gt;            &lt;td&gt;$&#123;u.id&#125;&lt;/td&gt;            &lt;td&gt;$&#123;u.username&#125;&lt;/td&gt;            &lt;td&gt;$&#123;u.address&#125;&lt;/td&gt;        &lt;/tr&gt;    &lt;/#list&gt;&lt;/table&gt;&lt;/div&gt;

遍历时，可以通过 变量_index 获取遍历的下标：
&lt;div&gt;&lt;table border=&quot;1&quot;&gt;    &lt;#list users as u&gt;        &lt;tr&gt;            &lt;td&gt;$&#123;u.id&#125;&lt;/td&gt;            &lt;td&gt;$&#123;u.username&#125;&lt;/td&gt;            &lt;td&gt;$&#123;u.address&#125;&lt;/td&gt;            &lt;td&gt;$&#123;u_index&#125;&lt;/td&gt;            &lt;td&gt;$&#123;u_has_next?string(&quot;yes&quot;,&quot;no&quot;)&#125;&lt;/td&gt;        &lt;/tr&gt;    &lt;/#list&gt;&lt;/table&gt;&lt;/div&gt;


  .erexqjnxivke{width:70%}




Map
直接获取 Map 中的值有不同的写法，如下：
&lt;div&gt;$&#123;info.name&#125;&lt;/div&gt;&lt;div&gt;$&#123;info[&#x27;age&#x27;]&#125;&lt;/div&gt;

获取 Map 中的所有 key，并根据 key 获取 value：【注意：循环写法时 &lt;div&gt;$&#123;key&#125;-$&#123;info.key&#125;&lt;/div&gt;这种写法是错的】
&lt;div&gt;  &lt;#list info?keys as key&gt;    &lt;div&gt;$&#123;key&#125;-$&#123;info[key]&#125;&lt;/div&gt;&lt;/#list&gt;&lt;/div&gt;

获取 Map 中的所有 value：
&lt;div&gt;    &lt;#list info?values as value&gt;        &lt;div&gt;$&#123;value&#125;&lt;/div&gt;    &lt;/#list&gt;&lt;/div&gt;


  .vtrxyvwogvdy{width:70%}




字符串操作字符串的拼接有两种方式：
&lt;div&gt;$&#123;&quot;hello $&#123;name&#125;&quot;&#125;&lt;/div&gt;&lt;div&gt;$&#123;&quot;hello &quot;+ name&#125;&lt;/div&gt;

也可以从字符串中截取子串：
&lt;div&gt;$&#123;name[0]&#125;$&#123;name[1]&#125;&lt;/div&gt;&lt;div&gt;$&#123;name[1..3]&#125;&lt;/div&gt;


  .ivmjpybhrqwq{width:70%}


集合操作集合或者 Map 都可以相加。
集合相加：
&lt;div&gt;&lt;#list [1,2,3]+[4,5,6] as x&gt;    &lt;div&gt;$&#123;x&#125;&lt;/div&gt;&lt;/#list&gt;&lt;/div&gt;

Map 相加：
&lt;#list (info+&#123;&quot;address&quot;:&quot;www.javaboy.org&quot;&#125;)?keys as key&gt;    &lt;div&gt;$&#123;key&#125;&lt;/div&gt;&lt;/#list&gt;


  .mjuyolkngvrk{width:70%}


3.1.5 算术运算符+、—、*、/、% 运算都是支持的。
&lt;div&gt;    &lt;#assign age=99&gt;    &lt;div&gt;$&#123;age*99/99+99-1&#125;&lt;/div&gt;&lt;/div&gt;

3.1.6 比较运算比较运算和 Thymeleaf 比较类似:

&#x3D; 或者 &#x3D;&#x3D; 判断两个值是否相等。
!&#x3D; 判断两个值是否不等。
&gt;或者 gt 判断左边值是否大于右边值。
&gt;= 或者 gte 判断左边值是否大于等于右边值。
&lt; 或者 lt 判断左边值是否小于右边值。
&lt;= 或者 lte 判断左边值是否小于等于右边值。

可以看到，带 &lt; 或者 &gt; 的符号，也都有别名，建议使用别名。
&lt;div&gt;    &lt;#assign age=99&gt;    &lt;#if age=99&gt;age=99&lt;/#if&gt;    &lt;#if age gt 99&gt;age gt 99&lt;/#if&gt;    &lt;hr&gt;    &lt;#if (age &gt; 99) || 1==1&gt;(age &gt; 99) || 1==1&lt;/#if&gt;    &lt;hr&gt;    &lt;#if age gte 99&gt;age gte 99&lt;/#if&gt;    &lt;#if age lt 99&gt;age lt 99&lt;/#if&gt;    &lt;#if age lte 99&gt;age lte 99&lt;/#if&gt;    &lt;#if age!=99&gt;age!=99&lt;/#if&gt;    &lt;#if age==99&gt;age==99&lt;/#if&gt;&lt;/div&gt;


  .ygguvoumtatn{width:70%}


逻辑运算逻辑运算符有三个:

逻辑与 &amp;&amp;
逻辑或 ||
逻辑非 !

逻辑运算符只能作用于布尔值,否则将产生错误。
&lt;div&gt;    &lt;#assign age=99&gt;    &lt;#if age=99 &amp;&amp; 1==1&gt;age=99 &amp;&amp; 1==1&lt;/#if&gt;    &lt;#if age=99 || 1==0&gt;age=99 || 1==0&lt;/#if&gt;    &lt;#if !(age gt 99)&gt;!(age gt 99)&lt;/#if&gt;&lt;/div&gt;

空值处理为了处理缺失变量,Freemarker 提供了两个运算符:

!：指定缺失变量的默认值
??：判断某个变量是否存在

如果某个变量不存在，则设置其为 javaboy，如下：
&lt;div&gt;$&#123;aaa!&quot;javaboy&quot;&#125;&lt;/div&gt;

如果某个变量不存在，则设置其为空字符串，如下：
&lt;div&gt;$&#123;aaa!&#125;&lt;/div&gt;

即，! 后面的东西如果省略了，默认就是空字符串。
判断某个变量是否存在：
&lt;div&gt;$&#123;aaa!&quot;javaboy&quot;&#125;&lt;/div&gt;&lt;div&gt;$&#123;aaa!&#125;&lt;/div&gt;&lt;div&gt;&lt;#if aaa??&gt;aaa&lt;/#if&gt;&lt;/div&gt;

内建函数内建函数涉及到的东西比较多，可以参考官方文档:http://freemarker.foofun.cn/ref_builtins.html
这里仅说一些比较常用的内建函数。
cap_first
使字符串第一个字母大写：
&lt;div&gt;$&#123;&quot;hello&quot;?cap_first&#125;&lt;/div&gt;

lower_case
将字符串转换成小写：
&lt;div&gt;$&#123;&quot;HELLO&quot;?lower_case&#125;&lt;/div&gt;

upper_case
将字符串转换成大写：
&lt;div&gt;$&#123;&quot;hello&quot;?upper_case&#125;&lt;/div&gt;

trim
去掉字符串前后的空白字符：
&lt;div&gt;$&#123;&quot; hello&quot;?trim&#125;&lt;/div&gt;

size
获取序列中元素的个数：
&lt;div&gt;$&#123;users?size&#125;&lt;/div&gt;

int
取得数字的整数部分,结果带符号：
&lt;div&gt;$&#123;3.14?int&#125;&lt;/div&gt;

freemarker日期格式化
&lt;div&gt;$&#123;birthday?string(&quot;yyyy-MM-dd&quot;)&#125;&lt;/div&gt;

常用指令if&#x2F;else分支控制指令，作用类似于 Java 语言中的 if：
&lt;div&gt;    &lt;#assign age=23&gt;    &lt;#if (age&gt;60)&gt;老年人    &lt;#elseif (age&gt;40)&gt;中年人    &lt;#elseif (age&gt;20)&gt;青年人    &lt;#else&gt; 少年人    &lt;/#if&gt;&lt;/div&gt;

比较符号中用了 ()，因此不用转义。
switch分支指令，类似于 Java 中的 switch：
&lt;div&gt;    &lt;#assign age=99&gt;    &lt;#switch age&gt;        &lt;#case 23&gt;23&lt;#break&gt;        &lt;#case 24&gt;24&lt;#break&gt;        &lt;#default&gt;9999    &lt;/#switch&gt;&lt;/div&gt;

&lt;#break&gt; 是提前退出，也可以用在 &lt;#list&gt; 中。
includeinclude 可以包含一个外部页面进来。
&lt;#include &quot;./javaboy.ftlh&quot;&gt;

macromacro 用来定义一个宏。
我们可以自定义一个名为 book 的宏，并引用它：
&lt;#macro book&gt;    三国演义&lt;/#macro&gt;&lt;@book/&gt;

最终页面中会输出宏中所定义的内容。
在定义宏的时候，也可以传入参数，那么引用时，也需要传入参数：
&lt;#macro book bs&gt;    &lt;table border=&quot;1&quot;&gt;        &lt;#list bs as b&gt;            &lt;tr&gt;                &lt;td&gt;$&#123;b&#125;&lt;/td&gt;            &lt;/tr&gt;        &lt;/#list&gt;    &lt;/table&gt;&lt;/#macro&gt;&lt;@book [&quot;三国演义&quot;,&quot;水浒传&quot;]/&gt;

bs 就是需要传入的参数。可以通过传入多个参数，多个参数跟在 bs 后面即可，中间用空格隔开。
还可以使用 &lt;#nested&gt; 引入用户自定义指令的标签体，像下面这样：
&lt;#macro book bs&gt;    &lt;table border=&quot;1&quot;&gt;        &lt;#list bs as b&gt;            &lt;tr&gt;                &lt;td&gt;$&#123;b&#125;&lt;/td&gt;            &lt;/tr&gt;        &lt;/#list&gt;    &lt;/table&gt;    &lt;#nested&gt;&lt;/#macro&gt;&lt;@book [&quot;三国演义&quot;,&quot;水浒传&quot;]&gt;    &lt;h1&gt;hello javaboy!&lt;/h1&gt;&lt;/@book&gt;

在宏定义的时候，&lt;#nested&gt; 相当于是一个占位符，在调用的时候，&lt;@book&gt; 标签中的内容会出现在 &lt;#nested&gt; 位置。
前面的案例中，宏都是定义在当前页面中，宏也可以定义在一个专门的页面中。新建 myjavaboy.ftlh 页面，内容如下：
&lt;#macro book bs&gt;    &lt;table border=&quot;1&quot;&gt;        &lt;#list bs as b&gt;            &lt;tr&gt;                &lt;td&gt;$&#123;b&#125;&lt;/td&gt;            &lt;/tr&gt;        &lt;/#list&gt;    &lt;/table&gt;    &lt;#nested&gt;&lt;/#macro&gt;

此时，需要先通过 &lt;#import&gt; 标签导入宏，然后才能调用，如下：
&lt;#import &quot;./myjavaboy.ftlh&quot; as com&gt;&lt;@com.book bs=[&quot;三国演义&quot;,&quot;水浒传&quot;]&gt;    &lt;h1&gt;hello javaboy!&lt;/h1&gt;&lt;/@com.book&gt;

3.2.5 noparse如果想在页面展示一些 Freemarker 语法而不被渲染，则可以使用 noparse 标签，如下：
&lt;#noparse&gt;&lt;#import &quot;./myjavaboy.ftlh&quot; as com&gt;&lt;@com.book bs=[&quot;三国演义&quot;,&quot;水浒传&quot;]&gt;    &lt;h1&gt;hello javaboy!&lt;/h1&gt;&lt;/@com.book&gt;&lt;/#noparse&gt;

显示效果如下：

  .bpnxteochbdf{width:70%}





Spring Boot 整合数据持久层Spring Boot 整合 MyBatis【注解版】
实体类准备
public class User &#123;    private Long id;    private String username;    private String address;    public Long getId() &#123;        return id;    &#125;    public void setId(Long id) &#123;        this.id = id;    &#125;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;id=&quot; + id +                &quot;, username=&#x27;&quot; + username + &#x27;\&#x27;&#x27; +                &quot;, address=&#x27;&quot; + address + &#x27;\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;    public String getAddress() &#123;        return address;    &#125;    public void setAddress(String address) &#123;        this.address = address;    &#125;&#125;

注册mapper
@SpringBootApplication@MapperScan(basePackages = &quot;org.javaboy.mybatis.mapper&quot;)//指定扫描文件public class MybatisApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(MybatisApplication.class, args);    &#125;&#125;

sql语句
public interface UserMapper &#123;    @Select(&quot;select * from user where id=#&#123;id&#125;&quot;)    User getUserById(Long id);    @Results(&#123;            @Result(property = &quot;address&quot;,column = &quot;address1&quot;)    &#125;)    @Select(&quot;select * from user&quot;)    List&lt;User&gt; getAllUsers();    @Insert(&quot;insert into user (username,address1) values (#&#123;username&#125;,#&#123;address&#125;)&quot;)    //主键回填    @SelectKey(statement = &quot;select last_insert_id()&quot;,keyProperty = &quot;id&quot;,before = false,resultType = Long.class)    Integer addUser(User user);    @Delete(&quot;delete from user where id=#&#123;id&#125;&quot;)    Integer deleteById(Long id);    @Update(&quot;update user set username=#&#123;username&#125; where id=#&#123;id&#125;&quot;)    Integer updateById(String username, Long id);&#125;

测试
@SpringBootTestclass MybatisApplicationTests &#123;    @Autowired    UserMapper userMapper;    @Test    void contextLoads() &#123;        User user = userMapper.getUserById(3L);        System.out.println(user);    &#125;    @Test    void tes1() &#123;        List&lt;User&gt; users = userMapper.getAllUsers();        System.out.println(users);    &#125;    @Test    void test2() &#123;        User user = new User();        user.setUsername(&quot;zhangsan&quot;);        user.setAddress(&quot;shenzhen&quot;);        userMapper.addUser(user);        System.out.println(&quot;user.getId() = &quot; + user.getId());    &#125;    @Test    void test3() &#123;        userMapper.deleteById(12L);        userMapper.updateById(&quot;123&quot;, 11L);    &#125;&#125;


Spring Boot 整合 MyBatis【XML版】
如上

如上

resource目录下的UserMapper2.xml
&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;org.javaboy.mybatis.mapper.UserMapper2&quot;&gt;    &lt;resultMap id=&quot;UserMap&quot; type=&quot;org.javaboy.mybatis.model.User&quot;&gt;        &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;        &lt;result property=&quot;username&quot; column=&quot;username&quot;/&gt;        &lt;result property=&quot;address&quot; column=&quot;address1&quot;/&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;getUserById&quot; resultMap=&quot;UserMap&quot;&gt;        select * from user where id=#&#123;id&#125;;    &lt;/select&gt;    &lt;select id=&quot;getAllUsers&quot; resultMap=&quot;UserMap&quot;&gt;        select * from user ;    &lt;/select&gt;    &lt;insert id=&quot;addUser&quot; parameterType=&quot;org.javaboy.mybatis.model.User&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;/*parameterType代表参数类型*/        insert into user (username,address1) values (#&#123;username&#125;,#&#123;address&#125;);    &lt;/insert&gt;    &lt;delete id=&quot;deleteById&quot;&gt;        delete from user where id=#&#123;id&#125;    &lt;/delete&gt;    &lt;update id=&quot;updateById&quot;&gt;        update user set username = #&#123;username&#125; where id=#&#123;id&#125;;    &lt;/update&gt;&lt;/mapper&gt;

测试类
@Autowired    UserMapper2 userMapper2;    @Test    void test4() &#123;        User user = userMapper2.getUserById(9L);        System.out.println(&quot;user = &quot; + user);        List&lt;User&gt; allUsers = userMapper2.getAllUsers();        System.out.println(&quot;allUsers = &quot; + allUsers);        User u = new User();        u.setUsername(&quot;lisi&quot;);        u.setAddress(&quot;guangzhou&quot;);        userMapper2.addUser(u);        System.out.println(u.getId());        userMapper2.deleteById(9L);        userMapper2.updateById(&quot;zhangsan&quot;, 4L);    &#125;


定义资源文件
告诉maven，我的配置文件不仅仅在resource目录下，还在上面的java目录下

&lt;resources&gt;         &lt;resource&gt;             &lt;directory&gt;src/main/java&lt;/directory&gt;             &lt;includes&gt;                 &lt;include&gt;**/*.xml&lt;/include&gt;             &lt;/includes&gt;         &lt;/resource&gt;         &lt;resource&gt;             &lt;directory&gt;src/main/resources&lt;/directory&gt;         &lt;/resource&gt;     &lt;/resources&gt;

文件目录如图

  .mrpsccjqmygl{width:70%}



也可以直接指定mapper在哪里，如下图


  .rfqrjipgkerh{width:70%}



Spring Boot 整合 MyBatis 多数据源
在配置数据库的properties里配置数据库的连接信息
spring.datasource.one.jdbcUrl=jdbc:mysql:///test01?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghaispring.datasource.one.username=rootspring.datasource.one.password=wqeqspring.datasource.two.jdbcUrl=jdbc:mysql:///test02?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghaispring.datasource.two.username=rootspring.datasource.two.password=wqeq

在config包中的DataSourceConfig创建DataSource的实例【DataSourceConfig】
@Configurationpublic class DataSourceConfig &#123;    @Bean    @ConfigurationProperties(prefix = &quot;spring.datasource.one&quot;)    DataSource dsOne() &#123;        return new HikariDataSource();    &#125;    @Bean    @ConfigurationProperties(prefix = &quot;spring.datasource.two&quot;)    DataSource dsTwo() &#123;        return new HikariDataSource();    &#125;&#125;

配置mybatis实例【MyBatisConfigOne 、MyBatisConfigTwo】
@Configuration@MapperScan(basePackages = &quot;org.javaboy.mybatismulti.mapper1&quot;,sqlSessionFactoryRef = &quot;sqlSessionFactory1&quot;,sqlSessionTemplateRef = &quot;sqlSessionTemplate1&quot;)public class MyBatisConfigOne &#123;    @Autowired    @Qualifier(&quot;dsOne&quot;)    DataSource ds;    @Bean    SqlSessionFactory sqlSessionFactory1() &#123;        SqlSessionFactory sqlSessionFactory = null;        try &#123;            SqlSessionFactoryBean bean = new SqlSessionFactoryBean();            bean.setDataSource(ds);            sqlSessionFactory = bean.getObject();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        return sqlSessionFactory;    &#125;    @Bean    SqlSessionTemplate sqlSessionTemplate1() &#123;        return new SqlSessionTemplate(sqlSessionFactory1());    &#125;&#125;

mapper包下，【UserMapper1和UserMapper1.xml】【UserMapper2和UserMapper2.xml】

综上↑，项目结构如图所示



  .oyxvctsmbber{width:70%}



测试代码
@SpringBootTestclass MybatismultiApplicationTests &#123;    @Autowired    UserMapper1 userMapper1;    @Autowired    UserMapper2 userMapper2;    @Test    void contextLoads() &#123;        System.out.println(&quot;userMapper1.getAllUsers() = &quot; + userMapper1.getAllUsers());        System.out.println(&quot;userMapper2.getAllUsers() = &quot; + userMapper2.getAllUsers());    &#125;&#125;



测试结果



  .ondhsgloqxsc{width:70%}



Spring Boot 整合 Spring Data Jpa入门操作
依赖
&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;   &lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;

数据库基本配置
spring.datasource.username=rootspring.datasource.password=wqeqspring.datasource.url=jdbc:mysql:///test01?useUnicode=true&amp;characterEncoding=UTF-8#jpa的平台spring.jpa.database=mysql#在控制台打印sqlspring.jpa.show-sql=true#指定数据库平台spring.jpa.database-platform=mysql#如果对象变了，对应的表也要重新更新spring.jpa.hibernate.ddl-auto=update#指定数据库的方言为mysql57，5.7的版本就会默认选择InnoDB【是MySQL的数据库引擎之一】spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL57Dialect

定义实体类
@Entity(name = &quot;t_book&quot;)//以后数据库上自动创建一个和java类对应的表||如果什么都不标记，默认使用类名作为表名public class Book &#123;    @Id//代表被注释的属性是主键    @GeneratedValue(strategy = GenerationType.IDENTITY)//自动生成【自动增长型】    private Long id;//默认属性名就是数据库里字段的名称    @Column(name = &quot;b_name&quot;)//重新指定数据库字段的名字    private String name;    private String author;    @Override    public String toString() &#123;        return &quot;Book&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +                &quot;, author=&#x27;&quot; + author + &#x27;\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;    public Long getId() &#123;        return id;    &#125;    public void setId(Long id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getAuthor() &#123;        return author;    &#125;    public void setAuthor(String author) &#123;        this.author = author;    &#125;&#125;

运行启动类，查看数据库结果



  .yibdgyxvdldb{width:70%}



操作表,在单元测试中测试

添加&#x2F;删除
     @AutowiredBookDao bookDao;     @Testvoid contextLoads() &#123;    Book book = new Book();    book.setName(&quot;三国演义&quot;);    book.setAuthor(&quot;罗贯中&quot;);    bookDao.save(book);//保存一条记录&#125;     @Testvoid test1() &#123;    List&lt;Book&gt; list = bookDao.findAll();    System.out.println(&quot;list = &quot; + list);    Optional&lt;Book&gt; byId = bookDao.findById(2L);//查找id为2的    System.out.println(&quot;byId = &quot; + byId);    bookDao.deleteById(1L);//删除id为1的&#125;        

分页操作
@Testvoid test2() &#123;    //页码从 0 开始记，1 表示第二页    PageRequest pageRequest = PageRequest.of(0, 3/*第一页，每页有三条记录*/, Sort.by(Sort.Order.asc(&quot;id&quot;)));    Page&lt;Book&gt; page = bookDao.findAll(pageRequest);    System.out.println(&quot;总记录数： &quot; + page.getTotalElements());    System.out.println(&quot;总页数 &quot; + page.getTotalPages());    System.out.println(&quot;查到的数据 &quot; + page.getContent());    System.out.println(&quot;每页的记录数 &quot; + page.getSize());//每页我打算查询到多少条记录    System.out.println(&quot;是否还有下一页 &quot; + page.hasNext());    System.out.println(&quot;是否还有上一页 &quot; + page.hasPrevious());    System.out.println(&quot;是否最后一页 &quot; + page.isLast());    System.out.println(&quot;是否第一页 &quot; + page.isFirst());    System.out.println(&quot;当前页码 &quot; + page.getNumber());    System.out.println(&quot;当前页的记录数 &quot; + page.getNumberOfElements());//实际查询到多少条，比如最后一页查询到的就不是三条了&#125;

分页测试





  .wjxsprecmnjh{width:70%}



按方法命名规范
按方法的命名规范来
public interface BookDao extends JpaRepository&lt;Book,Long&gt;/*JpaRepository这个类有两个泛型：1.到时候BookDao这个类要处理的实体类是谁                                                                                        2.实体类定义的主键类型是什么                                                           这堆东西会自动注入到spring容器中去                                              */ &#123;    List&lt;Book&gt; getBookByAuthorIs(String author);//方法名可以以find get read三个单词开始                                                //美其名曰：现在不用管数据库的东西，咱操作的就是对象   &#125;

在单元测试中测试
@Test void test3() &#123;     List&lt;Book&gt; list = bookDao.getBookByAuthorIs(&quot;鲁迅&quot;);     System.out.println(&quot;list = &quot; + list); &#125;   

结果



  .bnrjoocoukoz{width:70%}

   

这里借用下松哥的博客 http://springboot.javaboy.org/2019/0407/springboot-jpa


自定义查询当方法命名规范里的操作无法满足你的需求的时候，就需要自定义查询

在dao包下的BookDao类
//nativeQuery代表使用原生的sql   @Query(nativeQuery = true,value = &quot;select * from t_book where id=(select max(id) from t_book)&quot;)   Book maxIdBook();

单元测试
@Testvoid test4() &#123;    System.out.println(bookDao.maxIdBook());&#125;

测试结果



  .xddvntvrcpcd{width:70%}



自定义更新涉及到数据库的修改，要球必须要有事务 

dao包下的BookDao
@Query(&quot;update t_book set b_name=:name where id=:id&quot;)    @Modifying//默认的sql是不支持更新操作的，如果想让它支持更新操作，就要加这个注解    void updateBookById(String name, Long id);

service包下的BookService
@Servicepublic class BookService &#123;    @Autowired    BookDao bookDao;    @Transactional//给它一个事务    public void updateBookById(String name, Long id)&#123;        bookDao.updateBookById(name, id);    &#125;&#125;

单元测试
@AutowiredBookService bookService;@Testvoid test5() &#123;    bookService.updateBookById(&quot;123&quot;, 7L);&#125;

测试结果



  .gorqdbvgobuj{width:70%}





Spring Data Jpa 多数据源这方面比较简单是写起来又复杂，直接参考松哥的博客（关键是自己懒）
http://itboyhub.com/2021/01/25/spring-boot2-spring-data-jpa/
http://itboyhub.com/2021/01/25/spring-boot2-jpa/
http://itboyhub.com/2021/01/25/spring-boot2-multi-jpa/

Spring Boot 整合 NoSQLSpring Boot 整合 Redis
配置redis基本信息
# redis 密码，没有的话可以不弄#spring.redis.password=123spring.redis.host=127.0.0.1spring.redis.port=6379

依赖
&lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;        &lt;/dependency&gt;

实体类
public class User implements Serializable &#123;//Serializable接口可以实现自动序列化    private String username;    private String address;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;username=&#x27;&quot; + username + &#x27;\&#x27;&#x27; +                &quot;, address=&#x27;&quot; + address + &#x27;\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public String getAddress() &#123;        return address;    &#125;    public void setAddress(String address) &#123;        this.address = address;    &#125;&#125;

单元测试代码
@SpringBootTestclass RedisApplicationTests &#123;    @Autowired    RedisTemplate redisTemplate;//键值对可以是对象，并会自动序列化    @Autowired    StringRedisTemplate stringRedisTemplate;//键值对只能是string    @Test    void contextLoads() &#123;        User user = new User();        user.setUsername(&quot;javaboy&quot;);        user.setAddress(&quot;www.javaboy.org&quot;);        ValueOperations ops = redisTemplate.opsForValue();        ops.set(&quot;u&quot;, user);        User u = (User) ops.get(&quot;u&quot;);//拿到对象以后又自动帮我反序列化        System.out.println(&quot;u = &quot; + u);    &#125;    @Test    void test1() throws JsonProcessingException &#123;        ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue();        User user = new User();        user.setUsername(&quot;javaboy&quot;);        user.setAddress(&quot;www.javaboy.org&quot;);        ObjectMapper om = new ObjectMapper();        String s = om.writeValueAsString(user);//将对象序列化成字符串，“s”        ops.set(&quot;u1&quot;, s);        String u1 = ops.get(&quot;u1&quot;);        User user1 = om.readValue(u1, User.class);//反序列化成对象        System.out.println(&quot;user1 = &quot; + user1);    &#125;&#125;



RedisTemplate测试结果，key的值也会进行序列化操作



  .pyzrqgsszxii{width:70%}



StringRedisTemplate测试结果，不会进行任何序列化操作


  .xrbojunivtii{width:70%}



Spring Boot 整合 Redis的具体应用—session共享
所需的依赖【redis、spring session】
&lt;dependencies&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;           &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;       &lt;/dependency&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;           &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;       &lt;/dependency&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;           &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;       &lt;/dependency&gt;          &lt;dependency&gt;           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;           &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;           &lt;scope&gt;test&lt;/scope&gt;       &lt;/dependency&gt;   &lt;/dependencies&gt;

redis基本信息的配置和之前一样

代码，往session里面存数据以及读数据
@RestControllerpublic class HelloController &#123;    @Value(&quot;$&#123;server.port&#125;&quot;)//注入项目的端口号    Integer port;    @GetMapping(&quot;/set&quot;)    public String set(HttpSession session) &#123;        session.setAttribute(&quot;javaboy&quot;, &quot;www.javaboy.org&quot;);        return String.valueOf(port);    &#125;    @GetMapping(&quot;/get&quot;)    public String get(HttpSession session) &#123;        String javaboy = (String) session.getAttribute(&quot;javaboy&quot;);        return javaboy + &quot;:&quot; + port;    &#125;&#125;

如果引入了redis和spring session的依赖，那么关于spring的操作会被自动的拦截下来，本来session会存在内存里面，现在不会了，会存在redis里面

打成jar包，在不同的端口【8080&#x2F;8081】测试
java -jar sessionshare-0.0.1-SNAPSHOT.jar --server.port=8080
java -jar sessionshare-0.0.1-SNAPSHOT.jar --server.port=8081

测试结果



  .gugfincoeidf{width:70%}



redis处理SpringBoot接口幂等性
配置redis基本信息

在token包下定义所设计到的redis操作

定义RedisService类，操作redis
@Servicepublic class RedisService &#123;    @Autowired    StringRedisTemplate stringRedisTemplate;//把redis注册进来    public boolean setEx(String key, String value, Long expireTime) &#123;        boolean result = false;        try &#123;            ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue();//先拿到ops对象            ops.set(key,value);            stringRedisTemplate.expire(key, expireTime, TimeUnit.SECONDS);//设置过期时间            result = true;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        return result;    &#125;    public boolean exists(String key) &#123;//判断key是否存在        return stringRedisTemplate.hasKey(key);    &#125;    public boolean remove(String key) &#123;//移除，如果这次请求成功了就要把redis里面的token移出掉，                                       // 这样的话下一个请求带着相同的token来，请求就不会被通过。                                       //不被通过，所以要去重新获取一个token，这个过程就会避免一个接口被调用多次。        if (exists(key)) &#123;//判断key是否存在            return stringRedisTemplate.delete(key);        &#125;        return false;    &#125;&#125;

定义TokenService，设计到令牌的操作
@Servicepublic class TokenService &#123;    @Autowired    RedisService redisService;    public String createToken() &#123;//生成令牌        String uuid = UUID.randomUUID().toString();        redisService.setEx(uuid, uuid, 10000L);//10000秒，如果过期了token会自动的从redis里面移除掉                                                        //有效期只有一次：一旦用过了，就失效了；或者没有用，时间到了也会失效        return uuid;    &#125;    public boolean checkToken(HttpServletRequest request) throws IdempotentException &#123;//检查token，从请求里面尝试拿参数过来        String token = request.getHeader(&quot;token&quot;);        if (StringUtils.isEmpty(token)) &#123;//如果是空的            token = request.getParameter(&quot;token&quot;);            if (StringUtils.isEmpty(token)) &#123;//这里还是空的，证明请求过来的时候压根就没有带token                throw new IdempotentException(&quot;token 不存在&quot;);            &#125;        &#125;        //执行到这一步，证明是正常的，有token，看redis有没有token        if (!redisService.exists(token)) &#123;            throw new IdempotentException(&quot;重复操作！&quot;);        &#125;        boolean remove = redisService.remove(token);        if (!remove) &#123;            throw new IdempotentException(&quot;重复操作！&quot;);        &#125;        return true;//表示检查通过    &#125;&#125;

在exceptiion包下定义名为IdempotentException的异常，上面的方法需要用到
public class IdempotentException extends Exception &#123;    public IdempotentException(String message) &#123;        super(message);    &#125;&#125;

在注解anno包下，定义注解，到时候把这个注解加到方法上，哪个方法有这个注解，哪个方法上有这个注解，就要处理这个注解的幂等性问题。
@Target(ElementType.METHOD)//表示“被标注”的注解只能出现在方法上@Retention(RetentionPolicy.RUNTIME)//用来标注“被标注的注解”最终保存在哪里。public @interface AutoIdempotent &#123;&#125;

接下来就要对这个注解进行解析，注解的解析有两种方法：拦截器和AOP





拦截器方法
建一个拦截器的包interceptor，里面定义一个类IdempotentInterceptor，要继承HandlerInterceptor接口
@Componentpublic class IdempotentInterceptor implements HandlerInterceptor &#123;    @Autowired    TokenService tokenService;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        if (!(handler instanceof HandlerMethod)) &#123;            return true;        &#125;        Method method = ((HandlerMethod) handler).getMethod();//强转成HandlerMethod，再getMethod                                                              //这里的method，就是到时候controller层定义的method                                                              //而这个method会被@AutoIdempotent这个定义好的注解修饰        AutoIdempotent idempotent = method.getAnnotation(AutoIdempotent.class);//获取注解        if (idempotent != null) &#123;//如果等于null，代表没有加@AutoIdempotent这个的注解                                // 如果不等于null,代表这个接口要进行幂等性的处理            try &#123;                return tokenService.checkToken(request);            &#125; catch (IdempotentException e) &#123;                throw e;            &#125;        &#125;        return true;    &#125;&#125;

配置cocnfig使拦截器生效
@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123;    @Autowired    IdempotentInterceptor idempotentInterceptor;    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        registry.addInterceptor(idempotentInterceptor).addPathPatterns(&quot;/**&quot;);    &#125;&#125;

在exceptiion包下定义一个全局异常处理器
@RestControllerAdvicepublic class GlobalException &#123;    @ExceptionHandler(IdempotentException.class)    public String idempotentException(IdempotentException e) &#123;        return e.getMessage();    &#125;&#125;

定义Controller层的测试接口
@RestControllerpublic class HelloController &#123;    @Autowired    TokenService tokenService;    @GetMapping(&quot;/gettoken&quot;)//获取token的一个接口    public String getToken() &#123;        return tokenService.createToken();    &#125;    @PostMapping(&quot;/hello&quot;)//一般来讲get请求不需要处理幂等性，而post需要    @AutoIdempotent//代表这个接口需要去处理幂等性    public String hello() &#123;        return &quot;hello&quot;;    &#125;    @PostMapping(&quot;/hello2&quot;)    public String hello2() &#123;        return &quot;hello2&quot;;    &#125;&#125;

测试结果

直接访问hello接口【这个接口被@AutoIdempotent注解注释了】




  .qbzpmorogrjl{width:70%}



没有被注释过的接口


  .imvfdrcpnsxn{width:70%}



获取token


  .wdjchnlgtrdz{width:70%}



拿到token以后就可以去请求被@AutoIdempotent注释过的接口了，参数可以放到请求体里也可以放到请求头里


  .ldbhgkcmibel{width:70%}



再次请求，因为token已经用过了，所以失败


  .hgadvmgubbss{width:70%}



AOP与拦截器的方法相比，拦截器只能解析controller上的注解，但是方法上的不行

依赖
&lt;dependency&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;     &lt;/dependency&gt;

代码实现
@Component@Aspectpublic class IdempotentAspect &#123;    @Autowired    TokenService tokenService;    @Pointcut(&quot;@annotation(org.javaboy.idempontent.anno.AutoIdempotent)&quot;)//谁加了@AutoIdempotent注解就拦截谁    public void pc1() &#123;    &#125;    @Before(&quot;pc1()&quot;)    public void before() throws IdempotentException &#123;        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();//拿到当前的请求        try &#123;            tokenService.checkToken(request);        &#125; catch (IdempotentException e) &#123;            throw e;        &#125;    &#125;&#125;

测试方式和拦截器一致



Spring Boot 构建 RESTful 风格接口转载： 松哥：Spring Boot 中 10 行代码构建 RESTful 风格应用
 http://springboot.javaboy.org/2019/0606/springboot-restful

SpringBoot缓存Spring Cache基本用法具体的注解用法可以参考：http://springboot.javaboy.org/2019/0416/springboot-redis

配置redis基本信息
spring.redis.host=127.0.0.1spring.redis.port=6379

创建实体类，因为User对象要缓存到redis里面去，所以要实现Serializable接口
public class User implements Serializable &#123;    private String username;    private Long id;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;username=&#x27;&quot; + username + &#x27;\&#x27;&#x27; +                &quot;, id=&quot; + id +                &#x27;&#125;&#x27;;    &#125;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public Long getId() &#123;        return id;    &#125;    public void setId(Long id) &#123;        this.id = id;    &#125;&#125;

service包下的UserService
@Servicepublic class UserService &#123;    @Cacheable(cacheNames = &quot;c1&quot;)//标记在方法上，表示该方法的返回结果需要缓存，默认情况下，方法的参数将作为缓存的 key    public User getUserById(Long id) &#123;        System.out.println(&quot;getUserById:&quot; + id);        User user = new User();        user.setId(id);        user.setUsername(&quot;javaboy&quot;);        return user;    &#125;&#125;

单元测试
@SpringBootTestclass CacheRedisApplicationTests &#123;    @Autowired    UserService userService;    @Test    void contextLoads1() &#123;        for (int i = 0; i &lt; 3; i++) &#123;            User u = userService.getUserById(98L);            System.out.println(&quot;u = &quot; + u);        &#125;    &#125;&#125;

测试,也就是说UserService中的方法只执行了一次，而数据就是从缓存中来的



  .lwptsarflzjq{width:70%}



service包下的UserService
/** * 如果方法存在多个参数，那么参数共同作为缓存的key * @param id * @param username * @return */@Cacheable(cacheNames = &quot;c1&quot;)//标记在方法上，表示该方法的返回结果需要缓存，默认情况下，方法的参数将作为缓存的 keypublic User getUserById2(Long id, String username) &#123;    System.out.println(&quot;getUserById2:&quot; + id);    User user = new User();    user.setId(id);    user.setUsername(username);    return user;&#125;

单元测试
@AutowiredUserService userService;@Testvoid contextLoads1() &#123;    User u1 = userService.getUserById2(98L,&quot;张三&quot;);    User u2 = userService.getUserById2(98L,&quot;张三&quot;);&#125;

结果,如果方法存在多个参数，那么参数共同作为缓存的key



  .jlcolglbqtks{width:70%}







自定义缓存key
MyKeyGenerator实现KeyGenerator接口
@Componentpublic class MyKeyGenerator implements KeyGenerator &#123;    @Override    public Object generate(Object target, Method method, Object... params) &#123;        String s = target.toString() + &quot;:&quot; + method.getName() + &quot;:&quot; + Arrays.toString(params);        return s;    &#125;&#125;

UserService类
  @Cacheable(cacheNames = &quot;c1&quot;,keyGenerator = &quot;myKeyGenerator&quot;)//标记在方法上，表示该方法的返回结果需要缓存，默认情况下，方法的参数将作为缓存的 key    public User getUserById3 (Long id,String username) &#123;        System.out.println(&quot;getUserById2:&quot; + id);        User user = new User();        user.setId(id);        user.setUsername(username);        return user;    &#125;&#125;

单元测试
@AutowiredUserService userService;@Testvoid contextLoads1() &#123;    User u1 = userService.getUserById3(98L,&quot;张三&quot;);    User u2 = userService.getUserById3(98L,&quot;张三&quot;);    System.out.println(u1);    System.out.println(u2);&#125;

测试结果



  .eriavxvpepzu{width:70%}



更新缓存
UserService类
@CachePut &#x2F;&#x2F;如果缓存不存在，则运行缓存，否则进行更新
注意：key必须要保持一致，比如这里是#user.id 上面的是 id
   @CachePut(cacheNames = &quot;c1&quot;,key = &quot;#user.id&quot;)public User updateUserById(User user)&#123;    return user;&#125;

单元测试
@Test    void contextLoads() &#123;        User u1 = userService.getUserById(99L);         u1.setUsername(&quot;wangwu&quot;);         userService.updateUserById(u1);        User u2 = userService.getUserById(99L);        System.out.println(&quot;u2 = &quot; + u2);    &#125;

测试结果



  .hgjqrfedcbfr{width:70%}





清空缓存
UserService
@CacheEvict(cacheNames = &quot;c1&quot;)    public void deleteById(Long id)&#123;        System.out.println(&quot;deleteById&quot;);    &#125;

单元测试
@Testvoid contextLoads() &#123;    User u1 = userService.getUserById(100L);    userService.deleteById(100L);    userService.getUserById(100L);&#125;

测试结果



  .jesvsijbxskg{width:70%}





其他操作@CacheConfig可以配置到类上（不能放到方法上），所做的事情就是全局配置。
@Service@CacheConfig(cacheNames = &quot;c1&quot;)public class UserService &#123;

所以下面的所有方法都不需要配置cacheNames了

SpringBoot+WebSocket实现聊天室功能群聊
依赖
        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;        &lt;/dependency&gt;           &lt;dependency&gt;            &lt;groupId&gt;org.webjars&lt;/groupId&gt;            &lt;artifactId&gt;sockjs-client&lt;/artifactId&gt;            &lt;version&gt;1.1.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.webjars&lt;/groupId&gt;            &lt;artifactId&gt;stomp-websocket&lt;/artifactId&gt;            &lt;version&gt;2.3.3&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.webjars&lt;/groupId&gt;            &lt;artifactId&gt;jquery&lt;/artifactId&gt;            &lt;version&gt;3.5.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.webjars&lt;/groupId&gt;            &lt;artifactId&gt;webjars-locator-core&lt;/artifactId&gt;&lt;!--            &lt;version&gt;0.46&lt;/version&gt;--&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;

对WebSocket进行一个配置，config包下的WebSocketConfig
@Configuration@EnableWebSocketMessageBroker//开启WebSocket的消息代理public class WebSocketConfig implements WebSocketMessageBrokerConfigurer &#123;//注册端点    @Override    public void registerStompEndpoints(StompEndpointRegistry registry) &#123;        registry.addEndpoint(&quot;/chat&quot;).setAllowedOrigins(&quot;http://localhost:8080&quot;).withSockJS();//withSockJS让他支持SockJS        //↑定义了前缀为chat的endpoint，开启了对SockJS的支持，解决了浏览器对WebSock兼容性的问题    &#125;    @Override    public void configureMessageBroker(MessageBrokerRegistry registry) &#123;//配置消息代理        registry.enableSimpleBroker(&quot;/topic&quot;,&quot;/queue&quot;);//设置消息代理的前缀。如果到时候发送的消息前缀是topic的话，                                                                        // 就会把消息转发给消息代理，                                                                        // 然后消息代理再把消息广播到当前连接上来的所有客户端//        registry.setApplicationDestinationPrefixes(&quot;/app&quot;);//也可以不用它的消息代理，自己去转发消息。配置一个消息前缀：//                                                          通过前缀，区分出来被注解方法处理的消息。                                                                &#125;&#125;

先定义一个消息对象Message
public class Message &#123;    private String name;//是谁发出来的    private String content;    @Override    public String toString() &#123;        return &quot;Message&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +                &quot;, content=&#x27;&quot; + content + &#x27;\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getContent() &#123;        return content;    &#125;    public void setContent(String content) &#123;        this.content = content;    &#125;&#125;

在controller层的GreetingController下
@Controllerpublic class GreetingController &#123;    @MessageMapping(&quot;/hello&quot;)    @SendTo(&quot;/topic/greetings&quot;)//前段页面上会有一个/topic/greetings这样的监听地址，去监听这里发送的消息    public Message greeting(Message message) &#123;        return message;    &#125;&#125;

编写前端代码
&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script src=&quot;/webjars/jquery/jquery.min.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;/webjars/sockjs-client/sockjs.min.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;/webjars/stomp-websocket/stomp.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;    &lt;label for=&quot;username&quot;&gt;请输入用户名：&lt;/label&gt;    &lt;input type=&quot;text&quot; id=&quot;username&quot; placeholder=&quot;用户名&quot;&gt;&lt;/div&gt;&lt;div&gt;    &lt;input type=&quot;button&quot; value=&quot;连接&quot; id=&quot;connect&quot;&gt;    &lt;input type=&quot;button&quot; value=&quot;断开连接&quot; id=&quot;disconnet&quot; disabled=&quot;disabled&quot;&gt;&lt;/div&gt;&lt;div id=&quot;chat&quot;&gt;&lt;/div&gt;&lt;div&gt;    &lt;label for=&quot;content&quot;&gt;请输入聊天内容&lt;/label&gt;    &lt;input type=&quot;text&quot; id=&quot;content&quot; placeholder=&quot;聊天内容&quot;&gt;&lt;/div&gt;&lt;input value=&quot;发送&quot; type=&quot;button&quot; id=&quot;send&quot; disabled=&quot;disabled&quot;&gt;&lt;/input&gt;&lt;script&gt;//页面脚本    var stompClient;    $(function () &#123;//都在页面加载完之后执行        $(&quot;#connect&quot;).click(function () &#123;//给connect这个按钮设置一个点击事件            connect();            $(&quot;#send&quot;).click(function () &#123;//点击事件，把消息发送到服务端                stompClient.send(&quot;/hello&quot;,&#123;&#125;,JSON.stringify(&#123;&#x27;name&#x27;:$(&quot;#username&quot;).val(),&#x27;content&#x27;:$(&quot;#content&quot;).val()&#125;))            &#125;)            $(&quot;#disconnet&quot;).click(function () &#123;                stompClient.disconnect();                setConnect(false);            &#125;)        &#125;)    &#125;)    function connect() &#123;//定义一个叫connect的方法        if (!$(&quot;#username&quot;).val()) &#123;//获取username的value，如果没有获取到就return掉            return;        &#125;        /*如果输入用户名了，那就准备建立WebSocket连接*/        var socketjs = new SockJS(&quot;/chat&quot;);//配置连接地址        stompClient = Stomp.over(socketjs);        stompClient.connect(&#123;&#125;,function (frame) &#123;            alert(&quot;以成功连接&quot;)            setConnect(true);//当连接成功后，断开连接按钮取消禁用，而连接按钮禁用            stompClient.subscribe(&quot;/topic/greetings&quot;/*去订阅消息*/, function (greeting) &#123;                var msgContent = JSON.parse(greeting.body);//返回来的就是一个序列化后的json，再通过JSON.parse转成json对象                console.log(msgContent);                $(&quot;#chat&quot;).append(&quot;&lt;div&gt;&quot;+msgContent.name+&quot;:&quot;+msgContent.content+&quot;&lt;/div&gt;&quot;);//找到id为chat的区域，往里面追加消息            &#125;);        &#125;)    &#125;    function setConnect(connected) &#123;//当连接成功后，断开连接按钮取消禁用，而连接按钮禁用        $(&quot;#connect&quot;).prop(&quot;disabled&quot;, connected);        $(&quot;#disconnet&quot;).prop(&quot;disabled&quot;, !connected);        $(&quot;#send&quot;).prop(&quot;disabled&quot;, !connected);    &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;

访问localhost:8080&#x2F;chat.html

测试结果



  .pvnipitdstpy{width:70%}




私聊
依赖，加入springsecurity依赖
&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;

WebSocketConfig



  .cornmqqvusbw{width:70%}



私聊的需要的实体类
public class Chat &#123;    private String to;//发个谁    private String from;//谁发的    private String content;//内容    public String getTo() &#123;        return to;    &#125;    public void setTo(String to) &#123;        this.to = to;    &#125;    public String getFrom() &#123;        return from;    &#125;    public void setFrom(String from) &#123;        this.from = from;    &#125;    public String getContent() &#123;        return content;    &#125;    public void setContent(String content) &#123;        this.content = content;    &#125;&#125;


Spring Boot 与消息中间件用docker安装rabbitmq
  .jjfbrlizjbtb{width:70%}



其中代码可以查看官网https://hub.docker.com/_/rabbitmq


  .ghckvyxqbvmg{width:70%}



docker运行rabbitmq时端口的介绍


  .vucoqftsvxwu{width:70%}



测试

管理端端口，账号密码都是guest




  .hkmbmrwvqpze{width:70%}


如果是在虚拟机上安装，可以参考https://blog.csdn.net/qq_45502336/article/details/118699251

SpringBoot整合RabbitMQ
依赖
&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;

application.properties配置
spring.rabbitmq.host=8.142.93.194spring.rabbitmq.username=guestspring.rabbitmq.password=guestspring.rabbitmq.port=49156




三种交换策略direct模式
配置
​      如果用了 direct 模式，下面两个 bean 可以省略
import org.springframework.amqp.core.Binding;import org.springframework.amqp.core.BindingBuilder;import org.springframework.amqp.core.DirectExchange;import org.springframework.amqp.core.Queue;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class DirectConfig &#123;    //消息队列    @Bean    Queue directQueue() &#123;        return new Queue(&quot;javaboy-queue&quot;);    &#125;     /**     * 直来直去的交换机     * name:交换机的名字     * durable:重启队列后是否有效     * autoDelete：长期未使用是否自动删除     * @return     */    @Bean    DirectExchange directExchange() &#123;        return new DirectExchange(&quot;javaboy-direct&quot;, true, false);    &#125;    /**     * 相等于粘合剂，把队列和交换机绑定到一起     * @return     */    @Bean    Binding directBinding() &#123;        return BindingBuilder.bind(directQueue()).to(directExchange()).with(&quot;direct&quot;);    &#125;&#125;



消息接收
@Componentpublic class DirectReceiver &#123;    @RabbitListener(queues = &quot;javaboy-queue&quot;)//指定监听的队列是什么    public void handler(String msg) &#123;        System.out.println(&quot;msg = &quot; + msg);    &#125;&#125;

单元测试
import org.junit.jupiter.api.Test;import org.springframework.amqp.core.Message;import org.springframework.amqp.core.MessageBuilder;import org.springframework.amqp.rabbit.core.RabbitTemplate;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestclassAmqpApplicationTests &#123;    @Autowired    RabbitTemplate rabbitTemplate;    @Test    void contextLoads() &#123;        rabbitTemplate.convertAndSend(&quot;javaboy-queue&quot;, &quot;hello javaboy!&quot;);    &#125;&#125;


  .tkiidsxlipps{width:70%}



fanout模式
配置
​     
import org.springframework.amqp.core.Binding;import org.springframework.amqp.core.BindingBuilder;import org.springframework.amqp.core.FanoutExchange;import org.springframework.amqp.core.Queue;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class FanoutConfig &#123;    @Bean    Queue queueOne() &#123;        return new Queue(&quot;queue-one&quot;);    &#125;    @Bean    Queue queueTwo() &#123;        return new Queue(&quot;queue-two&quot;);    &#125;    //fanout交换机    @Bean    FanoutExchange fanoutExchange() &#123;        return new FanoutExchange(&quot;javaboy-fanout&quot;, true, false);    &#125;    @Bean    Binding bindingOne() &#123;        return BindingBuilder.bind(queueOne()).to(fanoutExchange());    &#125;    @Bean    Binding bindingTwo() &#123;        return BindingBuilder.bind(queueTwo()).to(fanoutExchange());    &#125;&#125;



消息接收
@Componentpublic class FanoutRecevier &#123;    @RabbitListener(queues = &quot;queue-one&quot;)    public void handler1(String msg) &#123;        System.out.println(&quot;handler1:msg = &quot; + msg);    &#125;    @RabbitListener(queues = &quot;queue-two&quot;)    public void handler2(String msg) &#123;        System.out.println(&quot;handler2:msg = &quot; + msg);    &#125;&#125;



单元测试
import org.junit.jupiter.api.Test;import org.springframework.amqp.core.Message;import org.springframework.amqp.core.MessageBuilder;import org.springframework.amqp.rabbit.core.RabbitTemplate;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestclassAmqpApplicationTests &#123;    @Autowired    RabbitTemplate rabbitTemplate;    @Test    void contextLoads() &#123;        rabbitTemplate.convertAndSend(&quot;javaboy-queue&quot;, &quot;hello javaboy!&quot;);    &#125;&#125;

因为这次绑定的交换机。消息是往交换机上发，而这个交换机上又维系着两个消息队列，所以两个消息队列都可以收到消息



  .rfwfhnfukihq{width:70%}



topic模式
配置
这里粘合剂最后一个参数是“routingKey”非常的关键：一会消息的routingKey如果是xiaomi.xxx的话，那么就会被这个消息队列所接收到 
@Configurationpublic class TopicConfig &#123;    @Bean    Queue xiaomi() &#123;        return new Queue(&quot;xiaomi&quot;);    &#125;    @Bean    Queue huawei() &#123;        return new Queue(&quot;huawei&quot;);    &#125;    @Bean    Queue phone() &#123;        return new Queue(&quot;phone&quot;);    &#125;    @Bean    TopicExchange topicExchange() &#123;        return new TopicExchange(&quot;javaboy-topic&quot;, true, false);    &#125;    @Bean    Binding xiaomiBinding() &#123;        return BindingBuilder.bind(xiaomi()).to(topicExchange()).with(&quot;xiaomi.#&quot;);    &#125;    @Bean    Binding huaweiBinding() &#123;        return BindingBuilder.bind(huawei()).to(topicExchange()).with(&quot;huawei.#&quot;);    &#125;    @Bean    Binding phoneBinding() &#123;        return BindingBuilder.bind(phone()).to(topicExchange()).with(&quot;#.phone.#&quot;);    &#125;&#125;



消息接收
@Componentpublic class TopicReceiver &#123;    @RabbitListener(queues = &quot;phone&quot;)    public void handler1(String msg) &#123;        System.out.println(&quot;phone:msg = &quot; + msg);    &#125;    @RabbitListener(queues = &quot;xiaomi&quot;)    public void handler2(String msg) &#123;        System.out.println(&quot;xiaomi:msg = &quot; + msg);    &#125;    @RabbitListener(queues = &quot;huawei&quot;)    public void handler3(String msg) &#123;        System.out.println(&quot;huawei:msg = &quot; + msg);    &#125;&#125;



单元测试
@SpringBootTestclassAmqpApplicationTests &#123;    @Autowired    RabbitTemplate rabbitTemplate;    @Test    void contextLoads() &#123;        rabbitTemplate.convertAndSend(&quot;javaboy-topic&quot;,&quot;xiaomi.news&quot;,&quot;小米新闻&quot;);        rabbitTemplate.convertAndSend(&quot;javaboy-topic&quot;,&quot;xiaomi.phone&quot;,&quot;小米手机&quot;);        Message nameMsg = MessageBuilder.withBody(&quot;hello javbaoy-name&quot;.getBytes()).setHeader(&quot;name&quot;, &quot;javaboy&quot;).build();    &#125;&#125;

因为这次绑定的交换机。消息是往交换机上发，而这个交换机上又维系着两个消息队列，所以两个消息队列都可以收到消息



  .xomrtdvkvuxd{width:70%}





header模式
配置 
@Configurationpublic class HeaderConfig &#123;    @Bean    Queue queueAge() &#123;        return new Queue(&quot;queue-age&quot;);    &#125;    @Bean    Queue queueName() &#123;        return new Queue(&quot;queue-name&quot;);    &#125;    @Bean    HeadersExchange headersExchange() &#123;        return new HeadersExchange(&quot;javaboy-header&quot;, true, false);    &#125;    @Bean    Binding bindingAge() &#123;        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;age&quot;, 99);//head中必须有age，并且值为99        return BindingBuilder.bind(queueAge()).to(headersExchange()).whereAny(map).match();    &#125;    @Bean    Binding bindingName() &#123;        return BindingBuilder.bind(queueName()).to(headersExchange()).where(&quot;name&quot;).exists();//只有存在name这个属性就行    &#125;&#125;



消息接收
@Componentpublic class HeaderReceiver &#123;    @RabbitListener(queues = &quot;queue-age&quot;)    public void handler1(String msg) &#123;        System.out.println(&quot;queue-age:msg = &quot; + msg);    &#125;    @RabbitListener(queues = &quot;queue-name&quot;)    public void handler2(String msg) &#123;        System.out.println(&quot;queue-name:msg = &quot; + msg);    &#125;&#125;



单元测试
    @Autowired    RabbitTemplate rabbitTemplate;    @Test    void contextLoads() &#123;//        rabbitTemplate.convertAndSend(&quot;javaboy-queue&quot;, &quot;hello javaboy!&quot;);//         rabbitTemplate.convertAndSend(&quot;javaboy-fanout&quot;, null, &quot;歪比巴卜&quot;);//        rabbitTemplate.convertAndSend(&quot;javaboy-topic&quot;,&quot;xiaomi.news&quot;,&quot;小米新闻&quot;);//        rabbitTemplate.convertAndSend(&quot;javaboy-topic&quot;,&quot;xiaomi.phone&quot;,&quot;小米手机&quot;);//        Message nameMsg = MessageBuilder.withBody(&quot;hello javbaoy-name&quot;.getBytes()).setHeader(&quot;name&quot;, &quot;javaboy&quot;).build();        Message ageMsg = MessageBuilder.withBody(&quot;hello javbaoy-age&quot;.getBytes()).setHeader(&quot;age&quot;, 99).build();//        rabbitTemplate.send(&quot;javaboy-header&quot;,null,nameMsg);        rabbitTemplate.send(&quot;javaboy-header&quot;,null,ageMsg);    &#125;&#125;

测试结果



  .btvbrmlmrihw{width:70%}



  .xskgwgnpdhiv{width:70%}





Spring Boot企业级开发邮件发送提前准备：http://itboyhub.com/2021/01/25/java-mail/
发送简单邮件
依赖
&lt;dependency&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;     &lt;/dependency&gt; 

配置
spring.mail.host=smtp.qq.comspring.mail.port=465spring.mail.username=1473220685@qq.comspring.mail.password=zytnklxrvfrjfgfdspring.mail.default-encoding=utf-8#一个加密连接的工具类spring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactoryspring.mail.properties.mail.debug=true

测试
@AutowiredJavaMailSender javaMailSender;@Testvoid contextLoads() &#123;    SimpleMailMessage simpMsg = new SimpleMailMessage();    simpMsg.setFrom(&quot;1473220685@qq.com&quot;);    simpMsg.setTo(&quot;1473220649@qq.com&quot;);    simpMsg.setSentDate(new Date());    simpMsg.setSubject(&quot;邮件主题-测试邮件&quot;);    simpMsg.setText(&quot;邮件内容-测试邮件&quot;);    javaMailSender.send(simpMsg);&#125;

发送带附件的邮件@Testvoid test1() throws MessagingException &#123;    File file = new File(&quot;E:\\photo\\微信图片_20220501212727.png&quot;);    MimeMessage mimeMessage = javaMailSender.createMimeMessage();//创建对象【附件邮件的对象没法new 】    MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true);//工具类，复合邮件    helper.setFrom(&quot;1473220685@qq.com&quot;);    helper.setTo(&quot;1741255713@qq.com&quot;);    helper.setSentDate(new Date());    helper.setSubject(&quot;邮件主题-测试邮件&quot;);    helper.setText(&quot;邮件内容-测试邮件&quot;);    helper.addAttachment(file.getName(), file);    javaMailSender.send(mimeMessage);&#125;





发送带图片资源的邮件【了解，不怎么用】@Testvoid test2() throws MessagingException &#123;    File file = new File(&quot;E:\\photo\\微信图片_20220501212727.png&quot;);    MimeMessage mimeMessage = javaMailSender.createMimeMessage();    MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true);    helper.setFrom(&quot;1473220685@qq.com&quot;);    helper.setTo(&quot;1473220649@qq.com&quot;);    helper.setSentDate(new Date());    helper.setSubject(&quot;邮件主题-测试邮件&quot;);    helper.setText(&quot;&lt;div&gt;hello ，这是一封带图片资源的邮件。。。&lt;/div&gt;&lt;div&gt;&lt;img src=&#x27;cid:p01&#x27; /&gt;&lt;/div&gt;&quot;, true);    helper.addInline(&quot;p01&quot;, file);    javaMailSender.send(mimeMessage);&#125;





使用freemarker&#x2F;thymleaf做邮件模板准备工作依赖：
&lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;        &lt;/dependency&gt;



package com.example.demo.model;public class User &#123;    private String username;    private Double salary;    private String position;    private String company;   //get set方法省略&#125;



freemarkerresource&#x2F;mail下的mail.ftl文件
&lt;div&gt;欢迎 $&#123;username&#125; 加入 $&#123;company&#125; 大家庭，您的入职信息如下：&lt;/div&gt;&lt;table border=&quot;1&quot;&gt;    &lt;tr&gt;        &lt;td&gt;姓名&lt;/td&gt;        &lt;td&gt;$&#123;username&#125;&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;职位&lt;/td&gt;        &lt;td&gt;$&#123;position&#125;&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;薪水&lt;/td&gt;        &lt;td&gt;$&#123;salary&#125;&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;&lt;div style=&quot;color: #ff0114;font-size: large&quot;&gt;希望在未来的日子里携手奋进！&lt;/div&gt;

@Test   void test3() throws MessagingException, IOException, TemplateException &#123;       MimeMessage mimeMessage = javaMailSender.createMimeMessage();       MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true);       helper.setFrom(&quot;1473220685@qq.com&quot;);       helper.setTo(&quot;1473220649@qq.com&quot;);       helper.setSentDate(new Date());       helper.setSubject(&quot;邮件主题-测试邮件&quot;);       Configuration cfg = new Configuration(Configuration.VERSION_2_3_30);//freemarker的配置       cfg.setClassLoaderForTemplateLoading(DemoApplication.class.getClassLoader(), &quot;mail&quot;);//第一个参数是类加载器，第二个参数是模板的位置       Template template = cfg.getTemplate(&quot;mail.ftl&quot;);//获取模板       User user = new User();       user.setCompany(&quot;xxx公司&quot;);       user.setUsername(&quot;javaboy&quot;);       user.setPosition(&quot;Java架构师&quot;);       user.setSalary(999999.0);       StringWriter out = new StringWriter();//输出流，就是ftl渲染之后的内容       template.process(user, out);       String text = out.toString();//toString里的就是邮件内容       System.out.println(&quot;text = &quot; + text);       helper.setText(text, true);       javaMailSender.send(mimeMessage);   &#125;

thymleaf在templates文件夹下创建mail.html文件【默认的文件目录就是templates，放在其他地方还要再配置】
&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;欢迎 &lt;span th:text=&quot;$&#123;username&#125;&quot;&gt;&lt;/span&gt; 加入 &lt;span th:text=&quot;$&#123;company&#125;&quot;&gt;&lt;/span&gt; 大家庭，您的入职信息如下：&lt;/div&gt;&lt;table border=&quot;1&quot;&gt;    &lt;tr&gt;        &lt;td&gt;姓名&lt;/td&gt;        &lt;td th:text=&quot;$&#123;username&#125;&quot;&gt;&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;职位&lt;/td&gt;        &lt;td th:text=&quot;$&#123;position&#125;&quot;&gt;&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;薪水&lt;/td&gt;        &lt;td th:text=&quot;$&#123;salary&#125;&quot;&gt;&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;&lt;div&gt;    &lt;img src=&quot;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.jj20.com%2Fup%2Fallimg%2F1113%2F052420110515%2F200524110515-2-1200.jpg&amp;refer=http%3A%2F%2Fimg.jj20.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1654615656&amp;t=df22f9999a3f041f1a8c6798e460babd&quot;&gt;&lt;/div&gt;&lt;div style=&quot;color: #ff0114;font-size: large&quot;&gt;希望在未来的日子里携手奋进！&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;



//↓↓↓模板引擎↓↓↓ 注入进来就可以直接用了    @Autowired    TemplateEngine templateEngine;    @Test    void test4() throws MessagingException, IOException, TemplateException &#123;        MimeMessage mimeMessage = javaMailSender.createMimeMessage();        MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true);        helper.setFrom(&quot;1473220685@qq.com&quot;);        helper.setTo(&quot;1473220649@qq.com&quot;);        helper.setSentDate(new Date());        helper.setSubject(&quot;邮件主题-测试邮件&quot;);      /*  User user = new User();        user.setCompany(&quot;xxx公司&quot;);        user.setUsername(&quot;javaboy&quot;);        user.setPosition(&quot;Java架构师&quot;);        user.setSalary(999999.0);*/        Context ctx = new Context();        ctx.setVariable(&quot;username&quot;,&quot;javaboy&quot;);        ctx.setVariable(&quot;position&quot;,&quot;Java工程师&quot;);        ctx.setVariable(&quot;company&quot;,&quot;xxx集团&quot;);        ctx.setVariable(&quot;salary&quot;, &quot;999999&quot;);        String text = templateEngine.process(&quot;mail.html&quot;, ctx);//用templateEngine把html渲染出来。        System.out.println(text);        // ↑↑↑第一个参数是模板名，第二个参数是一个上下文，因为没有给放对象的机会↑↑↑        helper.setText(text, true);        javaMailSender.send(mimeMessage);    &#125;







定时任务@Sccheduled]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>2022寒假自学笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>hadoop与hive的安装和配置</title>
    <url>/2024/06/20/hadoop%E4%B8%8Ehive%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[ssh登录过程
连接请求
用户通过 SSH 客户端发起连接请求，指定目标主机和用户名，即ssh username@hostname

服务器响应
服务器收到连接请求后，会发送一个公钥给客户端。

公钥验证
客户端收到服务器发送的公钥后，会检查这个公钥是否在自己的 known_hosts 文件中。如果没有找到，会发出警告，询问用户是否信任这个公钥，用户可以选择是或否。
ssh 111.229.25.127The authenticity of host &#x27;111.229.25.127 (111.229.25.127)&#x27; can&#x27;t be established.ECDSA key fingerprint is SHA256:1OLYAxTlNkqPEPqX4n2Pvcg8hBzYbqD+UOfVTseEMYo.Are you sure you want to continue connecting (yes/no/[fingerprint])? yes

生成会话密钥
如果客户端接受了服务器的公钥，客户端会生成一个称为会话密钥（session key）的随机数，并用服务器的公钥对其进行加密。这样只有服务器可以解密这个会话密钥。

发送加密数据
客户端使用生成的会话密钥加密一个随机数，并发送给服务器。

验证身份
服务器使用自己的私钥解密客户端发来的数据，得到客户端生成的随机数。服务器验证客户端是否能够正确地生成和解密这个随机数，以确认客户端的身份。

建立加密会话
如果身份验证成功，服务器和客户端将使用之前生成的会话密钥来加密和解密后续的通信数据，保证通信的安全性和完整性。


hadoopssh-keygen -t rsa -b 2048 -N &quot;&quot; -f ~/.ssh/id_rsassh-copy-id hadoop@DESKTOP-FTQ64CF#cat ~/.ssh/id_rsa.pub &gt; ~/.ssh/authorized_keys#如果是想要本地wsl去免密登录远程服务器，就把本地的 ~/.ssh/id_rsa.pub的内容复制到远程服务器的/root/.ssh/authorized_keys 中



vi /etc/profileexport JAVA_HOME=/usr/local/java/jdk1.8.0_221export PATH=$JAVA_HOME/bin:$PATH export HADOOP_HOME=/home/hadoop/hadoop-3.3.6export PATH=$PATH:$HADOOP_HOME/binexport PATH=$PATH:$HADOOP_HOME/sbinsource /etc/profilehadoop version



/home/hadoop/hadoop-3.3.6/etc/hadoop
 hadoop-env.sh
export JAVA_HOME=/home/hadoop/java/jdk1.8.0_221export HADOOP_HOME=/home/hadoop/hadoop-3.3.6export HDFS_NAMENODE_USER=hadoopexport HDFS_DATANODE_USER=hadoopexport HDFS_SECONDARYNAMENODE_USER=hadoopexport YARN_RESOURCEMANAGER_USER=hadoopexport YARN_NODEMANAGER_USER=hadoop



core-site.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;&lt;!--  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);  you may not use this file except in compliance with the License.  You may obtain a copy of the License at    http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the License for the specific language governing permissions and  limitations under the License. See accompanying LICENSE file.--&gt;&lt;!-- Put site-specific property overrides in this file. --&gt;&lt;configuration&gt;&lt;!-- 指定 NameNode 的地址 --&gt;    &lt;property&gt;        &lt;name&gt;fs.defaultFS&lt;/name&gt;        &lt;value&gt;hdfs://localhost:9090&lt;/value&gt;    &lt;/property&gt;    &lt;!-- 指定 hadoop 数据的存储目录 --&gt;    &lt;property&gt;        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;        &lt;value&gt;/home/hadoop/hdfs/tmp&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;hadoop.proxyuser.root.hosts&lt;/name&gt;        &lt;value&gt;*&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;hadoop.proxyuser.root.groups&lt;/name&gt;        &lt;value&gt;*&lt;/value&gt;    &lt;/property&gt;	&lt;!--配置root用户能够代理的用户为任意用户--&gt;&lt;property&gt;    &lt;name&gt;hadoop.proxyuser.root.users&lt;/name&gt;    &lt;value&gt;*&lt;/value&gt;	&lt;/property&gt;&lt;property&gt;  &lt;name&gt;hadoop.proxyuser.hadoop.hosts&lt;/name&gt;  &lt;value&gt;*&lt;/value&gt;&lt;/property&gt;&lt;property&gt;  &lt;name&gt;hadoop.proxyuser.hadoop.groups&lt;/name&gt;  &lt;value&gt;*&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt;



hdfs-site.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;&lt;!--  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);  you may not use this file except in compliance with the License.  You may obtain a copy of the License at    http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the License for the specific language governing permissions and  limitations under the License. See accompanying LICENSE file.--&gt;&lt;!-- Put site-specific property overrides in this file. --&gt;&lt;configuration&gt;&lt;property&gt;        &lt;name&gt;dfs.replication&lt;/name&gt;              &lt;value&gt;1&lt;/value&gt;        &lt;description&gt;副本个数，配置默认是3,应小于datanode机器数量&lt;/description&gt;    &lt;/property&gt;      &lt;property&gt;        &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;          &lt;value&gt;/home/hadoop/hdfs/name&lt;/value&gt;          &lt;final&gt;true&lt;/final&gt;    &lt;/property&gt;      &lt;property&gt;        &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;          &lt;value&gt;/home/hadoop/hdfs/data&lt;/value&gt;          &lt;final&gt;true&lt;/final&gt;    &lt;/property&gt;      &lt;property&gt;        &lt;name&gt;dfs.http.address&lt;/name&gt;        &lt;value&gt;0.0.0.0:50070&lt;/value&gt;        &lt;description&gt;将绑定IP改为0.0.0.0，而不是本地回环IP，这样，就能够实现外网访问本机的50070端口了&lt;/description&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;dfs.permissions&lt;/name&gt;          &lt;value&gt;false&lt;/value&gt;    &lt;/property&gt;&lt;/configuration&gt;



yarn-site.xml
&lt;configuration&gt;&lt;!-- Site specific YARN configuration properties --&gt;&lt;property&gt;        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;    &lt;/property&gt;&lt;/configuration&gt;



hdfs namenode -formatcd /home/hadoop/hadoop-3.3.6/sbin/./start-all.sh



hivecd /home/hadoopcurl https://mirrors.tuna.tsinghua.edu.cn/apache/hive/hive-3.1.3/apache-hive-3.1.3-bin.tar.gz -Otar -zxvf apache-hive-3.1.3-bin.tar.gz mv apache-hive-3.1.3-bin/ hive



vi /home/hadoop/.bash_profileexport HIVE_HOME=/home/hadoop/hive #hive文件夹的路径export PATH=$PATH:$HIVE_HOME/bin#修改/root/hive/conf下的hive-site.xmlcd /home/hadoop/hive/confmv hive-default.xml.template hive-default.xml



hive-site.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;&lt;configuration&gt;  &lt;property&gt;    &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;    &lt;value&gt;jdbc:mysql://111.229.25.127:3306/hive?createDatabaseIfNotExist=true&amp;amp;useSSL=false&lt;/value&gt;    &lt;description&gt;JDBC connect string for a JDBC metastore&lt;/description&gt;  &lt;/property&gt;  &lt;property&gt;    &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt;    &lt;value&gt;com.mysql.cj.jdbc.Driver&lt;/value&gt;    &lt;description&gt;Driver class name for a JDBC metastore&lt;/description&gt;  &lt;/property&gt;  &lt;property&gt;    &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt;    &lt;value&gt;root&lt;/value&gt;    &lt;description&gt;username to use against metastore database&lt;/description&gt;  &lt;/property&gt;  &lt;property&gt;    &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt;    &lt;value&gt;wqeq&lt;/value&gt;    &lt;description&gt;password to use against metastore database&lt;/description&gt;  &lt;/property&gt;  &lt;property&gt;  &lt;name&gt;hive.security.authorization.enabled&lt;/name&gt;  &lt;value&gt;true&lt;/value&gt;&lt;/property&gt;&lt;property&gt;  &lt;name&gt;hive.server2.thrift.bind.host&lt;/name&gt;  &lt;value&gt;172.26.160.119&lt;/value&gt;  &lt;!-- 服务器的 IP 地址 --&gt;&lt;/property&gt;&lt;property&gt;  &lt;name&gt;hive.server2.thrift.port&lt;/name&gt;  &lt;value&gt;10000&lt;/value&gt; &lt;/property&gt;&lt;property&gt;  &lt;name&gt;hive.server2.enable.doAs&lt;/name&gt;  &lt;value&gt;true&lt;/value&gt;&lt;/property&gt;&lt;property&gt;  &lt;name&gt;hive.server2.enable.impersonation&lt;/name&gt;  &lt;value&gt;true&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt;



设置mysql【可选】
create database hive; #用户hive的密码是hiveCREATE USER &#x27;hive&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;hive&#x27;;#授权，将所有数据库的所有表的所有权限赋给hive用户，后面的hive是配置hive-site.xml中配置的连接密码GRANT ALL PRIVILEGES ON *.* TO &#x27;hive&#x27;@&#x27;localhost&#x27;;#刷新mysql系统权限关系表FLUSH PRIVILEGES;



下载MySQL JDBC驱动程序
https://mvnrepository.com/artifact/com.mysql/mysql-connector-j/8.4.0
把jar包放进lib里面
cp mysql-connector-j-8.4.0.jar /home/hadoop/hive/lib

初始化元数据存储的数据库模式
cd /home/hadoop/hive ./bin/schematool -initSchema -dbType mysql #此时mysql数据库中应该有表了

启动Hive启动hive之前，先启动hadoop集群。
start-all.sh #启动Hadoophive --service hiveserver2hive --service metastorehive  #启动Hive

]]></content>
  </entry>
  <entry>
    <title>java常用util工具类</title>
    <url>/2022/04/26/java%E5%B8%B8%E7%94%A8util%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[时间package com.lcdzzz.utils;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;public class TimeUtils &#123;    //获取当前年份    public static int getCurrentYear() &#123;        return Calendar.getInstance().get(Calendar.YEAR);    &#125;    //获取当前月份    public static int getCurrentMonth() &#123;        return Calendar.getInstance().get(Calendar.MONTH) + 1;    &#125;    //获取年月日    public static String getYMD() &#123;        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);        String dateNowStr = sdf.format(new Date());        System.out.println(&quot;格式化后的日期：&quot; + dateNowStr);        return dateNowStr;    &#125;    /*     * 获取当月第一天的时间     * */    public static Date getFisrtDayOfMonth(int year, int month) &#123;        Calendar cal = Calendar.getInstance();        //设置年份        cal.set(Calendar.YEAR, year);        //设置月份        cal.set(Calendar.MONTH, month - 1);        //获取某月最小天数        int firstDay = cal.getActualMinimum(Calendar.DAY_OF_MONTH);        //设置日历中月份的最小天数        cal.set(Calendar.DAY_OF_MONTH, firstDay);        //格式化日期//        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);//        String firstDayOfMonth = sdf.format(cal.getTime());        return cal.getTime();    &#125;    /*     * 获取当月最后一天的时间     * */    public static Date getLastDayOfMonth(int year, int month) &#123;        Calendar cal = Calendar.getInstance();        //设置年份        cal.set(Calendar.YEAR, year);        //设置月份        cal.set(Calendar.MONTH, month - 1);        //获取某月最大天数        int lastDay = cal.getActualMaximum(Calendar.DAY_OF_MONTH);        //设置日历中月份的最大天数        cal.set(Calendar.DAY_OF_MONTH, lastDay);        //格式化日期//        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);//        String lastDayOfMonth = sdf.format(cal.getTime());        return cal.getTime();    &#125;    /*     * date转string     * */    public static String dateToString(Date value) &#123;        Date sqlDate = new java.sql.Date(value.getTime());        SimpleDateFormat formatter = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);        return formatter.format(sqlDate);    &#125;&#125;


ip工具类import javax.servlet.http.HttpServletRequest;import java.net.InetAddress;import java.net.UnknownHostException;public class IpUtils &#123;    /**     * 获取客户端真实 IP 地址     *     * @param request HttpServletRequest 对象     * @return 客户端 IP 地址     */    public static String getClientIp(HttpServletRequest request) &#123;        String ipAddress = request.getHeader(&quot;X-Forwarded-For&quot;);        if (ipAddress == null || ipAddress.isEmpty() || &quot;unknown&quot;.equalsIgnoreCase(ipAddress)) &#123;            ipAddress = request.getHeader(&quot;Proxy-Client-IP&quot;);        &#125;        if (ipAddress == null || ipAddress.isEmpty() || &quot;unknown&quot;.equalsIgnoreCase(ipAddress)) &#123;            ipAddress = request.getHeader(&quot;WL-Proxy-Client-IP&quot;);        &#125;        if (ipAddress == null || ipAddress.isEmpty() || &quot;unknown&quot;.equalsIgnoreCase(ipAddress)) &#123;            ipAddress = request.getRemoteAddr();        &#125;        // 多个代理服务器的情况，取第一个非unknown的IP地址        String[] ipArray = ipAddress.split(&quot;,&quot;);        for (String ip : ipArray) &#123;            if (!&quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;                ipAddress = ip.trim();                break;            &#125;        &#125;        return ipAddress;    &#125;    /**     * 判断是否为内部 IP 地址     *     * @param ipAddress IP 地址字符串     * @return 是否为内部 IP 地址     */    public static boolean isInternalIp(String ipAddress) &#123;        if (ipAddress == null || ipAddress.isEmpty()) &#123;            return false;        &#125;        try &#123;            InetAddress inetAddress = InetAddress.getByName(ipAddress);            byte[] addressBytes = inetAddress.getAddress();            // 10.0.0.0/8            if (addressBytes[0] == 10) &#123;                return true;            &#125;            // 172.16.0.0/12            if (addressBytes[0] == 172 &amp;&amp; (addressBytes[1] &gt;= 16 &amp;&amp; addressBytes[1] &lt;= 31)) &#123;                return true;            &#125;            // 192.168.0.0/16            if (addressBytes[0] == 192 &amp;&amp; addressBytes[1] == 168) &#123;                return true;            &#125;        &#125; catch (UnknownHostException e) &#123;            // 处理异常        &#125;        return false;    &#125;    /**     * 验证 IP 地址格式是否正确     *     * @param ipAddress IP 地址字符串     * @return 是否为有效的 IP 地址     */    public static boolean isValidIpAddress(String ipAddress) &#123;        try &#123;            InetAddress.getByName(ipAddress);            return true;        &#125; catch (UnknownHostException e) &#123;            return false;        &#125;    &#125;    // 可以添加更多的方法，例如获取本机 IP 地址、计算 IP 地址之间的距离等&#125;

]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>java工具类</tag>
        <tag>时间工具</tag>
        <tag>ip工具类</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo部分命令</title>
    <url>/2021/07/04/hexo%E9%83%A8%E5%88%86%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[hexo clean&amp;&amp; hexo g &amp;&amp; hexo d
hexo clean#清理各种缓存和旧文件
hexo g#生成静态文件
hexo s#开启服务器预览
hexo new &quot;postName&quot; #新建文章
hexo new page &quot;pageName&quot; #新建页面
hexo generate #生成静态页面至public目录
hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）
hexo deploy #将.deploy目录部署到GitHub
hexo help  # 查看帮助
hexo version  #查看Hexo的版本
hexo deploy -g  #生成加部署
hexo server -g  #生成加预览
命令的简写
hexo n &#x3D;&#x3D; hexo new 
hexo g &#x3D;&#x3D; hexo generate  #生成文件
hexo s &#x3D;&#x3D; hexo server #运行本地服务器
hexo d &#x3D;&#x3D; hexo deploy #上传到服务器
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>java语法随记</title>
    <url>/2021/07/04/java%E8%AF%AD%E6%B3%95%E9%9A%8F%E8%AE%B0/</url>
    <content><![CDATA[java.math.BigDecimal的用法
BigDecimal类型用来存储金额等有小数，需要精度的数据

BigDecimal不能直接使用int类型赋值！

两种使BigDecimal初始化为0的方法:BigDecimal a&#x3D;BigDecimalBigDecimal b&#x3D;new BigDecimal(0);BigDecimal a &#x3D; in.nextBigDecimal();

除法运算：

​      System.out.println(new BigDecimal(153.5).divide(new BigDecimal(100), 2, BigDecimal.ROUND_HALF_UP));
　  &#x2F;&#x2F;new BigDecimal(100)除数，2精确的位数，BigDecimal.ROUND_HALF_UP：舍入模式

加法运算：
System.out.println(new BigDecimal(&quot;2.005&quot;).add(new BigDecimal(&quot;0.03&quot;)));

减法运算：
System.out.println(new BigDecimal(&quot;2.00&quot;).subtract(new BigDecimal(&quot;1.10&quot;)));

乘法运算：
System.out.println(new BigDecimal(&quot;2.05&quot;).multiply(new BigDecimal(&quot;10&quot;)));





char [] SS &#x3D; s.toCharArray();
char [] SS = s.toCharArray();
&#x2F;&#x2F;把字符串中的每个字符放进ss的字符数组里



s.contains(“4”)||s.contains(“62”)
(s.contains(&quot;4&quot;)||s.contains(&quot;62&quot;)

  &#x2F;&#x2F;判断s字符串里有没有包含”4”或”62”

java自定义函数调用一：主类中的自定义函数在主类中，如果想要在main函数中调用自定义的其他方法，则这个函数需要使用static关键字定义，否则会报错Cannot make a static reference to the non-static method xx from the type xx，调用的时候直接用函数名就可以了，如下：
 public class create_function &#123;    public static void main(String []args)&#123;　　int s = jia(5,4);          System.out.println(s);      &#125;      static int jia(int a, int b)&#123;          System.out.println(&quot;我是自定义相加函数，我被调用了！！&quot;);          return a+b;      &#125;               &#125;     

下面使用static关键字定义了一个“+”运算的函数，在main中调用时，直接使用函数名，括号中加参数就可以了。输出结果如下：
​        我是自定义相加函数，我被调用了！！​        9

二：自定义类中函数的调用自定义类中函数的调用有两种情况，静态函数和非静态函数，非静态函数的调用需要先声明一个类实例，通过实例调用。静态函数的调用可以通过实例，也可以直接使用类名调用(建议使用这种，要不会造成内存空间的浪费。)，如下：
public class create_function &#123;    public static void main(String []args)&#123;           Y y =new Y();                        int s2 = y.cheng(3,5);//声明了y这个实例        System.out.println(s2);//直接用Y这个类调用                int s3 = Y.chu(8, 2);        System.out.println(s3);    &#125; &#125;class Y&#123;    int cheng(int a,int b)&#123;        System.out.println(&quot;我是自定义类中的乘方法，我被调用了！&quot;);        return a*b;    &#125;    static int chu(int c,int d)&#123;       System.out.println(&quot;我是自定义类中的除方法，我被调用了！&quot;);        return c/d;    &#125;&#125;



在下面，自定义了一个Y类，cheng方法是非静态方法，必须通过实例y调用，chu方法是静态方法，使用类名直接调用。输出结果如下：
​		我是自定义类中的乘方法，我被调用了！​		15​		我是自定义类中的除方法，我被调用了！​		4

String.valueOf()方法的使用一：由基本数据形态转换成StringString 类别中已经提供了将基本数据型态转换成 String 的 static 方法 ，也就是 String.valueOf() 这个参数多载的方法 ：
（1）String.valueOf(boolean b) : 将 boolean 变量 b 转换成字符串（2）String.valueOf(char c) : 将 char 变量 c 转换成字符串（3）String.valueOf(char[] data) : 将 char 数组 data 转换成字符串（4）String.valueOf(char[] data, int offset, int count) : 将 char 数组 data 中 由 data[offset] 开始取 count 个元素 转换成字符串 
（5）String.valueOf(double d) : 将 double 变量 d 转换成字符串（6）String.valueOf(float f) : 将 float 变量 f 转换成字符串（7）String.valueOf(int i) : 将 int 变量 i 转换成字符串（8）String.valueOf(long l) : 将 long 变量 l 转换成字符串（9）String.valueOf(Object obj) : 将 obj 对象转换成 字符串, 等于 obj.toString() 
　　用法如下:　　int i = 10;　　String str = String.valueOf(i);　　这时候 str 就会是 “10” 

二、 由 String 转换成 数字的基本数据型态要将 String 转换成基本数据型 ，大多需要使用基本数据型态的包装类别 
（1） Byte.parseByte(String s) : 将 s 转换成 byte 
（2）Byte.parseByte(String s, int radix) : 以 radix 为基底（进制基数） 将 s 转换为 byte ，比如说 Byte.parseByte(“11”, 16) 会得到 17。
（3） Double.parseDouble(String s) : 将 s 转换成 double 
（4） Double.parseFloat(String s) : 将 s 转换成 float 
（5） Integer.parseInt(String s) : 将 s 转换成 int 
（6） Long.parseLong(String s) : 将 s 转换成 long
终止程序的执行，退出JVM
system.exit(0);


强行转换类型（强制类型转换&#x2F;向下转型）调用子类中特有的方法是，需要向下转型
if(c instanceof D)&#123;//c指向的对象如果确实是一个D类型的     D d1=(D)c;    d1.doOther();//doOther是D类特有的方法   &#125;


局部变量和成员变量局部变量是没有初始值的
成员变量有初始值（0  0.0  null）

next部分相关用法
nextInt()它只读取int值，nextInt()在读取输入后将光标放在同一行。

next()只读取输入直到空格。它无法阅读两个被空格隔开的单词。
同样，next()在读取输入后将光标放在同一行中。

nextLine()读取包括单词之间的空格在内的输入(也就是说，读取到行n的末尾)。读取输入后，nextLine()将光标定位到下一行。



java中，按数组下标来输出内容System.out.println(line.substring(6,11));意思是：输出line字符串中下标6到11的字符

怎么把一个变量塞到一个字符串当中口诀：加一个引号，双引号中间加两个加号，两个加号之间加变量名
例如:
return &quot; [ &quot;+no+&quot;,单人间，空闲] &quot;；


三目运算符status ? &quot;空闲&quot; : &quot;占用&quot;;/**如果status是true，那么输出空闲，否则就输出占用*/


println(引用)，会自动调用引用toString()方法
arrays工具(排序和二分法查找)public static void main (String [] args)&#123;    int [] arr=&#123;1,3,434,3,232,45,67,5,3&#125;Arrays.sort(arr);//排序int index = Arrays.binarySearch(arr,3);//3是所要查询的数据，arr是查询的对象（数组）System.out.println(index==-1 ? &quot;该元素不存在&quot; : &quot;该元素下标是：&quot; +index);&#125;



类和接口的强制类型转换类在强制类型转换过程中，如果是类转换成接口类型。那么类和接口之间不需要存在继承关系，也可以转换	
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>hexo 博客安装教程 胎教级</title>
    <url>/2022/11/05/hexo-%E5%8D%9A%E5%AE%A2%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B-%E8%83%8E%E6%95%99%E7%BA%A7/</url>
    <content><![CDATA[环境准备安装git到 GitHub 的页面上下载 exe 安装文件并运行：
安装包下载地址
详细可看：(6条消息) Git 详细安装教程（详解 Git 安装过程的每一个步骤）_mukes的博客-CSDN博客_git安装

  .fkjtsmtdqsmk{width:70%}


安装Nodejs下载链接：下载 | Node.js 中文网 (nodejs.cn)

  .rzxthotcuhjm{width:70%}


详细可看：Node.js 安装配置 | 菜鸟教程 (runoob.com)
最后通过cmd 输入node --version 检测是否安装完成，只要有输出就行，不管版本号是多少

  .ydftthpvluyt{width:70%}


查看是否安装成功：
在桌面鼠标右键点击git bash here或者打开电脑CMD，依次输入以下指令
node -v	#查看node版本npm -v	#查看npm版本


  .dwexoyokcmqv{width:70%}


显示如上即成功
安装淘宝的cnpm 管理器npm install -g cnpm --registry=http://registry.npm.taobao.org

由于国内的镜像源速度较慢，所以我们利用 npm 来安装 cnpm ，在命令行中输入npm install -g cnpm --registry=https://registry.npm.taobao.org然后回车（Enter），稍等一会便下载好了
查看cnpm版本
cnpm -v


  .tglwbcjiwkbv{width:70%}


部署hexo框架cnpm install -g hexo-cli #部署hexo框架hexo -v	#查看hexo版本


  .srswvwmahpec{width:70%}


连接 Github注册使用邮箱注册 GitHub 账户，选择免费账户（Free），并完成邮件验证。
右键 -&gt; Git Bash Here，设置用户名和邮箱：
git config --global user.name &quot;GitHub 用户名&quot;git config --global user.email &quot;GitHub 邮箱&quot;

创建 SSH 密匙：输入 ssh-keygen -t rsa -C &quot;GitHub 邮箱&quot;，然后一路回车。
添加密匙：进入 [C:\Users\用户名.ssh] 目录（要勾选显示“隐藏的项目”），用记事本打开公钥 id_rsa.pub 文件并复制里面的内容。
登陆 GitHub ，进入 Settings 页面，选择左边栏的 SSH and GPG keys，点击 New SSH key。
Title 随便取个名字，粘贴复制的 id_rsa.pub 内容到 Key 中，点击 Add SSH key 完成添加。

  .xlfvrojvvnsy{width:70%}


验证连接：打开 Git Bash，输入 ssh -T git@github.com 出现 “Are you sure……”，输入 yes 回车确认。

  .ynxyfxjqdrxg{width:70%}


创建仓库创建一个和用户名相同的仓库，后面加上.github.io，必须要同名，否则后面会出现404的情况

  .qpgzypebrjft{width:70%}



  .fghiaxummuah{width:70%}


创建后默认自动启用 HTTPS，博客地址为：https://用户名.github.io
本地安装 Hexo 博客程序新建一个文件夹用来存放 Hexo 的程序文件，如 Hexo-Blog。打开该文件夹，右键 -&gt; Git Bash Here。
安装 Hexo使用 npm 一键安装 Hexo 博客程序：
npm install -g hexo-cli

安装时间有点久（真的很慢！），界面也没任何反应，耐心等待
Hexo 初始化和本地预览初始化并安装所需组件：
hexo init      # 初始化npm install    # 安装组件

完成后依次输入下面命令，启动本地服务器进行预览：
hexo g   # 生成页面hexo s   # 启动预览

访问 http://localhost:4000，出现 Hexo 默认页面，本地博客安装成功！
**Tips：**如果出现页面加载不出来，可能是端口被占用了。Ctrl+C 关闭服务器，运行 hexo server -p 5000 更改端口号后重试。
Hexo 博客文件夹目录结构如下：

  .gbeukbhqkmpz{width:70%}




部署 Hexo 到 GitHub Pages本地博客测试成功后，就是上传到 GitHub 进行部署，使其能够在网络上访问。
首先安装 hexo-deployer-git：
npm install hexo-deployer-git --save

然后修改 _config.yml 文件末尾的 Deployment 部分，修改成如下：
deploy:  type: git  repository: git@github.com:用户名/用户名.github.io.git  branch: master

完成后运行 hexo d 将网站上传部署到 GitHub Pages。

  .mnojxoqqxzgr{width:70%}


不过需要等一会，上传需要时间
过了一会再可以访问我们的 GitHub 域名 https://用户名.github.io 就可以看到 Hexo 网站了。

  .ruvcghxowybe{width:70%}




开始使用发布文章进入博客所在目录
右键打开 Git Bash Here，创建博文：
hexo new &quot;My New Post&quot;

然后 source 文件夹中的_posts文件夹会出现一个 My-New-Post.md 文件，就可以使用 Markdown 编辑器在该文件中撰写文章了。
也可以不使用命令,而自己去创建 .md 文件，只需在文件开头手动加入如下格式 Front-matter 即可，写完后运行 hexo g 和 hexo d 发布。
---title: Hello World # 标题date: 2019/3/26 hh:mm:ss # 时间categories: # 分类- Diarytags: # 标签- PS3- Games---摘要&lt;!--more--&gt;正文



写完后运行下面代码将文章渲染并部署到 GitHub Pages 上完成发布。
hexo g   # 生成页面hexo s   # 启动本地服务器，用于预览主题。默认地址： http://localhost:4000/hexo d   # 自动生成网站静态文件，并部署到设定的仓库。


  .vpgzesxvgmnr{width:70%}



  .kcjcsqqgikcl{width:70%}


也可以直接在浏览器上输入地址：localhost:4000 。 ctrl+c 是退出

  .sgsepeguonlw{width:70%}


这时候再等一会（时间有长有短，基本上不会出问题，如果出了问题继续百度），然后访问用户名.github.io就可以访问自己的博客了
以下还有些hexo的常用命令
hexo new &quot;name&quot;       # 新建文章hexo new page &quot;name&quot;  # 新建页面hexo g                # 生成页面hexo d                # 部署hexo g -d             # 生成页面并部署hexo s                # 本地预览hexo clean            # 清除缓存和已生成的静态文件hexo help             # 帮助

网站设置包括网站名称、描述、作者、链接样式等，全部在网站目录下的 _config.yml 文件中，参考官方文档按需要编辑。
注意：冒号后要加一个空格！
更换主题可以在 Themes | Hexo 选择一个喜欢的主题，或者其他地方，各种各样的主题网上应有尽有，至于怎么安装，就自己去百度吧（有些坑亲自去踩了才有意思 &#x2F;doge）
后续问题hexo d失败Please make sure you have the correct access rightsand the repository exists.FATAL &#123;  err: Error: Spawn failed      at ChildProcess.&lt;anonymous&gt; (D:\work_space\blog\hexo\node_modules\.store\hexo-util@2.7.0\node_modules\hexo-util\lib\spawn.js:51:21)      at ChildProcess.emit (node:events:518:28)      at cp.emit (D:\work_space\blog\hexo\node_modules\.store\cross-spawn@7.0.6\node_modules\cross-spawn\lib\enoent.js:34:29)      at ChildProcess._handle.onexit (node:internal/child_process:293:12) &#123;    code: 128  &#125;&#125; #提示检查访问权限和仓库是否存在


确保_config.yml设置的仓库地址是正确的

检查github或者gitee的SSH 密钥的配置、仓库的权限设置

确保你的系统上安装了所有必要的依赖项，比如 Node.js 和 npm（或 yarn或cnpm）。此外，检查你的 Hexo 版本是否与其他依赖项兼容。

（可选）尝试运行 Hexo 命令时加上 --debug 标志，这可能会提供更多关于错误的详细信息

检查用户名和邮箱：git config user.name和git config user.email
$ ssh -T git@github.com# 主机认证The authenticity of host &#x27;github.com (20.205.243.166)&#x27; can&#x27;t be established. # SSH 服务器（在这种情况下是 GitHub）提供了一个公钥指纹，用于验证其身份ED25519 key fingerprint is SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU.# SSH 服务器（在这种情况下是 GitHub）提供了一个公钥指纹，用于验证其身份This key is not known by any other names# SSH 客户端将服务器的公钥指纹添加到 ~/.ssh/known_hosts 文件中，这样在未来的连接尝试中，它就可以自动验证服务器的身份而不需要再次询问。	Are you sure you want to continue connecting (yes/no/[fingerprint])? yesWarning: Permanently added &#x27;github.com&#x27; (ED25519) to the list of known hosts.# 最后，GitHub 确认了你的身份（通过 SSH 密钥），但告诉你它没有提供 shell 访问权限。# 这是正常的，因为 GitHub（和大多数代码托管平台）不允许通过 SSH 直接获得 shell 访问权限。它们只允许使用 SSH 进行 Git 操作，如克隆、拉取、推送等。Hi lcdzzz! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.

以上，基本可以解决hexo d失效的问题（如长时间没有更新博客或者换了电脑）
上传图片
更新时间：20250731

网上有很多上传并显示图片的方法，我试过很多中，以下：

一种是npm install hexo-asset-image --save 安装插件，插件会将Markdown中的 ![](image.jpg) 自动转换为HTML可识别的绝对路径，但这种有个很大的缺点就是本地无法正确显示图片，这个当我们不想通过联网或者hexo s去查看笔记的时候是非常不方便的。

还有一种是图床，需要去配置图工具，再等图床生成图片URL后，直接写入Markdown。


![](https://img.example.com/path/to/image.jpg)



但是以上都是需要安装插件或者工具的，全部使用过后，我选择最简单，兼容性最强的方法：使用HTML标签（若插件或路径转换失败）
&lt;div style=&quot;text-align:center&quot;&gt;  &lt;img src=&quot;/images/image.jpg&quot; alt=&quot;描述&quot; width=&quot;80%&quot;&gt;&lt;/div&gt;



案例以前我引用图片是使用第一种方法，如下
{% asset_img "span>" "image-20221105123810384" %}

存在和文章同名的文件夹下。假如我这篇叫hexo-博客安装教程-胎教级.md,那么就有一个文件夹名为hexo-博客安装教程-胎教级存着名为image-20221105123810384.png的图片。
那么就转换成这样的html格式（这里建议直接使用）
&lt;div style=&quot;text-align:center&quot;&gt;  &lt;style&gt;.fhzfecdvatew&#123;width:70%&#125;&lt;/style&gt;&#123;% asset_img fhzfecdvatew image-20221105123810384.png &#x27;&quot;&quot;&quot;image-20221105123810384&quot;&#x27; %&#125;&lt;/div&gt;



转换脚本由于在我转换成这个写法的时候我已经写了三四十篇的博客了，人为转换工程量极其庞大，于是有了下面这个脚本，复制并赋权即可食用。
windows用户不方便使用shell的话，可以看看这篇
windowsのwsl安装centos
#!/bin/bash# 检查参数是否提供if [ $# -eq 0 ]; then  echo &quot;Usage: $0 file1.md [file2.md ...]&quot;  echo &quot;示例: $0 GaussDB安装及应用.md AnotherDocument.md&quot;  exit 1fi# 处理每个文件for filepath in &quot;$@&quot;; do  # 检查文件是否存在  if [ ! -f &quot;$filepath&quot; ]; then    echo &quot;警告: 跳过不存在的文件 &#x27;$filepath&#x27;&quot;    continue  fi    # 提取文件名（不含扩展名）作为图片前缀  filename=$(basename -- &quot;$filepath&quot;)  prefix=&quot;$&#123;filename%.*&#125;&quot;    # 创建临时文件  tmpfile=$(mktemp)    # 处理文件内容  while IFS= read -r line; do    # 检测图片语法 ![..](..)    if [[ $line =~ \!\[([^\]]*)\]\(([^\)]+)\) ]]; then      alt_text=&quot;$&#123;BASH_REMATCH[1]&#125;&quot;      img_path=&quot;$&#123;BASH_REMATCH[2]&#125;&quot;            # 输出转换后的HTML（保留完整前缀）      echo &quot;&lt;div style=\&quot;text-align:center\&quot;&gt;&quot;      echo &quot;  &lt;img src=\&quot;$prefix/$img_path\&quot; alt=\&quot;$alt_text\&quot; style=\&quot;width:70%\&quot;&gt;&quot;      echo &quot;&lt;/div&gt;&quot;    else      # 非图片行保持不变      echo &quot;$line&quot;    fi  done &lt; &quot;$filepath&quot; &gt; &quot;$tmpfile&quot;    # 替换原文件  mv &quot;$tmpfile&quot; &quot;$filepath&quot;  echo &quot;已处理: $filepath → 使用前缀: $prefix&quot;doneecho &quot;转换完成! 共处理 $# 个文件&quot;



使用方法
./convert_images.sh test.md ./convert_images.sh *.md







]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>pictures</title>
    <url>/2022/05/11/pictures/</url>
    <content><![CDATA[
  .xavrrdulyxix{width:70%}



  .zzurwgqdkmhj{width:70%}


]]></content>
  </entry>
  <entry>
    <title>leetcoce随记</title>
    <url>/2024/01/02/leetcoce%E9%9A%8F%E8%AE%B0/</url>
    <content><![CDATA[
1import java.util.HashMap;class Solution &#123;    public static void main(String[] args) &#123;        Solution solution = new Solution();        int[] fnums = &#123;3, 2, 4&#125;;        int[] result = solution.twoSum(fnums, 6);        for (int i = 0; i &lt; result.length; i++) &#123;            System.out.println(result[i]);        &#125;    &#125;    public int[] twoSum(int[] nums, int target) &#123;        int diff=0;        HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();        for (int i = 0; i &lt; nums.length; i++) &#123;            hashMap.put(nums[i],i);        &#125;        for (int i = 0; i &lt; nums.length; i++) &#123;            diff=target-nums[i];            if (hashMap.containsKey(diff)&amp;&amp;hashMap.get(diff)!=i)&#123;                int[] ints = new int[2];                ints[0]=i;                ints[1]=hashMap.get(diff);                return ints;            &#125;        &#125;        return new int[0];        &#125;


2迭代法public class ListNode &#123;    int val;    ListNode next;    ListNode() &#123;    &#125;    ListNode(int val) &#123;        this.val = val;    &#125;    ListNode(int val, ListNode next) &#123;        this.val = val;        this.next = next;    &#125;&#125;class Solution &#123;    public static void main(String[] args) &#123;        Solution solution = new Solution();        ListNode l1 = new ListNode(                2, new ListNode(                4, new ListNode(                3, null)));        ListNode l2 = new ListNode(                5, new ListNode(                6, new ListNode(                4, null)));        ListNode listNode = solution.addTwoNumbers(l1, l2);        while (listNode!=null)&#123;            System.out.print(listNode.val+&quot; &quot;);            listNode=listNode.next;        &#125;    &#125;    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;        int cf = 0;//进位标志        int total=0;        ListNode result = new ListNode();//结果的头指针        ListNode tempNode=result;        while (l1 != null &amp;&amp; l2 != null) &#123;            total=l1.val + l2.val + cf;            tempNode.next=new ListNode((total) % 10);//当位数            cf = (total) / 10;//进位            l1=l1.next;            l2=l2.next;            tempNode=tempNode.next;        &#125;        while (l1 != null ) &#123;            total=l1.val + cf;            tempNode.next=new ListNode((total) % 10);//当位数            cf = (total) / 10;//进位            l1=l1.next;            tempNode=tempNode.next;        &#125;        while (l2 != null ) &#123;            total=l2.val + cf;            tempNode.next=new ListNode((total) % 10);//当位数            cf = (total) / 10;//进位            l2=l2.next;            tempNode=tempNode.next;        &#125;        if (cf!=0)&#123;            tempNode.next=new ListNode(cf);//当位数        &#125;        return result.next;    &#125;&#125;



递归法public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;    int total;    int cf;    ListNode res = new ListNode();    total = l1.val + l2.val;    cf = total / 10;    res = new ListNode(total % 10);    if (l1.next != null || l2.next != null || cf != 0) &#123;        if (l1.next != null) &#123;            l1 = l1.next;        &#125; else &#123;            l1 = new ListNode(0);        &#125;        if (l2.next != null) &#123;            l2 = l2.next;        &#125; else &#123;            l2 = new ListNode(0);        &#125;        l1.val = l1.val + cf;//因为对于下一层递归来说，这里的cf是透明的，所以在进入递归之前需要先加进位        res.next = addTwoNumbers(l1, l2);    &#125;    return res;&#125;


20自己


执行用时分布
消耗内存分布



2ms
40.23MB


击败51.55%使用 Java 的用户
击败13.63%使用 Java 的用户


import java.util.Stack;class Solution &#123;    char l1=&#x27;(&#x27;;    char r1=&#x27;)&#x27;;    char l2=&#x27;[&#x27;;    char r2=&#x27;]&#x27;;    char l3=&#x27;&#123;&#x27;;    char r3=&#x27;&#125;&#x27;;    public boolean isValid(String s) &#123;        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();        boolean flag=true;        char[] charcuray = s.toCharcuray();        char temp;        char tempBracket;        int ll=0;        int rr=0;        int num=0;        for (int i=0;i&lt;charcuray.length;i++)&#123;            temp=charcuray[i];            if (temp==l1||temp==l2||temp==l3)&#123;                stack.add(temp);                ll++;                num++;            &#125;            if ((temp==&#x27;)&#x27;||temp==&#x27;]&#x27;||temp==&#x27;&#125;&#x27;)&amp;&amp;stack.isEmpty())&#123;                flag=false;                return flag;            &#125;            if (!stack.isEmpty())&#123;                if (temp==r1||temp==r2||temp==r3)&#123;                    tempBracket=stack.pop();                    rr++;                    if (temp==&#x27;]&#x27;)&#123;                        if (tempBracket!=&#x27;[&#x27;)&#123;                            flag=false;                            return flag;                        &#125;else &#123;                            num--;                        &#125;                    &#125;                    else if (temp==&#x27;)&#x27;)&#123;                        if (tempBracket!=&#x27;(&#x27;)&#123;                            flag=false;                            return flag;                        &#125;else &#123;                            num--;                        &#125;                    &#125;                    else if (temp==&#x27;&#125;&#x27;)&#123;                        if (tempBracket!=&#x27;&#123;&#x27;)&#123;                            flag=false;                            return flag;                        &#125;else &#123;                            num--;                        &#125;                    &#125;                &#125;            &#125;        &#125;        if (ll-rr!=0||num!=0)&#123;            flag=false;            return flag;        &#125;        return flag;    &#125;    public static void main(String[] args) &#123;        String s = &quot;()&quot;;        Solution solution = new Solution();        System.out.println(solution.isValid(s));    &#125;&#125;

被优化


执行用时分布
消耗内存分布



1ms
40.45MB


击败98.64%使用 Java 的用户
击败9.24%使用 Java 的用户


public boolean isValid(String s) &#123;    if (s.length() == 0) &#123;        return true;    &#125;    Stack&lt;Character&gt; stack = new Stack&lt;&gt;();    for (char ch : s.toCharcuray()) &#123;        if (ch == &#x27;(&#x27; || ch == &#x27;[&#x27; || ch == &#x27;&#123;&#x27;) &#123;            stack.push(ch);        &#125; else &#123;            if (stack.isEmpty()) &#123;                return false;            &#125; else &#123;                char temp = stack.pop();                if (ch == &#x27;)&#x27;) &#123;                    if (temp != &#x27;(&#x27;) &#123;                        return false;                    &#125;                &#125; else if (ch == &#x27;]&#x27;) &#123;                    if (temp != &#x27;[&#x27;) &#123;                        return false;                    &#125;                &#125; else if (ch == &#x27;&#125;&#x27;) &#123;                    if (temp != &#x27;&#123;&#x27;) &#123;                        return false;                    &#125;                &#125;            &#125;        &#125;    &#125;    return stack.isEmpty()? true:false;&#125;//抄的




21public class ListNode &#123;    int val;    ListNode next;    ListNode() &#123;    &#125;    ListNode(int val) &#123;        this.val = val;    &#125;    ListNode(int val, ListNode next) &#123;        this.val = val;        this.next = next;    &#125;&#125;class Solution &#123;    public static void main(String[] args) &#123;        Solution solution = new Solution();        // 示例链表1: 1 -&gt; 3 -&gt; 5        ListNode list1 = new ListNode(1);        list1.next = new ListNode(3);        list1.next.next = new ListNode(5);        // 示例链表2: 2 -&gt; 4 -&gt; 6        ListNode list2 = new ListNode(2);        list2.next = new ListNode(4);        list2.next.next = new ListNode(6);        ListNode result = solution.mergeTwoLists(list1, list2);    &#125;    public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123;        // 创建一个哑节点作为合并后的链表的头节点        ListNode dummy = new ListNode(0);        ListNode current = dummy;        while (list1!=null&amp;&amp;list2!=null)&#123;            if (list1.val&lt;list2.val)&#123;                current.next=list1;                list1=list1.next;            &#125;else &#123;                current.next=list2;                list2=list2.next;            &#125;            current=current.next;        &#125;        if (list1!=null)&#123;            current.next=list1;        &#125;else if (list2!=null)&#123;            current.next=list2;        &#125;        return dummy.next;    &#125;&#125;


22括号生成（回溯）回溯法import java.util.curayList;import java.util.List;class Solution &#123;    public static void main(String[] args) &#123;        Solution solution = new Solution();        List&lt;String&gt; strings = solution.generateParenthesis(2);    &#125;    public List&lt;String&gt; generateParenthesis(int n) &#123;        List&lt;String&gt; result = new curayList&lt;&gt;();        backtracking(n,result,0,0,&quot;&quot;);        return result;    &#125;    void backtracking(int n,List&lt;String&gt; result,int left,int right,String str)&#123;        if (right&gt;left)&#123;            return;        &#125;        if (left==right&amp;&amp;right==n)&#123;            result.add(str);            return;        &#125;        if (left&lt;n)&#123;            backtracking(n,result,left+1,right,str+&quot;(&quot;);        &#125;        if (right&lt;n)&#123;            backtracking(n,result,left,right+1,str+&quot;)&quot;);        &#125;    &#125;&#125;




24两两交换链表中的节点(链表交换)迭代法iteration
  .olcirgclinog{width:70%}



把res-&gt;1的指针断了，让cur指向2                                           cur.next=next

把 2-&gt;3的指针断了，并 让next（原本指向2的指针）指向1 next.next=head

把head.next的指针断了，让它指向temp                              head.next=temp

此时链表为  res-&gt;2-&gt;1-&gt;3-&gt;4

接下来同理。



  .hmhwvtzurwgv{width:70%}



↑↑ 
 cur&#x3D;head; 
 head&#x3D;head.next

然后 重复123步，得到链表res-&gt;2-&gt;1-&gt;4-&gt;3


class Solution &#123;    /*    *           res   -&gt;  1   -&gt;   2  -&gt;  3   -&gt;4    *           cur      head    next    temp    *    * */    public ListNode swapPairs(ListNode head) &#123;        if (head==null||head.next==null)&#123;            return head;        &#125;        ListNode res=new ListNode(0);        res.next=head;//使res把链表串起来：res-&gt;1-&gt;2-&gt;3-&gt;4        ListNode cur=res;//辅助指针        while (cur.next!=null&amp;&amp;cur.next.next!=null)&#123;            ListNode next=head.next;       //定义指针            ListNode temp=head.next.next;  //定义指针            cur.next=next;   //两两            next.next=head;  //交            head.next=temp;  //换            cur=head;//虽然叫head，但是它指向的是1，此时1已经是第二个节点了（不算res）            head=head.next;//把head指向3,下个循环解决的就是3-&gt;4的交换        &#125;        return res.next;//返回的是res，因为cur已经滚到后面去了    &#125;&#125;

注：真实链表一直是以res起头的，即res-&gt;1-&gt;2-&gt;3-&gt;4&#x3D;&#x3D;&gt;res-&gt;2-&gt;1-&gt;3-&gt;4&#x3D;&#x3D;&gt;res-&gt;2-&gt;1-&gt;4-&gt;3。所以返回的是res.next而不是cur.next
递归法recursion
  .vgrkrhicdleb{width:70%}



把1-&gt;2的指针切断，让1的next指向head.next.next。所以head.next就是递归自己即swapPairs(head.next.next);
   ListNode next=head.next;  (使得指针next对应2)head.next=swapPairs(head.next.next);

注意，此时的next指针的next应该不指向3了（2-&gt;3的关联别切断了），并且应该指向1，即next.next=head


(具体请看图，如果看不懂就再画一次)。周某，我知道你第二次或许还是看不懂，所以干脆再画一遍吧，第一次能画出来，那第二次一定可以的。

  .cnkioxugcvpq{width:70%}


class Solution &#123;    public ListNode swapPairs(ListNode head) &#123;        if (head==null||head.next==null)&#123;//递归终止条件            return head;        &#125;        ListNode next=head.next;        head.next=swapPairs(head.next.next);        next.next=head;        return next;    &#125;&#125;


49. 字母异位词分组排序法class Solution &#123;    public static void main(String[] args) &#123;        Solution solution = new Solution();        String[] strings = new String[6];        strings[0]=&quot;eat&quot;;        strings[1]=&quot;tea&quot;;        strings[2]=&quot;tan&quot;;        strings[3]=&quot;ate&quot;;        strings[4]=&quot;nat&quot;;        strings[5]=&quot;bat&quot;;        solution.groupAnagrams(strings);    &#125;    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;        HashMap&lt;String,ArrayList&gt; result=new HashMap&lt;&gt;();        for (String s:strs)&#123;            char[] temp=s.toCharArray();            Arrays.sort(temp);            String key= Arrays.toString(temp);            if (!result.containsKey(key))&#123;                result.put(key,new ArrayList&lt;&gt;());            &#125;            result.get(key).add(s);        &#125;        return new ArrayList(result.values());    &#125;&#125;



哈希法public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;    HashMap&lt;String, ArrayList&gt; result = new HashMap&lt;&gt;();    for (String s : strs) &#123;        int[] count_table = new int[26];        for (char c : s.toCharArray()) &#123;            count_table[c - &#x27;a&#x27;]++;        &#125;        StringBuilder sb = new StringBuilder();        for (int count : count_table) &#123;            sb.append(&quot;#&quot;);            sb.append(count);        &#125;        String key = sb.toString();        if (!result.containsKey(key)) &#123;           result.put(key,new ArrayList&lt;&gt;());        &#125;        result.get(key).add(s);    &#125;    return new ArrayList(result.values());&#125;


46全排列（回溯）回溯法class Solution &#123;    public static void main(String[] args) &#123;        Solution solution = new Solution();    &#125;    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;        HashMap&lt;Integer, Boolean&gt; map = new HashMap&lt;&gt;();        ArrayList&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();        for (int num : nums) &#123;            map.put(num, false);        &#125;        backtracking(nums, result, map, list);        return result;    &#125;    void backtracking(int[] nums,List&lt;List&lt;Integer&gt;&gt; result,HashMap&lt;Integer, Boolean&gt; map,ArrayList&lt;Integer&gt; list )&#123;        if (nums.length==list.size())&#123;            result.add(List.copyOf(list));//防止引用传递        &#125;        for (int num : nums) &#123;            if (!map.get(num))&#123;                list.add(num);                map.put(num,true);                backtracking(nums, result, map, list);                list.remove(list.size()-1);                map.put(num,false);            &#125;        &#125;    &#125;&#125;


53最大子数组和（分治&amp;&amp;动规）分治法图示
  .xujwnukvrclm{width:70%}


代码class Solution &#123;    public static void main(String[] args) &#123;        Solution solution = new Solution();        System.out.println(solution.maxSubArray(new int[]&#123;5, 4, -1, 7, 8&#125;));    &#125;    public int maxSubArray(int[] nums) &#123;        return getMax(nums, 0, nums.length - 1);    &#125;    int getMax(int[] nums, int left, int right) &#123;        int mid = 0;        int leftMax = 0;        int rightMax = 0;        int crossMax = 0;        if (left == right) &#123;//分治法用了递归的思想，所以要有终止条件            return nums[left];//分治到只有它自身为止        &#125;        mid = left + (right - left) / 2;        leftMax = getMax(nums, left, mid);        rightMax = getMax(nums, mid + 1, right);        crossMax = getCrossMax(nums, left, right);        return Math.max(leftMax, Math.max(rightMax, crossMax));    &#125;    int getCrossMax(int[] nums, int left, int right) &#123;        int mid = 0;        int leftSum = 0;        int leftMax = 0;        int rightSum = 0;        int rightMax = 0;        mid = left + (right - left) / 2;        leftSum = nums[mid];        leftMax = nums[mid];        for (int i = mid - 1; i &gt;= left; i--) &#123;            leftSum = leftSum + nums[i];            leftMax = Math.max(leftMax, leftSum);        &#125;        rightSum = nums[mid + 1];        rightMax = rightSum;                for (int i = mid + 2; i &lt;= right; i++) &#123;            rightSum = rightSum + nums[i];            rightMax = Math.max(rightMax, rightSum);        &#125;        return leftMax + rightMax;    &#125;&#125;



动规法题解：https://leetcode.cn/problems/maximum-subarray/solutions/9058/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/
public int maxSubArray(int[] nums) &#123;    int[] dp = new int[nums.length];    dp[0]=nums[0];    int result=nums[0];    for (int i = 1; i &lt; nums.length; i++) &#123;        dp[i]=Math.max(dp[i-1]+nums[i],nums[i]);        result=Math.max(result, dp[i]);    &#125;    return result;&#125;




34. 在排序数组中查找元素的第一个和最后一个位置虽然自己做出了，但是分析的方法有问题。以后先要分析可能遇见的各种情况，然后在针对可能出现的情况进行编写。
以下是没有想到的方面：

按照三种情况：target 在数组范围的右边或者左边、target 在数组范围中，且数组中不存在target、target 在数组范围中，且数组中存在target。
分别编写找右边界和找左边界的函数。然后整合时在近一步验证

没有想到可以在一层循环中直接搞定元素第一次&#x2F;最后一次出现的位置。对二分法的变式没有很好的掌握。


]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>prometheus&amp;consul&amp;blackboxTest</title>
    <url>/2024/09/30/prometheus-consul-blackboxTest/</url>
    <content><![CDATA[
安装包地址：通过网盘分享的文件：链接: https://pan.baidu.com/s/1iBSiZ4baGzf8KWlhdnDv0w?pwd=9i1u 提取码: 9i1u 
代码地址见文章末尾
虚拟机关闭防火墙：
systemctl status firewalldsystemctl stop firewalldsystemctl disable firewalld

Prometheus启动脚本startup-prometheus
#!/bin/bashcd `dirname $0`  # 替换为 Prometheus 的实际路径BASE_DIR=`pwd`echo `pwd`# 定义 Prometheus 的路径PROMETHEUS_PATH=$BASE_DIR/prometheus  # 替换为 Prometheus 的实际路径PID_FILE=$BASE_DIR/prometheus.pid  # 存储进程 ID 的文件LOG_FILE=$BASE_DIR/logs/prometheus.log  # 日志文件CONFIG_FILE=$BASE_DIR/prometheus.yml  # Prometheus 配置文件路径DATA_DIR=$BASE_DIR/data  # Prometheus 数据目录# 检查是否已经在运行if [ -f &quot;$PID_FILE&quot; ] &amp;&amp; kill -0 $(cat &quot;$PID_FILE&quot;) 2&gt;/dev/null; then    echo &quot;Prometheus is already running.&quot;else    echo &quot;Starting Prometheus...&quot;    nohup $PROMETHEUS_PATH --config.file=$CONFIG_FILE --storage.tsdb.path=$DATA_DIR &gt; $LOG_FILE 2&gt;&amp;1 &amp;  # 后台运行    echo $! &gt; &quot;$PID_FILE&quot;  # 将进程 ID 写入文件    echo &quot;Prometheus started with PID $(cat &quot;$PID_FILE&quot;).&quot;fi

终止脚本shundown-prometheus
#!/bin/bashcd `dirname $0`  # 替换为 Prometheus 的实际路径BASE_DIR=`pwd`PID_FILE=$BASE_DIR/prometheus.pid  # 存储进程 ID 的文件# 检查 PID 文件是否存在if [ -f &quot;$PID_FILE&quot; ]; then    PID=$(cat &quot;$PID_FILE&quot;)    if kill -0 &quot;$PID&quot; 2&gt;/dev/null; then        echo &quot;Stopping Prometheus...&quot;        kill &quot;$PID&quot;        rm -f &quot;$PID_FILE&quot;  # 删除 PID 文件        echo &quot;Prometheus stopped.&quot;    else        echo &quot;Prometheus is not running.&quot;        rm -f &quot;$PID_FILE&quot;  # 删除 PID 文件    fielse    echo &quot;Prometheus is not running.&quot;fi

consul# 下载 Consulwget https://releases.hashicorp.com/consul/1.17.2/consul_1.17.2_linux_amd64.zip# 解压unzip consul_1.17.2_linux_amd64.zip# 移动到 /usr/local/bin 目录sudo mv consul /usr/local/bin/# 验证安装consul version# 启动 Consulconsul agent -dev#在云服务器上启动了consul，但是访问不了8500端口，这里需要在服务器启动的时候，加上-client的指定./consul agent -dev #这是最开始启动的命令 只能本机访问#当使用下面命令的时候就可以其他机器进行访问了：./consul agent -dev -client 0.0.0.0 -ui #外部机器就可以访问

待被发现的java程序的要求application.yml
management:  endpoints:    web:      exposure:        include: health,info,prometheus  metrics:    export:      prometheus:        enabled: truespring:  application:    name: prometheus-consul-app  # 服务名称  cloud:    consul:      discovery:        instance-id: $&#123;spring.application.name&#125;-$&#123;spring.cloud.client.ip-address&#125;-$&#123;server.port&#125;  # 使用IP和端口生成唯一ID        prefer-ip-address: true  # 强制使用IP地址注册到Consul        heartbeat:          enabled: true        service-name: $&#123;spring.application.name&#125;      host: 192.168.15.128      port: 8500server:  port: 8111#  address: 192.168.15.128 # 将这里的IP替换为你的机器实际的内网或外网IP地址

主程序
//@EnableDiscoveryClient 自springboot2.7x以后就不用了@EnableDiscoveryClient@SpringBootApplicationpublic class PrometheusMonitoringDemoApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(PrometheusMonitoringDemoApplication.class, args);    &#125;&#125;

pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.7.4&lt;/version&gt;        &lt;relativePath/&gt;     &lt;/parent&gt;    &lt;groupId&gt;org.example&lt;/groupId&gt;    &lt;artifactId&gt;prometheus-monitoring-demo&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;prometheus-monitoring-demo&lt;/name&gt;    &lt;description&gt;prometheus-monitoring-demo&lt;/description&gt;    &lt;properties&gt;         &lt;!-- springboot和springcloud有兼容要求、springboot和micrometer有兼容要求--&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;        &lt;micrometer.version&gt;1.9.5&lt;/micrometer.version&gt;        &lt;spring-boot.version&gt;2.7.4&lt;/spring-boot.version&gt;        &lt;spring-cloud.version&gt;2021.0.5&lt;/spring-cloud.version&gt;    &lt;/properties&gt;    &lt;dependencyManagement&gt;        &lt;dependencies&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;                &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;                &lt;type&gt;pom&lt;/type&gt;                &lt;scope&gt;import&lt;/scope&gt;            &lt;/dependency&gt;        &lt;/dependencies&gt;    &lt;/dependencyManagement&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;         &lt;!-- 为应用程序提供了暴露管理端点的功能，这些端点包括健康检查、性能监控和指标。--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;        &lt;/dependency&gt;         &lt;!-- 让应用程序通过 Micrometer 收集并格式化度量指标，以 Prometheus 可理解的方式暴露给 Prometheus。。--&gt;        &lt;dependency&gt;            &lt;groupId&gt;io.micrometer&lt;/groupId&gt;            &lt;artifactId&gt;micrometer-registry-prometheus&lt;/artifactId&gt;            &lt;version&gt;$&#123;micrometer.version&#125;&lt;/version&gt;        &lt;/dependency&gt;         &lt;!-- 让Spring Boot应用程序可以通过 Consul 服务发现机制来进行注册和发现服务。--&gt;         &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;

prometheus配置prometheus.yml
global:  scrape_interval: 5s  # 默认抓取间隔scrape_configs:  - job_name: &#x27;prometheus-consul-app&#x27;    consul_sd_configs:      - server: &#x27;192.168.15.128:8500&#x27;        services: [&#x27;prometheus-consul-app&#x27;]    metrics_path: &#x27;/actuator/prometheus&#x27;  # Spring Boot 默认的 Prometheus 指标路径



consul启动终止脚本startup-consul.sh
#!/bin/bash cd `dirname $0` # 替换为 consul 的实际路径BASE_DIR=`pwd`# 定义 Consul 的路径CONSUL_PATH=$BASE_DIR/consul  # 替换为 consul 的实际路径PID_FILE=$BASE_DIR/consul.pid  # 存储进程 ID 的文件LOG_FILE=$BASE_DIR/logs/consul.log  # 日志文件DATA_FILE=$BASE_DIR/dataCONFIG_FILE=$BASE_DIR/consul.hcl # 检查是否已经在运行if [ -f &quot;$PID_FILE&quot; ] &amp;&amp; kill -0 $(cat &quot;$PID_FILE&quot;) 2&gt;/dev/null; then    echo &quot;Consul is already running.&quot;else    echo &quot;Starting Consul...&quot;    nohup $CONSUL_PATH agent -dev -data-dir=$DATA_FILE -config-file=$CONFIG_FILE -client 0.0.0.0 -ui &gt; $LOG_FILE 2&gt;&amp;1 &amp;  # 后台运行，# 此行如若不需要流控熔断功能可把【-config-file=$CONFIG_FILE 】去掉    echo $! &gt; &quot;$PID_FILE&quot;  # 将进程 ID 写入文件    echo &quot;Consul started with PID $(cat &quot;$PID_FILE&quot;).&quot;fi

shutdown-consul.sh
#!/bin/bashcd `dirname $0`  # 替换为 consul 的实际路径BASE_DIR=`pwd`PID_FILE=$BASE_DIR/consul.pid  # 存储进程 ID 的文件# 检查 PID 文件是否存在if [ -f &quot;$PID_FILE&quot; ]; then    PID=$(cat &quot;$PID_FILE&quot;)    if kill -0 &quot;$PID&quot; 2&gt;/dev/null; then        echo &quot;Stopping Consul...&quot;        kill &quot;$PID&quot;        rm -f &quot;$PID_FILE&quot;  # 删除 PID 文件        echo &quot;Consul stopped.&quot;    else        echo &quot;Consul is not running.&quot;        rm -f &quot;$PID_FILE&quot;  # 删除 PID 文件    fielse    echo &quot;Consul is not running.&quot;fi



Prometheus黑盒测试wget https://github.com/prometheus/blackbox_exporter/releases/download/v0.23.0/blackbox_exporter-0.23.0.linux-amd64.tar.gztar -xvf blackbox_exporter-0.23.0.linux-amd64.tar.gzcd blackbox_exporter-0.23.0.linux-amd64./blackbox_exporter#Blackbox Exporter 将在默认的 9115 端口上运行。



需要在 Prometheus 的配置文件 prometheus.yml 中添加 Blackbox Exporter 的配置，以监控指定的 IP 和端口。
在 prometheus.yml 中，添加一个新的 scrape_configs 来配置 Prometheus 通过 Blackbox Exporter 进行 TCP 探测：
- job_name: &#x27;tcp_probes&#x27;    metrics_path: /probe  # 使用 Blackbox Exporter 的探测路径    params:      module: [tcp_connect]  # 指定使用 TCP 连接探测模块    static_configs:          # 添加更多要监控的服务地址      - targets: [&#x27;localhost:9115&#x27;]  # 本地运行的 Blackbox Exporter    relabel_configs:      - source_labels: [__address__]        target_label: __param_target



通过请求http://localhost:9115/probe?target=111.229.25.127:6379&amp;module=tcp_connect
会获得
# HELP probe_dns_lookup_time_seconds Returns the time taken for probe dns lookup in seconds# TYPE probe_dns_lookup_time_seconds gaugeprobe_dns_lookup_time_seconds 1.0149e-05# HELP probe_duration_seconds Returns how long the probe took to complete in seconds# TYPE probe_duration_seconds gaugeprobe_duration_seconds 0.029551479# HELP probe_failed_due_to_regex Indicates if probe failed due to regex# TYPE probe_failed_due_to_regex gaugeprobe_failed_due_to_regex 0# HELP probe_ip_addr_hash Specifies the hash of IP address. It&#x27;s useful to detect if the IP address changes.# TYPE probe_ip_addr_hash gaugeprobe_ip_addr_hash 3.600422005e+09# HELP probe_ip_protocol Specifies whether probe ip protocol is IP4 or IP6# TYPE probe_ip_protocol gaugeprobe_ip_protocol 4# HELP probe_success Displays whether or not the probe was a success# TYPE probe_success gaugeprobe_success 1

成功状态：probe_success 的值为 1，表明被监控的服务可达且正常运行。
探测时间：probe_duration_seconds 和 probe_dns_lookup_time_seconds 的值都相对较小，表示响应时间快，这通常是健康服务的标志。
无正则错误：probe_failed_due_to_regex 的值为 0，表明探测没有因正则表达式问题而失败。
java实现package com.example.demo.blackboxexporter;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.net.HttpURLConnection;import java.net.URL;public class BlackboxProbe &#123;    private static final String PROBE_URL_TEMPLATE = &quot;http://172.26.160.119:9115/probe?module=tcp_connect&amp;target=%s&quot;;    public static void main(String[] args) &#123;        try &#123;            // 发起 HTTP GET 请求            String target = &quot;111.229.25.127:3306&quot;;            String probeUrl = String.format(PROBE_URL_TEMPLATE, target);            HttpURLConnection connection = (HttpURLConnection) new URL(probeUrl).openConnection();            connection.setRequestMethod(&quot;GET&quot;);            // 处理响应            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));            String inputLine;            StringBuilder response = new StringBuilder();            while ((inputLine = in.readLine()) != null) &#123;                response.append(inputLine).append(&quot;\n&quot;);            &#125;            in.close();            // 解析 Prometheus 格式的响应            String[] lines = response.toString().split(&quot;\n&quot;);            int probeSuccess = -1;            double probeDuration = -1;            for (String line : lines) &#123;                if (line.startsWith(&quot;probe_success&quot;)) &#123;                    probeSuccess = Integer.parseInt(line.split(&quot; &quot;)[1]);                &#125; else if (line.startsWith(&quot;probe_duration_seconds&quot;)) &#123;                    probeDuration = Double.parseDouble(line.split(&quot; &quot;)[1]);                &#125;            &#125;            // 输出结果            System.out.println(&quot;probe_success: &quot; + probeSuccess);            System.out.println(&quot;probe_duration_seconds: &quot; + probeDuration);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;



blackbox_exporter启动终止脚本startup-blackbox_exporter.sh
#!/bin/bash cd `dirname $0`/blackbox_exporter-0.23.0.linux-amd64BASE_DIR=`pwd`# 定义 blackbox_exporter 的路径BLACKBOX_EXPORTER_PATH=$BASE_DIR/blackbox_exporter  # 替换为 blackbox_exporter 的实际路径PID_FILE=$BASE_DIR/blackbox_exporter.pid  # 存储进程 ID 的文件# 检查是否已经在运行if [ -f &quot;$PID_FILE&quot; ] &amp;&amp; kill -0 $(cat &quot;$PID_FILE&quot;) 2&gt;/dev/null; then    echo &quot;blackbox_exporter is already running.&quot;else    echo &quot;Starting blackbox_exporter...&quot;    nohup $BLACKBOX_EXPORTER_PATH &gt; $BASE_DIR/../logs/blackbox_exporter.log 2&gt;&amp;1 &amp;  # 后台运行    echo $! &gt; &quot;$PID_FILE&quot;  # 将进程 ID 写入文件    echo &quot;blackbox_exporter started with PID $(cat &quot;$PID_FILE&quot;).&quot;fi

shutdown-blackbox_exporter.sh
#!/bin/bashcd `dirname $0`/blackbox_exporter-0.23.0.linux-amd64BASE_DIR=`pwd`PID_FILE=$BASE_DIR/blackbox_exporter.pid  # 存储进程 ID 的文件# 检查 PID 文件是否存在if [ -f &quot;$PID_FILE&quot; ]; then    PID=$(cat &quot;$PID_FILE&quot;)    if kill -0 &quot;$PID&quot; 2&gt;/dev/null; then        echo &quot;Stopping blackbox_exporter...&quot;        kill &quot;$PID&quot;        rm -f &quot;$PID_FILE&quot;  # 删除 PID 文件        echo &quot;blackbox_exporter stopped.&quot;    else        echo &quot;blackbox_exporter is not running.&quot;        rm -f &quot;$PID_FILE&quot;  # 删除 PID 文件    fielse    echo &quot;blackbox_exporter is not running.&quot;fi



流控和熔断借鉴sentinel的参数设计consul配置启用consul的ACL
修改consul的配置文件consul.hcl
acl &#123;  enabled = true  # 启用访问控制列表  default_policy = &quot;deny&quot;  # 默认策略为拒绝  enable_token_persistence = true  # 启用令牌持久性  tokens &#123;    master = &quot;1a2b3c4d-5678-90ab-cdef-1234567890ab&quot;  # 主令牌,可由JAVA工具类UUID.randomUUID().toString();生成  &#125;&#125;

重启consul（脚本在上）

执行consul acl list
如果 ACL 系统启用了，你会看到相关的 ACL 配置信息。如果仍然出现错误，说明 ACL 可能没有正确启用，需检查日志或配置文件。


Prometheus配置修改global:  scrape_interval: 5s  # 默认抓取间隔scrape_configs:  - job_name: &#x27;prometheus-consul-app&#x27;    consul_sd_configs:      - server: &#x27;192.168.15.128:8500&#x27;        services: [&#x27;prometheus-consul-app-demo&#x27;]        token: &#x27;1a2b3c4d-5678-90ab-cdef-1234567890ab&#x27;    metrics_path: &#x27;/actuator/prometheus&#x27;  # Spring Boot 默认的 Prometheus 指标路径

java程序的配置management:  endpoints:    web:      exposure:        include: health,info,prometheus  metrics:    export:      prometheus:        enabled: truespring:  application:    name: prometheus-consul-app  # 服务名称  cloud:    consul:      discovery:        health-check-path: /actuator/health  # 使用 HTTP 健康检查        health-check-interval: 10s  # 健康检查的间隔时间        acl-token: 1a2b3c4d-5678-90ab-cdef-1234567890ab        instance-id: $&#123;spring.application.name&#125;-$&#123;spring.cloud.client.ip-address&#125;-$&#123;server.port&#125;  # 使用IP和端口生成唯一ID        prefer-ip-address: true  # 强制使用IP地址注册到Consul        service-name: prometheus-consul-app-demo      host: 192.168.15.128      port: 8500      config:      	acl-token: 1a2b3c4d-5678-90ab-cdef-1234567890ab	sentinel:	  eager: true	  transport:		dashboard: 127.0.0.1:8718server:  port: 8111#  address: 192.168.15.128 # 将这里的IP替换为你的机器实际的内网或外网IP地址

如图

  .flodnstwoplp{width:70%}













被监控的java程序示例：https://gitee.com/lcdzzz/prometheus-consul-demo
获取监控指标的java程序示例：https://gitee.com/lcdzzz/client

]]></content>
  </entry>
  <entry>
    <title>Spring5自学</title>
    <url>/2022/01/20/spring5%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[动力节点Spring框架初学总结：https://www.processon.com/view/link/5fbdf69b0791294615630fd9#map
Spring框架概述：
Spring是轻量级的开源的JavaEE框架
Spring可以解决企业应用开发的负杂性
Spring有两个核心部分：IOC和Aop


IoC（Inversion of  Control）:控制反转， 是一个理论，概念，思想
描述的：把对象的创建，赋值，管理工作都交给代码之外的容器实现， 也就是对象的创建是有其它外部资源完成。(把对象的创建交给别人去干)

控制：创建对象，对象的属性赋值，对象之间的关系管理

反转：把原来的开发人员管理、创建对象的权限转移给代码之外的容器来实现，由容器代替开发人员管理对象，创建对象，给属性赋值。

正传：由开发人员在代码中，使用new构造方法创建对象，开发人员主动管理对象。
public static void main(String args[])&#123;           Student student = new Student(); // 在代码中， 创建对象。--正转。  	 &#125;

容器：是一个服务器软件，一个框架（spring）

为什么要使用 ioc ： 目的就是减少对代码的改动， 也能实现不同的功能。 实现解耦合。 

java中创建对象有哪些方式：

构造方法 ， new Student（）
反射
序列化
克隆
ioc ：容器创建对象
动态代理


ioc的体现： 

创建类继承HttpServelt 

在web.xml 注册servlet ， 使用
&lt; servlet-name&gt; myservlet &lt; &#x2F;servlet-name&gt;&lt; servelt-class&gt;com.bjpwernode.controller.MyServlet1&lt; &#x2F;servlet-class&gt;

没有创建 Servlet对象， 没有 MyServlet myservlet &#x3D; new MyServlet()Servlet 是Tomcat服务器它能你创建的。 Tomcat也称为容器  omcat作为容器：里面存放的有Servlet对象， Listener ， Filter对象



IoC的技术实现 ： :依赖注入， 只需要在程序中提供要使用的对象名称就可以， 至于对象如何在容器中创建， 赋值，查找都由容器内部实现。

spring是使用的di实现了ioc的功能， spring底层创建对象，使用的是反射机制。



junit:单元测试，一个工具类库，做测试方法使用的
单元：指定的是方法，一个类中有很多方法，一个方法称为单元
使用单元测试：

需要加入junit依赖。
&lt;dependency&gt;  &lt;groupId&gt;junit&lt;/groupId&gt;  &lt;artifactId&gt;junit&lt;/artifactId&gt;  &lt;version&gt;4.11&lt;/version&gt;  &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;

创建测试作用的类：叫做测试类
src&#x2F;test&#x2F;java目录中创建类

创建测试方法

public方法
没有返回值void
方法名称自定义，建议名称是test+要测试方法名称


方法没有参数

方法上面加入@Test，这样的方法是可以单独执行的。不用使用main方法
@Testpublic void test01()&#123;    //使用spring容器创建的对象    //1.指定spring配置文件的名称    String config=&quot;ba01/applicationContext.xml&quot;;    //2.创建表示spring容器的对象，ApplicationContext    //ApplicationContext就是表示spring容器，通过容器获取对象    //ClassPathXmlApplicationContext:表示从类路劲中加载spring配置文件    ApplicationContext ac = new ClassPathXmlApplicationContext(config);//这句话执行时，对象创建成功    //从容器中获取某个对象，你要调用对象的方法    //getBean(&quot;配置文件中bean的id值&quot;)    Student myStudent =(Student) ac.getBean(&quot;myStudent&quot;);    System.out.println(&quot;student对象= &quot;+myStudent);&#125;


基于XML的DI注入分类
set注入（掌握）

简单类型
简单类型的set注入：spring调用类的set方法
&lt;bean id =&quot;xx&quot; class=&quot;yyy&quot;&gt;&lt;property name =&quot;属性名字&quot; value=&quot;此属性的值&quot;/&gt;一个property只能给一个属性赋值&lt;property...&gt;&lt;/bean&gt;



引用类型：
 引用类型的set注入：spring调用类的set方法
&lt;bean id =&quot;xxx&quot; class=&quot;yyy&quot;&gt;    &lt;property name=&quot;属性名&quot; ref=&quot;bean的id（对象名称）&quot;/&gt;&lt;/bean&gt;


构造注入（理解）
spring调用类有的有参数构造方法，在创建对象的同时，在构造方法中给属性赋值，构造注入使用


&lt;constructor -arg&gt;标签   &lt;constructor -arg&gt; 标签： 一个&lt;constructor -arg&gt;表示构造方法的一个参数（构造方法中有三个参数则对应三个&lt;constructor -arg&gt;）                   &lt;constructor -arg&gt;标签属性：                       name:表示构造方法的形参名                       index:表示构造方法的参数位置，参数从左网友位置是0,1,2                       value：构造方法形参类型是简单类型，使用value                       ref：构造方法形参类型是引用类型，使用ref

引用类型自动注入spring框架根据某些规则可以给引用类型赋值。你不用再给引用类型赋值了

byName方式自动注入
（按名称注入）：java类中引用类型的属性名和spring容器中的（配置文件）&lt; bean&gt;的id名称一样，且数据类型是一致的，这样的容器中的bean，spring能够赋值给引用类型
语法：&lt;bean id =&quot;xx&quot; class=&quot;yy&quot; autowire=&quot;byName&quot;&gt;  简单类型属性赋值&lt;/bean&gt;

byType方法自动注入
按类型注入）：java类中引用类型的数据类型和spring容器中（配置文件）&lt; bean&gt;的class的属性是同源关系的，这样的bean能够赋值给引用类型。    同源就是一类的意思：    1.java类中引用类型的数据类型和bean的class值是一样的或是父子类关系的。    2.java类中引用类型的数据类型和bean的class值是接口和实现类的关系。
语法：&lt;bean id =&quot;xx&quot; class=&quot;yy&quot; autowire=&quot;byName&quot;&gt;  简单类型属性赋值&lt;/bean&gt;

注意：在byType中，在xml配置文件中声明bean只能有一个是符合条件的，否则错误



为应用指定多个Spring配置文件
多个配置优势：


每个文件的大小比一个文件要小很多。效率高
避免多人竞争带来的冲突。
如果你的项目有多个模块（相关的功能在一起） 一个模块一个配置文件。 学生考勤模块一个配置文件，  张三 学生成绩一个配置文件，      李四


多文件的分配方式：


按功能模块，一个模块一个配置文件
按类的功能，数据库相关的配置一个文件配置文件， 做事务的功能一个配置文件， 做service功能的一个配置文件等


基于注解的DI定义bean的注解@Component
@component: 创建对象，等同于&lt; bean&gt;的功能  属性：value，就是对象的名称（不指定对象名称，有spring提供默认的名称：类名首字母小写），也就是bean的id值， value的值是唯一的，创建的对象在整个spring容器中就一个  位置：在类的上面

@Component(value = &quot;myStudent&quot;)等同于  &lt; bean id=&quot;myStudent&quot; class=&quot;com.bjpowernode.ba01.Student&quot; /&gt;

spring中和@Component功能一致的，创建对象的注解还有：



@Repository（用在持久层类的上面）：放在dao的实现类上面，表示创建dao对象，dao对象是能访问数据库的。

@Service（用在业务层类的上面）：放在service的实现类上面，创建service对象，service对象是做业务出列，可以由事务等功能的。

@Controller（用在控制器的上面）：放在控制器（处理器）类上面，创建控制器对象的，控制器对象，能够接受用户提交的参数，显示请求的处理结果。


以上三个注解的使用语法和@Component一样的。都能创建对象，但是这三个注解还有额外的功能。  @Repository，@Service，@Controller是给项目的对象分层的。


  
  
  

简单类型属性注入@Value属性：value是String类型的，表示简单类型的属性值位置:   属性定义的上面，无需set方法，推荐使用；在set方法上面




byType自动注入@Autowired
spring框架提供的注解，实现引用类型的赋值
spring中通过注解给引用类型赋值，使用的是自动注入原理，支持byName，byType（默认）
位置:在属性定义的上面，无需set方法，推荐使用
属性：required，是一个boolean类型的，默认true
required&#x3D;true:表示引用类型赋值失败，程序报错，并终止执行
required&#x3D;false:引用类型赋值失败，程序正常执行，引用类型为null




byName自动注入@Autowired与@Qualifier步骤：

在属性上面加入@Autowired
在属性上面加入@Qualifier(value&#x3D;”bean的id”):表示使用指定名称的bean来完成赋值


JDK注解@Resource引用类型自动注入
来自jdk的注解，spring框架提供了对这个注解的功能支持，可以使用它给引用类型赋值。使用时也是自动注入原理，默认是byName
位置：在属性定义的上面，无需set方法，推荐使用；在set方法的上面
默认先使用byName自动注入，如果byType赋值失败，在使用byType
如果只想通过byName，则需要添加一个属性：name，name的值是bean的id（名称）


AOP面向切面编程动态代理：
实现方式：jdk动态代理，使用jdk中的Proxy，Method，InvocaitonHanderl创建代理对象。 jdk动态代理要求目标类必须实现接口
 cglib动态代理：第三方的工具库，创建代理对象，原理是继承。 通过继承目标类，创建子类。 子类就是代理对象。 要求目标类不能是final的， 方法也不能是final的

动态代理的作用：

在目标类源代码不改变的情况下，增加功能。
减少代码的重复
专注业务逻辑代码
解耦合，让你的业务功能和日志，事务非业务功能分离。




AOP（Aspect Orient Programming）面向切面编程Aspect: 切面，给你的目标类增加的功能，就是切面。 像上面用的日志，事务都是切面。          切面的特点： 一般都是非业务方法，独立使用的。
Orient：面向， 对着。
  Programming：编程
  oop: 面向对象编程

怎么理解面向切面编程 ？


需要在分析项目功能时，找出切面。
合理的安排切面的执行时间（在目标方法前， 还是目标方法后）
合理的安全切面执行的位置，在哪个类，哪个方法增加增强功能


术语：
Aspect:切面，表示增强的功能， 就是一堆代码，完成某个一个功能。非业务功能，常见的切面功能有日志， 事务， 统计信息， 参数检查， 权限验证。
JoinPoint:连接点 ，连接业务方b法和切面的位置。 就某类中的业务方法
Pointcut : 切入点 ，指多个连接点方法的集合。多个方法
目标对象： 给哪个类的方法增加功能， 这个类就是目标对象
Advice:通知，通知表示切面功能执行的时间。


一个切面有三个关键的要素：
切面的功能代码，切面干什么
切面的执行位置，使用Pointcut表示切面执行的位置
切面的执行时间，使用Advice表示时间，在目标方法之前，还是目标方法之后




AOP实现 aop是一个规范，是动态的一个规范化，一个标准
aop的技术实现框架：

spring：spring在内部实现了aop规范，能做aop的工作。spring主要在事务处理时使用aop。我们项目开发中很少使用spring的aop实现。 因为spring的aop比较笨重。
aspectJ：一个开源的专门做aop的框架。spring框架中集成了aspectj框架，通过spring就能使用aspectj的功能。  aspectJ框架实现aop有两种方式：
使用xml的配置文件 ： 配置全局事务
使用注解，我们在项目中要做aop功能，一般都使用注解， aspectj有5个注解。




学习aspectj框架的使用
切面的执行时间， 这个执行时间在规范中叫做Advice(通知，增强)， 在aspectj框架中使用注解表示的。也可以使用xml配置文件中的标签
@Before（前置）
@AfterReturning（后置）
@Around（环绕）
@AfterThrowing（异常）
@After（最终）
@Pointcut （定义切入点）


表示切面执行的位置，使用的是切入点表达式。

]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>git github git bash内容随记</title>
    <url>/2021/07/04/title%20git%20github%20git%20bash%E5%86%85%E5%AE%B9%E9%9A%8F%E8%AE%B0/</url>
    <content><![CDATA[使用git bash 创建文件及文件夹命令1.cd : 切换到哪个目录下， 如 cd e:\fff 切换 E 盘下面的fff 目录。　　当我们用cd 进入文件夹时,我们可以使用 通配符*, cd f*, 如果E盘下只有一个f开头的文件夹,它就会进入到这个文件夹.2.cd … 回退到上一个目录， 注意，cd 和两个点点…之间有一个空格。3.pwd : 显示当前目录路径。4.ls(ll): 都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。5.touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。6.rm: 删除一个文件, rm index.js 就会把index.js文件删除.7.mkdir: 新建一个目录,就是新建一个文件夹. 如mkdir src 新建src 文件夹.8.rm -r : 删除一个文件夹, rm -r src 删除src目录， 好像不能用通配符。9.mv 移动文件, mv index.html src index.html 是我们要移动的文件, src 是目标文件夹,当然, 这样写,必须保证文件和目标文件夹在同一目录下.10.reset 清屏，把git bash命令窗口中的所有内容清空。

Vim编辑器的撤销与恢复撤销操作
使用vim修改文档内容

按下Esc，回到命令模式

按下u，可以发现刚刚新加的内容全部消失了，vim编辑器底部还会显示“4 行被去掉的操作提示”，这就是撤销操作。

如果我们想回复到撤销前的内容，按下ctrl+r
可以看到刚刚被我们撤掉的四行内容又回来了，而且vim编辑器底部会显示“4 行被加入的操作提示”，这就是恢复撤销操作。



github中查找资源的小技巧：常用前缀后缀

找百科大全 awesome xxx
找例子 xxx sample
找空项目架子 xxx starter&#x2F;xxx boilerplate
找教程 xxx tutorial


github中Clone代码
点击绿色的Code图标
复制Clone中HTTPS的网址（git仓库在github上托管的地址）例：【https://github.com/akullpp/awesome-java.git 】
进入一个想要保存这个项目的文件夹
右键：git bash here

]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>tienchin项目笔记</title>
    <url>/2022/06/02/tienchin%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[项目结构分析项目结构：多模块（不是微服务）
整体思路：

依赖链最底层：common，提供了公用的工具，定义了统一的controller，BaseEntity实体类公共对象，以及其他的操作工具
common的上一层：framework，主要是配置类，在这里配置了系统的一些东西，例如security aop 数据源的配置等等
剩下的对应了三个的功能模块
system：系统管理，相等于具体的业务。比如系统管理中的用户管理，角色管理，菜单管理等等，包括系统监控什么的，都是写在system里面的
generator：代码生成
quartz：定时任务


ui：前端项目
admin：项目唯一的统一入口，controller都是在这里写的，上面的common等，都会被admin所依赖，这里的controller会调用对应的service

登录验证码响应结果分析：
Base64字符串转图片：https://tool.jisuapi.com/base642pic.html
验证码生成接口分析：
url：localhost/dev-api/captchaImage
AjaxResult是一个封装的返回工具类
验证码配置分析使用github上的kaptcha开源工具导入maven依赖
&lt;dependency&gt;            &lt;groupId&gt;com.github.penggle&lt;/groupId&gt;            &lt;artifactId&gt;kaptcha&lt;/artifactId&gt;            &lt;version&gt;2.3.2&lt;/version&gt;&lt;/dependency&gt;

接下来只要提供一个CaptchaConfig就行
再在里面提供一个bean
package com.lcdzzz.kaptcha;import com.google.code.kaptcha.impl.DefaultKaptcha;import com.google.code.kaptcha.util.Config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.util.Properties;import static com.google.code.kaptcha.Constants.*;@Configurationpublic class CaptchaConfig &#123;    @Bean(name = &quot;captchaProducer&quot;)    public DefaultKaptcha getKaptchaBean() &#123;        DefaultKaptcha defaultKaptcha = new DefaultKaptcha();        Properties properties = new Properties();        // 是否有边框 默认为true 我们可以自己设置yes，no        properties.setProperty(KAPTCHA_BORDER, &quot;yes&quot;);        // 验证码文本字符颜色 默认为Color.BLACK        properties.setProperty(KAPTCHA_TEXTPRODUCER_FONT_COLOR, &quot;black&quot;);        // 验证码图片宽度 默认为200        properties.setProperty(KAPTCHA_IMAGE_WIDTH, &quot;160&quot;);        // 验证码图片高度 默认为50        properties.setProperty(KAPTCHA_IMAGE_HEIGHT, &quot;60&quot;);        // 验证码文本字符大小 默认为40        properties.setProperty(KAPTCHA_TEXTPRODUCER_FONT_SIZE, &quot;38&quot;);        // KAPTCHA_SESSION_KEY        //将来生成验证码时，自动将验证码文本存入session中        properties.setProperty(KAPTCHA_SESSION_CONFIG_KEY, &quot;kaptchaCode&quot;);        // 验证码文本字符长度 默认为5        properties.setProperty(KAPTCHA_TEXTPRODUCER_CHAR_LENGTH, &quot;4&quot;);        // 验证码文本字体样式 默认为new Font(&quot;Arial&quot;, 1, fontSize), new Font(&quot;Courier&quot;, 1, fontSize)        properties.setProperty(KAPTCHA_TEXTPRODUCER_FONT_NAMES, &quot;Arial,Courier&quot;);        // 图片样式 水纹com.google.code.kaptcha.impl.WaterRipple 鱼眼com.google.code.kaptcha.impl.FishEyeGimpy 阴影com.google.code.kaptcha.impl.ShadowGimpy        properties.setProperty(KAPTCHA_OBSCURIFICATOR_IMPL, &quot;com.google.code.kaptcha.impl.ShadowGimpy&quot;);        Config config = new Config(properties);        defaultKaptcha.setConfig(config);        return defaultKaptcha;    &#125;&#125;

搞一个图片返回的controller
@RestControllerpublic class CaptchaController &#123;    @Autowired    DefaultKaptcha defaultKaptcha;    @GetMapping(&quot;/img&quot;)    public void captchaImg(HttpServletResponse reps) throws IOException &#123;        //生成验证码的文本        String text = defaultKaptcha.createText();        //基于这个文本去生成一个图片对象。把这个文本作为参数传进去，它会绘制一个验证码图片出来        BufferedImage image = defaultKaptcha.createImage(text);        ImageIO.write(image,&quot;jpg&quot;,reps.getOutputStream());    &#125;&#125;

接下里我们访问localhost:8082&#x2F;img
就会生成图片。
BUT!!!其实这个验证码工具，自己提供了个servlet，其实我们不需要自己写，直接用它提供的servlet
怎么用呢？
注册一个bean,原先的bean就不使用了
@Bean   ServletRegistrationBean&lt;HttpServlet&gt; captchaServlet()&#123;       ServletRegistrationBean&lt;HttpServlet&gt; bean = new ServletRegistrationBean&lt;&gt;();       bean.setServlet(new KaptchaServlet());       bean.addUrlMappings(&quot;/img2&quot;);       Properties properties = new Properties();       // 是否有边框 默认为true 我们可以自己设置yes，no       properties.setProperty(KAPTCHA_BORDER, &quot;yes&quot;);       // 验证码文本字符颜色 默认为Color.BLACK       properties.setProperty(KAPTCHA_TEXTPRODUCER_FONT_COLOR, &quot;black&quot;);       // 验证码图片宽度 默认为200       properties.setProperty(KAPTCHA_IMAGE_WIDTH, &quot;160&quot;);       // 验证码图片高度 默认为50       properties.setProperty(KAPTCHA_IMAGE_HEIGHT, &quot;60&quot;);       // 验证码文本字符大小 默认为40       properties.setProperty(KAPTCHA_TEXTPRODUCER_FONT_SIZE, &quot;38&quot;);       // KAPTCHA_SESSION_KEY       //将来生成验证码时，自动将验证码文本存入session中       properties.setProperty(KAPTCHA_SESSION_CONFIG_KEY, &quot;kaptchaCode&quot;);       // 验证码文本字符长度 默认为5       properties.setProperty(KAPTCHA_TEXTPRODUCER_CHAR_LENGTH, &quot;4&quot;);       // 验证码文本字体样式 默认为new Font(&quot;Arial&quot;, 1, fontSize), new Font(&quot;Courier&quot;, 1, fontSize)       properties.setProperty(KAPTCHA_TEXTPRODUCER_FONT_NAMES, &quot;Arial,Courier&quot;);       // 图片样式 水纹com.google.code.kaptcha.impl.WaterRipple 鱼眼com.google.code.kaptcha.impl.FishEyeGimpy 阴影com.google.code.kaptcha.impl.ShadowGimpy       properties.setProperty(KAPTCHA_OBSCURIFICATOR_IMPL, &quot;com.google.code.kaptcha.impl.ShadowGimpy&quot;);       bean.setInitParameters(new HashMap&lt;&gt;((Map)properties));       return bean;   &#125;



只有当：使用这个工具提供的验证码接口， properties.setProperty(KAPTCHA_SESSION_CONFIG_KEY, &quot;kaptchaCode&quot;);这个配置才是有效的
此时，只有hello一个接口：
@GetMapping(&quot;/hello&quot;)    public void hello(HttpSession session)&#123;        System.out.println(&quot;session.getAttribute(\&quot;kaptchaCode\&quot;) = &quot; + session.getAttribute(&quot;kaptchaCode&quot;));    &#125;

结果：

  .gyyvnalxnshp{width:70%}


&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;总结&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
properties.setProperty(KAPTCHA_SESSION_CONFIG_KEY, &quot;kaptchaCode&quot;);

如果想用Kaptcha本身提供的servlet来生成验证码的话，它就会自动把验证码文本存入session中
但如果是自己写的接口，比如最开始的方法，那么文本就需要自己手动去存入session中了

tienchin项目本身回归项目本身，其实properties.setProperty(KAPTCHA_SESSION_CONFIG_KEY, &quot;kaptchaCode&quot;);这行配置没必要，不需要
为什么呢？

生成验证码接口是我们自己写的
tienchin项目本身没有用session
所以tienchin中Captconfig中的bean，最终目的就是生成字符串&#x2F;数学运算的验证码

数学运算方面有意思的是这行代码,意思是验证码文本生成器是：KaptchaTextCreator
// 验证码文本生成器        properties.setProperty(KAPTCHA_TEXTPRODUCER_IMPL, &quot;com.lcdzzz.tienchin.framework.config.KaptchaTextCreator&quot;);





登录流程分析
登录核心：
SysLoginService类下的login方法中的
// 该方法会去调用UserDetailsServiceImpl.loadUserByUsername// 这句话的意思就是去执行登录authentication = authenticationManager                    .authenticate(new UsernamePasswordAuthenticationToken(username, password));   



登录成功后生成一个jwt字符串,return tokenService.createToken(loginUser);从这里点进createToken查看

public String createToken(LoginUser loginUser) &#123;
        String token = IdUtils.fastUUID();
        loginUser.setToken(token);
        setUserAgent(loginUser);
        refreshToken(loginUser);//所谓的刷新，就是存入到redis里面去

        Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;();
        claims.put(Constants.LOGIN_USER_KEY, token);
        return createToken(claims);
    &#125;
4. 点进上面的refreshToken   ```java       /**        * 刷新令牌有效期        *        * @param loginUser 登录信息        */       public void refreshToken(LoginUser loginUser) &#123;           loginUser.setLoginTime(System.currentTimeMillis());           loginUser.setExpireTime(loginUser.getLoginTime() + expireTime * MILLIS_MINUTE);           // 根据uuid将loginUser缓存           String userKey = getTokenKey(loginUser.getToken());           redisCache.setCacheObject(userKey, loginUser, expireTime, TimeUnit.MINUTES);       &#125;



暂且不考虑jwt原先的作用（例如无状态登录），其实这里的jwt作用已经“变形了”，实际上又变成了httpsession的作用，【虽然没有用session，但其实用户信息已经存入到redis里面了】

所谓的jwt，其实返回的仅仅只是uuid【相当于sessionid】，以后来回都传uuid

以后发送请求时，都会携带jwt字符串

登录成功后，f12查看token



  .fruoiioxjrer{width:70%}


   这个token是一个jwt字符串，而jwt字符串是分为了三部分【都是用base64编码】,如下
   eyJhbGciOiJIUzUxMiJ9 //指定算法名字.eyJsb2dpbl91c2VyX2tleSI6ImYwOTg1ZjljLWQ0YmEtNDZlYy05MWZkLTFkZWE4ZmQxNTFkNCJ9 //核心信息==&gt;json对象.y_wTovMxjSdh2XDFFoS8Y_ANo2p3iYjrhU-rK72LfG63OrL1L-d05-NNNBBOSJsgA4G410uOYl8PustxtN3DaQ


使用base64解码工具【https://base64.us/】查看内容


  .hohamgcomkkm{width:70%}




流程分析总结综上，登录流程就是：登录成功后，返回一个jwt字符串，以后每次发送请求都会携带它。jwt字符串分为三部分，第一部分是算法，第二部分是核心信息，核心信息里面只有一个uuid。
同时，它把用户信息存入redis里面中【登录信息，管理员，名字，leader，部门等等，都存在redis里面】，如图【左边相等于id，右边则是信息】

  .xboqabelhwhk{width:70%}



以后每次访问接口时，都要带上jwt字符串


  .yugyxeiskvov{width:70%}



所谓的jwt说白了就像用session时的jsessionid一样。只不过jsessionid是浏览器自动携带，而现在是自己手动加上jwt参数的

每次请求都需要校验参数，而这个是在哪里校验的呢？


jwt校验核心部分就是framework.security.filter下的JwtAuthenticationTokenFilter
@Override   protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)           throws ServletException, IOException &#123;       LoginUser loginUser = tokenService.getLoginUser(request); //根据请求，来获取登录用户       if (StringUtils.isNotNull(loginUser) &amp;&amp; /*这玩意为null，代表没有登录*/StringUtils.isNull(SecurityUtils.getAuthentication())) &#123;           //令牌续签           tokenService.verifyToken(loginUser);//验证用户，看看有没有过期           //构建一个UsernamePasswordAuthenticationToken存放用户信息，然后存入SecurityContextHolder           UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(loginUser, null, loginUser.getAuthorities());           authenticationToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));           SecurityContextHolder.getContext().setAuthentication(authenticationToken);           //此时SecurityContextHolder就有了用信息           //这样以后【接下来层级的过滤器，就不需要从请求头里获取用户信息了】           //当当前请求完毕时，SecurityContextHolder里的用户信息会被清楚掉。当下个请求来了，再周而复始，走来时路       &#125;       chain.doFilter(request, response);   &#125;

每次请求的时候，都带上jwt，然后拿着jwt，去redis里面查看用户信息，，然后存到SecurityContextHolder里面去
springsecurity登录配置分析详见framework.config下的SecurityConfig类，以后准备再看看springsecurity
自定义动态数据源思路分析
自定义一个注解@DataSource,将来可以将该注解加service层在方法或者类上面，表示方法或者类中的所有方法都使用某一个数据源
对于第一步，如果某个方法上面有@DataSource注解，那么就将该方法需要使用的数据源名称存入ThreadLocal。
自定义切面，在切面中解析@DataSource注解的时候，将@DataSource注解所标记的数据源存入到ThreadLocal中。
最后，当Mapper执行的时候，需要DataSource，他会自动去AbstractRoutingDataSource类中查找需要的数据源，我们只需要在AbstractRoutingDataSource中返回ThreadLocal中的值

综上：用@DataSource注解，在一个方法或者一个类上面，去标注你想使用哪个数据源。然后将来在这个AOP(切面)里面解析这个注解，把想使用的数据源的名字找出来，存在ThreadLocal里面去。当以后真正需要用的时候，人家会自动的从AbstractRoutingDataSource里面去查找需要的数据源。
所以，我们要做的就是：重写（自己写一个类继承）AbstractRoutingDataSource，然后在它的方法里面去返回ThreadLocal里边所存储的数据源的名字。最后它会根据名字找到对应的数据源
详细可见：自定义动态数据源
自定义限流注解详见：自定义限流注解
]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
        <tag>项目实战</tag>
        <tag>前后端分离</tag>
        <tag>ruoyi</tag>
        <tag>tienchin</tag>
      </tags>
  </entry>
  <entry>
    <title>windowsのwsl安装centos</title>
    <url>/2025/07/31/windows%E3%81%AEwsl%E5%AE%89%E8%A3%85centos/</url>
    <content><![CDATA[打开虚拟化在安装 WSL 2 之前，必须启用虚拟机平台可选功能。计算机将需要虚拟化功能才能使用此功能。
执行命令(管理员)
dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart



Chocolatey安装NuGet（读作New Get）是用于微软.NET开发平台的软件包管理器，是一个Visual Studio的扩展。Chocolatey 是基于 NuGet 的一个软件包管理器，就像 Linux 中的 yum 或 apt 一样，在 Windows10 中也可以用命令行安装程序了
以管理员身份打开powershell.exe,执行以下代码
Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString(&#x27;https://chocolatey.org/install.ps1&#x27;))

完成后，输入命令：choco ，如果能正确显示版本号，说明安装成功
LxRunOffline安装（需要重启终端）LxRunOffline 是非常实用的 WSL 管理软件，可以备份、创建、恢复、导出WSL子系统，也可以安装适配 WSL 的任何 Linux 发行版，可以将 WSL 子系统安装到任意目录中。
执行命令
choco install lxrunoffline -y



镜像安装依次执行以下命令
# 将wsl默认版本设置为2wsl --set-default-version 2# -n 后面是安装的实例名称，-d 后面是想将实例安装到的位置，-f 后面是镜像包所在路径。镜像要求为容器镜像，不能直接使用发布版。lxrunoffline install -n CentOS -d C:/work_space/wsl/centoszd -f C:/work_space/wsl/images/rootfs.tar.gz# 将已经安装的实例版本设置为 WSL2（可选，也可以将2改为1）wsl --set-version CentOS 2

可以从**GitHub - mishamosher&#x2F;CentOS-WSL: A GitHub Actions automated CentOS RootFS to use with WSL**获取centos镜像
也可以直接使用百度云：链接: https://pan.baidu.com/s/15OODsqT6QXqDpc-EXe0kFg?pwd=1xpv 提取码: 1xpv 
WSL简易维护命令行#升级wsl内核wsl --update#查看安装的子系统wsl -l -v #启用子系统 wsl -s centos #停用子系统wsl -t centos #注销子系统wsl --unregister centos #导出系统镜像wsl --export centos D:\rootfs.tar#【可选】centos8配置yum源cd /etc/yum.repos.drm -rf ./*curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-8.repo yum -y clean all #清除所有文件yum -y makecache #建立缓存yum repolist  #查看yum仓库信息



使用systemctl使用管理员权限打开文件/etc/wsl.conf，并加上以下内容
[boot] systemd=true



在cmd中运行
# 配置选项仅适用于在 Windows 内部版本 19041 及更高版本中作为 WSL 2 运行的分发版。# 请记住，可能需要运行 `wsl --shutdown`来关闭 WSL 2 VM，然后运行`wsl`重启 WSL 实例以使这些更改生效。# 关闭wsl --shutdown#重启wsl

官方文档：WSL 中的高级设置配置 | Microsoft Learn
映射windows程序新建/usr/mysoft，并追加到环境变量path中，之后将windows软件软连接到这个目录即可
mkdir /usr/mysoftvi /etc/profile# 在/etc/profile末尾加上export PATH=$PATH:/usr/mysoft# 使之生效source /etc/profile

如Notepad++
ln -s &quot;/mnt/d/software/Notepad++/notepad++.exe&quot; /usr/mysoft/note
接下来 就可以使用note aaa.txt等命令来编写文件了

推荐链接：docker 使用docker让wsl可以做更多的事

补档这个错误表示你的系统在尝试从阿里云的镜像源下载 vim-enhanced 包时，无法解析镜像服务器的主机名。通常，这种问题可能是由于 DNS 配置问题、网络连接问题或镜像源不可用造成的。
你可以尝试以下步骤来解决该问题：

检查网络连接： 确保你的机器能够连接到互联网，可以通过 ping 测试其他网站来验证网络连接，例如：
ping www.google.com

检查 DNS 配置： 如果网络连接正常，但 DNS 无法解析镜像主机名，你可以尝试更改 DNS 设置，使用公共 DNS 服务器（如 Google 的 8.8.8.8 和 8.8.4.4）。编辑 /etc/resolv.conf 文件，加入以下内容：
nameserver 8.8.8.8nameserver 8.8.4.4

切换镜像源： 如果你怀疑阿里云的镜像源当前不可用，可以尝试切换到其他镜像源。你可以编辑 CentOS 的 YUM 配置文件，切换为其他镜像源，例如：
sudo vi /etc/yum.repos.d/CentOS-Base.repo

修改 baseurl 和 mirrorlist 为其他可用的镜像源地址，例如：
baseurl=http://mirror.centos.org/centos/7/os/x86_64/

清理缓存： 清理 YUM 缓存后再试安装：
sudo yum clean allsudo yum makecachesudo yum install vim

]]></content>
  </entry>
  <entry>
    <title>图书管理系统介绍</title>
    <url>/2022/02/07/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[图书管理系统介绍简介项目地址：https://github.com/lcdzzz/springboot-library
对于github项目：https://github.com/jacklightChen/ManageBooks  的改造，这是原项目地址。
一个基于SpringBoot+Thymeleaf渲染的图书管理系统功能:

用户: a.预约图书 b.查看预约记录 c.还书 d.查看个人信息以及修改个人信息
管理员: a.添加图书 b.处理预约(借书) c.查看借阅记录另:1.当用户过了还书日期仍旧未还书时会发邮件通知（原）2.当有书被还时发邮件通知预约书的用户到图书馆进行借书（原）

在学习这个项目的过程中发现原项目的提供的sql文件并不完整，于是花了一些时间去完善了表结构，存储过程以及视图。
适用人群适合刚接触springboot不久的同学使用，因为几乎对每行代码都写上了注释，阅读起来会更舒适
使用技术


后端
…



核心框架
spring、springboot、mybatis


连接池
Alibaba Druid





前端
…



核心框架(轻量简洁)
BootStrap、Thymeleaf


界面入口:  localhost:8080管理员用户名: admin_zhangsan 密码: 123456 (manager表)普通用户名: zdcl_reader 密码: 123 (reader表)
项目演示
登录界面


  .vesfityhyghi{width:70%}



管理员页面


  .bcqdtxocwbbq{width:70%}



添加图书


  .fjwthtqghfey{width:70%}



管理预约


  .twqlklqhglfl{width:70%}



查看借阅情况


  .jiffkuxqfncr{width:70%}



借阅者界面


  .tslnfrvfmekh{width:70%}



预约图书


  .invcuwkjbltn{width:70%}



查看预约情况


  .cyzfoahgimru{width:70%}



退还图书


  .ukxipgtpsfwd{width:70%}



查看个人信息、修改个人信息


  .urfewmlusvok{width:70%}


  





]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>java</tag>
        <tag>springboot</tag>
        <tag>项目实战</tag>
      </tags>
  </entry>
  <entry>
    <title>关于java的Calendar类的bug</title>
    <url>/2022/10/19/%E5%85%B3%E4%BA%8Ejava%E7%9A%84Calendar%E7%B1%BB%E7%9A%84bug/</url>
    <content><![CDATA[
这篇文章废话比较多，想看bug和本人的逆天操作的话，可以直接去看“解决办法”和“结论”部分

起源一切的一切都起源于软测这一道看似无比简单的题

  .skwivjrcikfu{width:70%}


简单来说就是输出20221019这样的格式，然后输出是星期几
错误的代码这是我最开始写的错误的代码
import java.util.*;public class day &#123;    public static void main(String[] args) &#123;        Scanner in = new Scanner(System.in);        while (in.hasNext()) &#123;            System.out.println(&quot;输入任意1900从年到2400年之间的8位数的一个日期（日期格式例子：20221014）&quot;);            String next = in.next();            char[] chars = next.toCharArray();            String tempYear = &quot;&quot;;            String tempMonth = &quot;&quot;;            String tempDay = &quot;&quot;;            for (int i = 0; i &lt; 4; i++) &#123;                tempYear = tempYear + chars[i];            &#125;            for (int i = 4; i &lt; 6; i++) &#123;                tempMonth = tempMonth + chars[i];            &#125;            for (int i = 6; i &lt; 8; i++) &#123;                tempDay = tempDay + chars[i];            &#125;            int year = Integer.parseInt(tempYear);            int month = Integer.parseInt(tempMonth);            int day = Integer.parseInt(tempDay);//        System.out.println(year+&quot; &quot;+month+&quot; &quot;+day+&quot; &quot;);            if (year &lt; 1900 || year &gt; 2400) &#123;                System.out.println(&quot;日期格式错误！&quot;);                continue;            &#125;            if (month &lt; 1 || month &gt; 12) &#123;                System.out.println(&quot;日期格式错误！&quot;);                continue;            &#125;            if (day &lt; 1 || day &gt; 31) &#123;                System.out.println(&quot;日期格式错误！&quot;);                continue;            &#125;            int leapYear = 0;            int commonYear = 0;            for (int i = 1900; i &lt; year; i++) &#123;                    if (year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0) &#123;                        leapYear++;                    &#125; else                        commonYear++;            &#125;            int counts = 0;            counts = counts + leapYear * 366;            counts = counts + commonYear * 365;            switch (month)&#123;                case 12:                    counts+=30;                case 11:                    counts+=31;                case 10:                    counts+=30;                case 9:                    counts += 31;                case 8:                    counts += 31;                case 7:                    counts += 30;                case 6:                    counts += 31;                case 5:                    counts += 30;                case 4:                    counts += 31;                case 3:                    //sumDays += 28;                    //判断year是否是闰年                    if((year%4==0&amp;&amp;year%100!=0)||year%400==0)&#123;                        counts+=29;                    &#125;else&#123;                        counts+=28;                    &#125;                case 2:                    counts+=31;                case 1:                    counts+=day;            &#125;            System.out.println(&quot;counts = &quot; + counts);            int temp = counts % 7;            if (temp == 0) &#123;                System.out.println(&quot;星期日&quot;);            &#125;            if (temp == 1) &#123;                System.out.println(&quot;星期一&quot;);            &#125;            if (temp == 2) &#123;                System.out.println(&quot;星期二&quot;);            &#125;            if (temp == 3) &#123;                System.out.println(&quot;星期三&quot;);            &#125;            if (temp == 4) &#123;                System.out.println(&quot;星期四&quot;);            &#125;            if (temp == 5) &#123;                System.out.println(&quot;星期五&quot;);            &#125;            if (temp == 6) &#123;                System.out.println(&quot;星期六&quot;);            &#125;        &#125;    &#125;&#125;


因为要考虑的错误输入，所以代码看起来非常的冗余
不知道为什么会错，求发现问题的大佬联系qq1473220685，请喝奶茶

口头描述下遇到的bug吧，19000101往后几年，基本上没什么问题的，但是时间跨度一大，就出问题了。
解决办法于是就干脆去网上找到现成的工具类了
下面是更改后的代码，这边写的简介明了点
代码public class Test02 &#123;    public static void main(String[] args) &#123;        LocalDate date = LocalDate.of(2022,10,19);        ZoneId zone = ZoneId.systemDefault();        Instant instant = date.atStartOfDay().atZone(zone).toInstant();        java.util.Date da = Date.from(instant);        String weekDayString = getWeek(da);        System.out.println(weekDayString);    &#125;    public static String getWeek(Date date)&#123;        String[] weeks = &#123;&quot;星期日&quot;,&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;,&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;&#125;;        Calendar cal = Calendar.getInstance();        cal.setTime(date);        int i = cal.get(Calendar.DAY_OF_WEEK);        System.out.println(i);        int week_index = i - 1;        System.out.println(week_index);        if(week_index&lt;0)&#123;            week_index = 0;        &#125;        return weeks[week_index];    &#125;&#125;

输出
  .hyzvyxeaxkwi{width:70%}




bug描述看起来没什么毛病对不对？
但是换个测试用例，那就出问题了
代码public class Test02 &#123;    public static void main(String[] args) &#123;        LocalDate date = LocalDate.of(1900,1,1);        ZoneId zone = ZoneId.systemDefault();        Instant instant = date.atStartOfDay().atZone(zone).toInstant();        java.util.Date da = Date.from(instant);        String weekDayString = getWeek(da);        System.out.println(weekDayString);    &#125;    public static String getWeek(Date date)&#123;        String[] weeks = &#123;&quot;星期日&quot;,&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;,&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;&#125;;        Calendar cal = Calendar.getInstance();        cal.setTime(date);        int i = cal.get(Calendar.DAY_OF_WEEK);        System.out.println(i);        int week_index = i - 1;        System.out.println(week_index);        if(week_index&lt;0)&#123;            week_index = 0;        &#125;        return weeks[week_index];    &#125;&#125;

输出
  .qewwedpeocmi{width:70%}


1900的1月1日，怎么可能是周日呢？明明是周一啊
再测试我们再试试1900年1月2日的输出时什么
代码
public class Test02 &#123;    public static void main(String[] args) &#123;        LocalDate date = LocalDate.of(1900,1,2);        ZoneId zone = ZoneId.systemDefault();        Instant instant = date.atStartOfDay().atZone(zone).toInstant();        java.util.Date da = Date.from(instant);        String weekDayString = getWeek(da);        System.out.println(weekDayString);    &#125;    public static String getWeek(Date date)&#123;        String[] weeks = &#123;&quot;星期日&quot;,&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;,&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;&#125;;        Calendar cal = Calendar.getInstance();        cal.setTime(date);        int i = cal.get(Calendar.DAY_OF_WEEK);        System.out.println(i);        int week_index = i - 1;        System.out.println(week_index);        if(week_index&lt;0)&#123;            week_index = 0;        &#125;        return weeks[week_index];    &#125;&#125;

输出

  .vlgfprqomuhs{width:70%}



  .atqnhrumrbtx{width:70%}


结论综上，我认为这是Calendar类本身的bug。当然这个bug问题也不大，毕竟也没什么正常的需求需要去看19000101是星期几吧？
但本着“你就说有没有解决吧”的精神，我还是给这坨代码用if给救了回来…..

  .vyidfpqqenqf{width:70%}




最终代码import java.time.Instant;import java.time.LocalDate;import java.time.ZoneId;import java.util.*;public class day &#123;    public static void main(String[] args) &#123;        Scanner in = new Scanner(System.in);        System.out.println(&quot;输入任意1900从年到2400年之间的8位数的一个日期（日期格式例子：20221014）&quot;);        while (in.hasNext()) &#123;            String next = in.next();            int i1 = 0;            try &#123;                i1 = Integer.parseInt(next);            &#125; catch (NumberFormatException e) &#123;                System.out.println(&quot;日期格式错误！请重新输入&quot;);                continue;            &#125;            if (19000000 &gt; i1 || i1 &gt; 24000000) &#123;                System.out.println(&quot;日期格式错误！请重新输入&quot;);                continue;            &#125;            char[] chars = next.toCharArray();            String tempYear = &quot;&quot;;            String tempMonth = &quot;&quot;;            String tempDay = &quot;&quot;;            for (int i = 0; i &lt; 4; i++) &#123;                tempYear = tempYear + chars[i];            &#125;            for (int i = 4; i &lt; 6; i++) &#123;                tempMonth = tempMonth + chars[i];            &#125;            for (int i = 6; i &lt; 8; i++) &#123;                tempDay = tempDay + chars[i];            &#125;            int year = Integer.parseInt(tempYear);            int month = Integer.parseInt(tempMonth);            int day = Integer.parseInt(tempDay);            if (year &lt; 1900 || year &gt; 2400) &#123;                System.out.println(&quot;日期格式错误！请重新输入&quot;);                continue;            &#125;            if (month &lt; 1 || month &gt; 12) &#123;                System.out.println(&quot;日期格式错误！请重新输入&quot;);                continue;            &#125;            if (day &lt; 1 || day &gt; 31) &#123;                System.out.println(&quot;日期格式错误！请重新输入&quot;);                continue;            &#125;            LocalDate date = null;            try &#123;                System.out.println(&quot;year = &quot; + year);                System.out.println(&quot;month = &quot; + month);                System.out.println(&quot;day = &quot; + day);                if (year==1900&amp;&amp;month==1&amp;&amp;day==1)&#123;                    System.out.println(&quot;星期一&quot;);                    continue;                &#125;                date = LocalDate.of(year, month, day);            &#125; catch (Exception e) &#123;                System.out.println(&quot;日期格式错误！请重新输入&quot;);                continue;            &#125;            ZoneId zone = ZoneId.systemDefault();            Instant instant = date.atStartOfDay().atZone(zone).toInstant();            java.util.Date da = Date.from(instant);            String week = getWeek(da);            System.out.println(week);        &#125;    &#125;    public static String getWeek(Date date) &#123;        String[] weeks = &#123;&quot;星期日&quot;, &quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;&#125;;        Calendar cal = Calendar.getInstance();        cal.setTime(date);        int week_index = cal.get(Calendar.DAY_OF_WEEK) - 1;        System.out.println(week_index);        if (week_index &lt; 0) &#123;            week_index = 0;        &#125;        return weeks[week_index];    &#125;&#125;



]]></content>
      <categories>
        <category>解决的错误</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>解决的错误</tag>
        <tag>java报错</tag>
      </tags>
  </entry>
  <entry>
    <title>java自学笔记</title>
    <url>/2021/07/04/java%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[IDEA使用新建
新建一个Empty Project
新建一个空的工程，选择创建工程窗口下面的Empty Project

给空的工程起一个名字：javase

会自动弹出一个：project structure，这个窗口先取消掉

给空的工程下新建Module（模块）
idea的组织方式projecrt–&gt;module

在New Module窗口上点击左下角的java，然后next

给module起一个名字

编写代码，在src目录下新建类，写代码，并运行。



关于IDEA工具的快捷键以及一些简单的设置字体设置file–&gt;setting–&gt;输入font–&gt;设置字体样式以及字号大小

快捷方式
psvm（main方法）        sout（system.out.println)

删除一行：ctrl+y

左侧窗口的列表怎么展开？怎么关闭？
左箭头关闭，右箭头展开，上下箭头移动

idea中退出任何窗口，都可以使用esc键

任何新增、新建、添加的快捷键：
​    alt+insert

窗口变大变小
​    ctrl+shift+F12

快速运行
ctrl+shift+F10

切换java程序：
alt+左&#x2F;右箭头

切换窗口：
alt+标号（打开&#x2F;关闭）
alt+1(打开、关闭)

提示方法的参数：ctrl+p

注释：
单行注释：ctrl+&#x2F;
多行注释：ctrl+shift+&#x2F;

怎么定位方法&#x2F;属性&#x2F;变量?
光标停到单词下面，这个单词可能是方法名、变量名，停到单词下面之后，按住ctrl键，出现下划线，点击跳转。

idea当中复制一行是ctrl+d

idea工具中纠正错误的快捷键：alt+回车

快速查看源代码：ctrl按住。点击单词

查看一个类的属性和方法：ctrl + F12  








super关键字
super是一个关键字，全部小写

super和this对比着学习
this：

能出现在实例方法和构造方法中

语法是”this.” 、 “this()”

this不能出现在静态方法中

大部分条件下是可以省略的

this.什么时候不能省略呢？
在区分局部变量和实例变量的时候不能省略。
public void setName(string name)&#123;
​    this.name=name;
&#125;
this()只能出现在构造方法第一行，通过当前的构造方法去调用“本类”中其他的构造方法，目的是：代码复用。


super：

能出现在实例方法和构造方法中

语法是”super.” 、 “super()”

super不能出现在静态方法中

大部分条件下是可以省略的

super.什么时候不能省略呢？
父类和子类中有同名属性或者说有同样的方法，
想在子类中访问父类的，super. 不能省略。
super（)只能出现在构造方法第一行，通过当前的构造方法去调用“父类”中其他的构造方法，目的是：创建子类对象的时候，先初始化父类型特征



super()
表示通过子类的构造方法调用父类的构造方法。
模拟现实世界中：要想要儿子，必须先有父亲。
&#x2F;&#x2F;一个类如果没有手动提供任何构造方法，系统会默认提供一个无参数构造方法。
&#x2F;&#x2F;一个类如果手动提供了一个构造方法，那么无参数构造方法系统将不会再提供。

重要结论：
当一个构造方法第一行：
既没有this（）又没有super（）的话，默认会有一个super（）；
表示通过当前子类的构造方法调用父类的无参数构造方法。
所以必须保证父类的无参数构造方法是存在的。

注意：
this()和super()不能共存，他们都是只能出现在构造方法的第一行。

无论怎么折腾，父类的构造方法是一定会执行的（100%）。
&#x2F;&#x2F;在java语言中不管是new什么对象。最后老祖宗的object类的无参数构造方法一定会执行（object类的无参数构造方法是处于“栈顶部”）
栈顶的特点：
最后调用，但最先执行结束。
后进先出原则
以后写代码的时候，一个类的无参数构造方法还是建议手动写出来。
如果无参数构造方法丢失的话，可能会影响到子类对象的构建

注意：在构造方法执行过程中一连串调用了父类的构造方法，父类的构造方法有继续向下调用它的父类构造方法，但实际上对象只创建了一个。
super（实参）的作用：初始化当前对象的父类型特征，并不是创建新对象，对象只创建了一个。
&#x2F;&#x2F;java中允许在子类中出现一个和父类同名的变量、同名属性。

super不是引用，也不保存内存地址，也不指向任何对象，super只代表当前对象内部的那一块父类型的特征。

在父和子中有同名的属性或者相同的方法，如果此时想在子类中访问父类的数据，必须使用”super.”加一区分。

在子类中访问父类私有的数据，使用super.没有权限的
但父类私有的构造方法，可以用super（实参）去构造。


super的使用super.属性名    【访问父类的属性】*
super.方法名(实参)   【访问父类的方法】
super.(实参)   【调用父类的构造方法】*








final关键字
final修饰的变量？
final修饰的局部标量，一但被赋值，就不能重新赋值【final修饰的变量只能赋一次值】

fianl修饰的方法？
final修饰的方法无法被覆盖，被重写

fianl修饰的类？
final修饰的类无法被继承

final控制不了能不能调用的问题，final管的是：最后的，不能变的，不能改的。

final修饰的变量，如果这个变量是一个人”引用“
引用也是一个变量，所以也是不能变的
*final person p=new person(30);**p=new Person(30)//错误！无法为最终变量p分配值*
final修饰的引用：


  该引用只能指向1个对象，并且它只能永远指向该对象，无法指向其他对象。  并且在该方法执行过程中，该引用指向对象后，该对象不会被垃圾回收器回收。	  直到当前方法结束，才会释放空间。
  虽然final的引用指向对象A后，不能再重新指向对象B。  但是对象内部的数据可以被修改。

final修饰的实例变量，系统不负责赋默认值，要求程序员必须手动赋值。
这个手动赋值，在变量后面赋值可以，在构造方法赋值也可以。
final修饰的实例变量一般添加static修饰
解释：i永远都是10，创建100个对象，i也是10i是10是永远都不会改变的，既然这样，没必要声明为实例变量，最好是静态，节省内存空间
static final联合修饰的变量成为“常量”。


​	例：public static final double PI=3.1415926;
   常量名建议大写，每个单词之间采用下划线来衔接。
   常量：实际上常量和静态变量一样，区别在于：
   常量的值不能变。
   常量和静态变量，都是存储在方法去，并且都是类加载时初始化。








抽象类（abstract）
抽象类怎么定义？
在class钱添加abstract关键字。

抽象类是无法实例化的，无法创建对象的，所以抽象类是用来被子类继承的。

final和abstract不能联合使用，这两个关键字是对立的。

抽象类的子类可以是抽象类，也可以不是。

抽象类虽然无法实例化，但是抽象类有构造方法，这个构造方法是供子类使用的。

抽象类中不一定有抽象方法，但是抽象方法必须出现在抽象类中。

抽象方法怎么定义？
public abstract void dosome();

一个非抽象的类，继承抽象类，必须将抽象类中的抽象方法进行覆盖&#x2F;重写&#x2F;实现。

面试题（判断）：java语言中凡是没有方法体的方法都是抽象方法。（×）
object类中就有很多方法没有方法体，都是以“;”结尾的，但他们不是抽象方法，例如：
public native int hashCode();
这个方法底层调用了C++写的动态链接库。
前面修饰符列表中没有：abstract。有一个native表示调用JVM本地程序。








接口（接口也是一种类）接口的基础语法
接口也是一种“引用数据类型”。编译之后也是一个class字节码文件。

接口完全抽象。（抽象类是半抽象。）或者也可以说接口是特殊的抽象类。

接口怎么定义的，语法是什么？
[修饰符列表] interface 接口名{}

接口支持多继承。
interface C extend A，B&#123;
&#125;

接口只包含两个内容：常量+抽象方法。

接口中所有元素都会public修饰的。

接口中的抽象方法定义是：pubiic abstract 修饰符可以省略。

接口中的常量的public static final可以省略。

接口中的方法是抽象方法，所以接口中的方法不能有方法体（不能加大括号{}）。

一个非抽象的类，实现接口的时候，必须将接口中所有方法加以实现。

一个类可以实现多个接口

extends和implements可以共存，extends在前，implements在后。
class Cat extends Animal implements Flyable&#123;
​    &#125;

使用使用接口，在写代码时，可以使用多态（父类型引用指向子类型对象）。
向下转型要养成习惯：转型之前先if+instanceof进行判断
if(m instanceof K)&#123;
K k = (K) m；
&#125;



接口在开发中的作用注意：接口在开发中的作用，类似于多态在开发中的作用。
多态：面向抽象编程，不要面向具体编程。降低程序耦合度。提高程序的扩展力。
public class Master&#123;    public void feed(Dog d)&#123;&#125;    public void feed(Cat c)&#123;&#125;    //假设又要养其他宠物，那么这个时候需要再加1个方法。（需要修改代码）    //这样扩展力太差，违背了ocp原则（对扩展开放，对修改关闭）&#125;public class Master&#123;    public void feed(Animal a)&#123;        /*        面向Animal 父类编程，父类是比子类更抽象的。所以我们叫做面向抽象编程，不要面向具体编程。这样程序的扩展力就强。        */    &#125;&#125;



接口在开发总共的作用？
抽象是完全抽象的，而我们以后正好要求，面向抽象编程。
面向抽象编程这句话以后可以修改为：面向接口编程。
有了剪口就有了可插拔，可插拔表示扩展力很强，不是焊接死的。
主板和内存条之间有插槽，这个插槽就是接口，内存条坏了，可以重新买一个换下来，这叫做高扩展性（低耦合度）。

总结一句话：三个字解耦合
面向接口编程，可以降低程序耦合度，提高程序扩展力。符合ocp开发原则 。接口的使用离不开多态机制。（接口+多态才可以打到降低耦合度。）
 接口可以解耦合，解开的是谁和谁的耦合？？？
任何一个接口都有调用者和实现着。
接口可以讲调用者和实现者解耦合。
调用者面向接口调用。
实现者面向接口编写实现。


以后进行大项目的开发，一般都是讲项目分离成一个模块一个模块的，模块和模块之间采用接口衔接，降低耦合度 








类型和类型之间的关系：is a（继承）、has a（关联）、 like a（实现）

is a:
Ca is a Animal(猫是一个动物)
凡是能够满足is a的表示“继承关系”
A extends B;

has a:
I has a Pen(我有一支笔)
凡是能够满足has a 关系的表示“关联关系”
关联关系通常以“属性”的形式存在。
A&#123;
   B b;
&#125;

like a：
Cooker like a FoodMenu(厨师想一个菜单一样)、
凡是能够满足like a 关系的表示“实现关系”
实现关系通常是：类实现接口。
A implements B;










抽象类和接口有什么区别这里直说下抽象类和接口在语法上的区别。至于以后抽象类和接口应该怎么进行选择，通过后面的项目去体会。


抽象类是半抽象的
接口是完全抽象的


抽象类中有构造方法。
接口中没有构造方法。


类与类之间只能单继承。
接口与接口直接支持多继承。


一个抽象类只能继承一个类（单继承）。
一个类可以同时实现多个接口。


接口中只允许出现常量和抽象方法。


以后接口使用的比抽象类多。一般抽象类使用的还是少。
接口一般都是对“行为”的抽象。
抽象类既可以抽象行为又可以抽象数据。








package和import机制package
package出现在java源文件第一行。

带有包名怎么编译？
javac -d . xxx.java

怎么运行？
java 完整类名
例：java com.bjpowernode.javase.chapter17.HelloWorld




importimport什么时候不需要？

java.lang不需要
同包下不需要
其他一律都需要

怎么用？

import 完整类名
import 包名.*;


访问控制权限有哪些访问控制权限？
private 私有
protect 受保护
public 公开
____    默认


以上四种访问控制权限，控制的范围是什么？


访问控制修饰符
本类
同包
子类
任意位置



public
Y
Y
Y
Y


protected
Y
Y
Y
N


默认
Y
Y
N
N


private
Y
N
N
N


public&gt;protected&gt;默认&gt;private

访问控制权限修饰符可以修饰什么
属性（4个都行）
方法（4个都能用）
类（public 和默认可以，其他不行）
接口（public 和默认可以，其他不行）


JDK类库的根类：Object这个老祖宗中的方法都是所有子类通用的，任何一个类默认继承Object，就算没有继承，也会间接继承
Object类当中有哪些常用的方法？怎么找？

去源代码当中。（但这种方式比较麻烦，源代码也比较难）
去查阅java的类库的帮助文档。

什么事API?
​      应用程序的编程接口。整个JDK的类库就是一个javase的API（application program interface）。每一个API都会配置一套API帮助文档。SUN公司提前写好的这套类库就是API。（一般每一份API都对应一份API帮助文档。）、
目前为止我们只需要知道这几个方法即可：
protected Object clone()； //负责对象克隆的int hashOde(); //换区对象哈希值的一个方法boolean equals(Object obj); //判断两个对象是否相等String toString(); //讲哦对象转换成字符串形式protected void finalize(); //垃圾回收器负责调用的方法 




toString()方法以后所有类的toString()方法是需要重写的，重写规则，越简单越明了就好。
System.out.println(引用)；这里会自动调用“引用”的toString()方法。
String类是SUN写的，toString方法已经重写了。

equals()方法以后所有类的equals方法也需要重写，因为object中的equals方法比较的是两个对象的内存地址，我们应该比较内容，所以需要重写。
重写规则：自己定，主要看是什么和什么相等时表示里欧昂个对象相等。
基本数据类型比较实用：&#x3D;&#x3D;
对象和对象比较：调用equals方法
String类是SUN编写的，所以Strng类的equals方法重写了。
以后判断两个字符串是否相等，最好不要实用&#x3D;&#x3D;。要调用字符串对象的equals方法。

finalize()方法
在Object类中的源代码：
protected void finaliz() throw Throwable&#123; &#125;
GC：负责带一把过finalize()方法

finalize()方法只有一个方法体，里面没有代码，而且这个方法是protected修饰的。

这个方法不需要程序员手动调用，JVM的垃圾回收器会负责调调用这个方法。
不像equals toString ,equals和toString（）方法是需要你写代码调用的。
finalize（）只需要重写，重写玩将来会自动会有程序来调用。

finalize()方法的执行时机
当一个java对象即将被垃圾回收器回收的时候，垃圾回收器负责调用fianlize()方法。

finalize()方法实际上是SUN公司为java程序员准备的一个实际，垃圾销毁时机。
如果希望在对象销毁时机执行一段代码的话，这段代码要写在finalize()方法中。

静态代码块的作用是什么？
static{
   …
}
静态代码块在类加载的时候执行，并且只执行一次，这是一个SUN准备的类加载时机。
finalize()方法同样是sun为程序员准备的一个时机。
这个时机是垃圾回收时机。

有段代码可以建议垃圾回收期启动
System.gc();   // 建议启动垃圾回收器



hashCode方法：
在object中的hashCode方法是怎么样的?
public native int hashCode();
这个方法不是抽象方法，带有native关键字，底层调用c++程序。

hashCode()方法返回的是哈希值：
实际上就是java对象的内存地址，经过哈希算法，得出一个值。
所以hashCode()方法的执行结果可以等同看做一个java对象的内存地址


public class Test&#123;    public static void main (string[] args)&#123;                Object o = new Object();        int hashCodeValue = o.hashcode();        //对象内存地址经过哈希算法转换的一个数字。可以等同看做内存地址。        System.out.println(hashCodeValue);//89641564      	        MyClass mc=new MyClass;        System.out.println(mc.hashCode());//5641864654    &#125;&#125;class MyClass&#123;    &#125;


匿名内部类：
内部类：在类的内部又定义了一个新的类。被称为内部类。

内部类的分类：
静态内部类：类似于静态变量
实例内部类：类似于实例变量
局部内部类：类似于局部变量

使用内部类编写的代码，可读性差，尽量别用

匿名内部类是局部内部类的一种。因为这个类没有名字而得名，叫做匿名内部类。可以直接实现接口


mm.mySum(new Compute()&#123;    public int sum(int a,int b)&#123;        return a+b;&#125;&#125;,200,300);/*mm是对象，使用了mySum这个方法compute是一个接口，不能直接new对象，这里使用了匿名内部类。如果不用匿名内部类，那么需要再创建一个class，去implements接口*///以下是不使用匿名内部类的方法public class ComputeImpl implements Compute&#123;    public int sum (int a,int b)&#123;        return a + b;    &#125;&#125;


数组
数组的优缺点，并且要理解为什么

空间存储上，内存地址是连续的

每个元素占用的空间大小相同

知道首元素的内存地址

通过下班可以计算出偏移量
通过一个数学表达式，就可以快速计算出摸个下标为止上元素的内存1地址，直接通过内存地址定位，效率非常高。

优点：检索效率高。
缺点随记增删改效率较低，数组无法存储大数据量
注意：数组最后一个元素增删效率不受影响



以为数组的静态初始化和动态初始化

静态初始化：
int[] arr = &#123;1,2,3,4&#125;;
object[] objs = &#123;new Object(),new Object(),new Object() &#125;;

动态初始化
int []arr=new int[4];
Object[] objs=new Object[4]; //元素默认值为null



一维数组的遍历


二维数组的静态初始化和动态初始化

静态初始化：
int [] [] arr=&#123;    &#123;1,2,3&#125;,    &#123;2,3,4,4,5,6&#125;,    &#123;2,8&#125;&#125;;Object[][] arr=&#123;    &#123;new Object(),new Object()&#125;,    &#123;new Object(),new Object(),new Object(),new Object()&#125;,    &#123;new Object(),new Object(),new Object(),new Object(),new Object()&#125;&#125;;



动态初始化
int [] []arr = new int[3][4];//三行四列Object [] [] arr=new Object[4][4];Animal [][] arr=new Animal[3][4];//Animal累的数组，里面可以存储Animal对象以及它的子类


二维数组的遍历

main方法上”String[] args”参数的使用

数组的拷贝：System.arraycopy()方法的使用
数组长度一旦确定，不可变。
所以数组长度不够的时候需要扩容，扩容的机制是：新建一个大数组，讲小数组的数据拷贝到大数组，小数组被垃圾回收器回收
public class Selftest &#123;    public static void main(String[] args) &#123;        int[] arr=&#123;1,2,3,4,5,6,7,8,9,0&#125;;        int[] targetArr=new int[4];        System.arraycopy(arr,1,targetArr,0,targetArr.length);        for (int i = 0; i &lt;targetArr.length ; i++) &#123;            System.out.println(targetArr[i]);        &#125;    &#125;&#125;



对数组中存储应用数据类型的情况，要会画它的内存结构图



Java JDK中内置的一个类：java.lang.String
String 表示字符串类型，属于引用数据类型，不属于基本数据类型。

在java中随便使用双引号括起来的对象。例如：”abc”,”hello world”，这是三个String对象

java中规定，双引号括起来的字符串是不可变的·，也就是说”abc”从出生到死亡，都不可变。

在JDK当中双引号括起来的字符串。例如：“abc” “def”都是直接存储在”方法区’’的”字符串常量池”当中的。
为什么SUN公司把自付出存储在一个“字符串常量池”当中呢，因为字符串在实际开发中使用太频繁，为了执行效率，所以把字符串放到了方法区的字符串常量池当中。


String s1 =&quot;abcdef&quot;;String s2 =&quot;abcdef&quot;+&quot;xy&quot;;/**↑这两行代码在表示底层创建了3个字符串对象，都在字符串常量池当中↓这是使用new方法创建的字符串对象。这个代码中的“xy”是从哪里来的？凡是双引号括起来的都在字符串常量池当中有一份new对象的时候一定是在堆内存当中开辟空间*/String s3 = new String(&quot;xy&quot;);//i变量中保持的是100这个值int i=100;//s变量中保存的是字符串对象的内存地址//s引用中保存的不是&quot;abd&quot;，是0x1111//而0x1111是“abd”字符串对象在“字符串常量池”当中的内存地址。		String s =&quot;abc&quot;


关于String类中的构造方法
String s &#x3D; new String(“”);
String s &#x3D; “”;&#x2F;&#x2F;最常用
String s &#x3D; new String (char数组);
String s &#x3D; new String (char数组，起始下标，长度);
String s &#x3D; new String (byte数组)；
String s &#x3D; new String (byte数组，起始下标，长度)；


String 类当中常用方法
（掌握） char charAt(int index)
char c = &quot;中国人&quot;.charAt(1);
System.out.printlb(c);//国


（了解） int compareTo(String anotherString)
int result &#x3D; “abc”.compareTo(“abc”);
System.out.println(result);&#x2F;&#x2F;0
&#x2F;&#x2F;输出0（等于0）–&gt;前后一致
&#x2F;&#x2F;输出1（大于0）–&gt;前大后小
&#x2F;&#x2F;输出-1（小于0）–&gt;前小后大
按字典顺序
拿着字符串第一个字母和后面字符串的第一个字母比较。能分胜负就不再比较了。
System.out.println(“xyz”.compareTo(“yxz”));&#x2F;&#x2F;-1


（掌握） boolean contains(CharSequence s)
判断前面的字符串中是否包含后面的字符串。
System.out.println(“hello.java”.contains(“.java”));&#x2F;&#x2F;ture。如果没有，则输出false


（掌握） boolean endsWith(String suffix)
判断当前字符串是否以某个字符串结尾
System.out.println(“test.txt”.endsWith(“java”));&#x2F;&#x2F;false


（掌握） boolean equals(Object anObject)
比较两个字符串鼻血使用equals方法，不能使用“&#x3D;&#x3D;”
System.out.println(“abc”.equals(“abc”));&#x2F;&#x2F;true;


（掌握） boolean equalsIgnoreCase(String anotherString)
判断两个字符串是否相等，并且同时忽略大小写。


（掌握） byte[] getBytes()
将字符串转换成字节数组
byte[] bytes &#x3D; “abcd”.getBytes();
&#x2F;&#x2F;遍历以后输出的是 97 98 99 100


（掌握） int indexOf(String str)**
判断某个字符串在当前字符串中第一次出现处的索引（下标）
System,out.println(“12345java2222”.indexOf(“java”));&#x2F;&#x2F;6


（掌握） lastInt indexOf(String str)**
判断某个字符串在当前字符串中最后一次出现处的索引（下标）
System,out.println(“12345java2222”.lastIndexOf(“2”));&#x2F;&#x2F;12


（掌握） boolean isEmpty()
判断某个字符串是否为”空字符串”
String s &#x3D; “”；&#x2F;&#x2F;不能是null，不然会空指针异常,同时必须为空，就算是空格，返回的也是false；
System.out.println(s.isEmpty());


（掌握） int length()
面试题：判断数组长度和判断字符串长度不一样
判断数组长度是length属性，判断字符串长度是length()方法
System.out.println(“abc”.length());&#x2F;&#x2F;3


（掌握） String replace(CharSequence target, CharSequence replacement)
String的父接口就是：CharSequence
String s &#x3D;”abc”;String s1&#x3D;s.replace(“a”,”b”);System.out.println(s1);


（掌握） String [] split(String regex)
拆分字符串
String[] ymd &#x3D; “2002-6-1”.split(“-“);for (int i &#x3D; 0; i &lt; ymd.length ; i++) {System.out.println(ymd[i]);
&#x2F;&#x2F;可以继续向下拆分，比如通过”0”拆分
}&#x2F;&#x2F;输出2002  6  1


（掌握） boolean startWith(String prefix)
判断某个字符串是否以某个子字符串开始
System.out.println(“111222333”.startWith(“111”));&#x2F;&#x2F;true
System.out.println(“111222333”.startWith(“123”));&#x2F;&#x2F;false


（掌握） String substring(int beginIndex)
截取字符串
System.out.println(“111222333”.substring(6));333


（掌握） String substring(int beginIndex,int endIndex)
beginIndex包括，endIndex不包括
System.out.println(“111222333444”.substring(7,10));334【左闭右开】


（掌握） char[] toCharArray();
将字符串转换成char数组
char[] chars &#x3D; “我是中国人”.toCharArray();
&#x2F;&#x2F;遍历得出结果：我 是 中 国 人


（掌握） String toLowerCase()
转换成小写
System.out.println(“ABCDef”.toLowerCase());


（掌握） String toUpperCase()
转换成大写
System.out.println(“ABCDef”.toLowerCase());


（掌握） String trim();
去除字符串前后空白
System.out.println(“   sda sdas  “.trim());&#x2F;&#x2F;sda sdas


(掌握) .String中有一个方法是静态的不需要new对象
这个方法叫做valueOf，作用是“非字符串“转换成”字符串”
String s1 &#x3D; String.valueOf(true);
String s1 &#x3D; String.valueOf(123);
System.out.println(s1);
//这个静态的valueOf()方法，参数是一个对象的时候，会自动调用这个对象的toString()方法String s1 = String.valueOf(new Customer());System.out.println(s1);//没有重写toString()方法之前是对象内存地址 System.out.println(s1);//我是一个vip客户！class Customer&#123;    //重写toString()方法    public String toString()&#123;        return &quot;我是一个vip客户！&quot;;    &#125;&#125;

本质上System.out.println()这个方法在输出任何数据的时候都是先转换成字符串，再输出 



StringBuffer和StringBuliderStringBuffer
如果以后需要进行大量的字符串拼接操作，建议使用JDK自带的：java.lang.StringBuffer;java.lang.StringBuilder;

如何优化StringBuffer的性能？
在创建StringBuffer的时候尽可能给定一个初始化容量。
最好减少底层的扩容次数。预估计一下，给一个大一些的初始化容量。


public static void main(String[] args) &#123;    //创建一个初始化容量为16个byte[]数组（字符串缓冲区对象）    StringBuffer stringBuffer= new StringBuffer();    //拼接字符串，以后拼接字符串同意调用append()方法    //append是追加的意思    stringBuffer.append(&quot;abd&quot;);    stringBuffer.append(3.14);    stringBuffer.append(true);    stringBuffer.append(100l);    //append方法底层在进行追加的时候，如果byte数组慢了，会自动扩容    stringBuffer.append(100l);    System.out.println(stringBuffer);//abd3.14true100100    //指定初始化容量的StringBuffer对象（字符串缓冲区对象）    StringBuffer sb = new StringBuffer(100);&#125;


StringBuilder和StringBuffer的异同
StringBuffer中的方法都有synchronized关键字修饰。表示StringBuffer在多线程环境下运行时安全的。StringBuilder则不安全
其余基本一样


8种基本数据类型对应的包装类型及方法基本数据类型名对应的包装类型名


基本数据类型
包装类型
父类



byte
java.lang.Byte
Number


short
java.lang.Short
Number


int
java.lang.Integer
Number


long
java.lang.Long
Number


float
java.lang.Float
Number


double
java.lang.Double
Number


boolean
java.lang.Boolean
Object


char
java.lang.Character
Object



以上八种包装类中，重点以java.lang.Integer为代表进行学习，其他的类型照葫芦画瓢就行

拆装箱及方法
八种包装类其中6个都是数字对应的包装类，他们的父类都是Nunber可先研究下Number中公共的方法：
Number是一个抽象类，无法实例化对象
Number类中有这样的方法：



Modifier and Type
Method and Description



byte
byteValue()返回指定号码作为值 byte ，这可能涉及舍入或截断。


abstract double
doubleValue()返回指定数字的值为 double ，可能涉及四舍五入。


abstract float
floatValue()返回指定数字的值为 float ，可能涉及四舍五入。


abstract int
intValue()返回指定号码作为值 int ，这可能涉及舍入或截断。


abstract long
longValue()返回指定数字的值为 long ，可能涉及四舍五入或截断。


short
shortValue()返回指定号码作为值 short ，这可能涉及舍入或截断。






public static void main(String[] args) &#123;    //123这个基本数据类型，进行构造方法的包装打到了：基本数据类型向引用数据类型的转型；    //基本数据类型（转换为）引用数据类型：装箱    Integer i = new Integer(123);    //引用数据类型（转换为）基本数据类型：拆箱    float f = i.floatValue();    System.out.println(f);//123.0    int revalue = i.intValue();    System.out.println(revalue);//123&#125;


关于Integer类的构造方法，有两个：
Integer(int)
Integer(String)

通过访问包装类的常量，来获取最大值和最小值：
System.out.println(Inter.MAX_VALUE);
System.out.println(Inter.MIN_VALUE);



JDK1.5以后，支持自动拆装箱：
自动装箱：int–&gt;Integer
Integer x &#x3D; 100;

自动拆箱：Integer–&gt;int
int y &#x3D; x;



关于方法权益中的“整数型常量池”java中为了提高程序的执行小效率，讲[-128,127]之间的所有数据提前创建好，放到一个方法去的”整数型常量池“当中了，目的是只要这个区间的数据不需要再new了，可以直接从整数型常量池中取出来。 
Integer常用方法
static int parseInt(String s)
静态方法，传参String，返回int
parse方法，把字符串转化成基本数据类型
int retValue &#x3D; Integer.parseInt(“123”);&#x2F;&#x2F;123,String–&gt;int
照葫芦画瓢：
double retValue2 &#x3D; Double.parseDouble(“3.14”);
System.out.println(retValue2+1); &#x2F;&#x2F;4.140000000000001(精度问题)

valueOf方法作为了解
static Integer valueOf(int i)
静态的：int –&gt;Integer
Integer i1 = Integer.valueOf(100);


static Integer valueOf(String s)
静态的：String–&gt;Integer
Integer i2 = Integer.valueOf(&quot;100&quot;);



String int Integer三种类型的互相转换：public static void main(String[] args) &#123;  //String --&gt;int    String s1=&quot;100&quot;;    int i1 = Integer.parseInt(s1);    System.out.println(i1+1);//101  //int --&gt;String    String s2 = i1+&quot;&quot;;    System.out.println(s2+1);//1001        long i=System.currentTimeMillis();        Integer ig = new Integer(100);        String s= String.valueOf(i);//long--&gt;String        String s2 = String.valueOf(ig);//Integer--&gt;String  //int --&gt;Integer  //自动装箱  Integer x=1000;  //Integer --&gt;int  //自动拆箱  int y = x;  //String --&gt;Integer    Integer k = Integer.valueOf(&quot;123&quot;);  //Integer --&gt;String    String s = String.valueOf(k);&#125;

   
java对日期的处理：
怎么获取系统当前时间

String –&gt;Date

Date –&gt;String
注意：字符串的日期格式和SimpleDateFormat对象指定的日期格式要一直，不然会出现异常


import java.text.SimpleDateFormat;import java.util.Date;public class Main &#123;    public static void main(String[] args) throws Exception &#123;     //获取系统当前时间        Date nowTime = new Date();        System.out.println(nowTime);//Thu Feb 04 23:20:25 CST 2021        /**         * 日期可以格式化吗？         * 将日期类型Date,按照指定格式进行转换：Date (转换成具有一定格式的日期字符串) --&gt;String         * SimpleDateFormat是java。text包下的。专门负责日期格式化         * yyyy年         * MM月         * dd日         * HH小时         * mm分         * ss秒         * SSS毫秒         */        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyy-M-d H:m:s:S&quot;);//格式随意组织，特殊字母不能动,这里的字母是java定好的，不能动        String nowTimeStr = sdf.format(nowTime);        System.out.println(nowTimeStr);        //String--&gt;Date        String time = &quot;2008-08-08 08:08:08 888&quot;;        SimpleDateFormat sdf2 = new SimpleDateFormat(&quot;yyyy-M-d H:m:s S&quot;);        //上面两个格式必须相同        Date dateTime = sdf2.parse(time);        System.out.println(dateTime);    &#125;&#125;


System类的相关属性和方法：
System.out【out是System类的静态变量】
System.outt.println() 【println()方法不是System类的，是PrintStream类的方法】
System.gc() 建议启动垃圾回收器
System.currentTimeMillis() 获取1970年1月1日到系统当前时间的总毫秒数
System.exit(0) 退出JVM

 
关于数字的格式化由于用的是在太少，想了解的点击https://www.bilibili.com/video/BV1Rx411876f?p=623&amp;spm_id_from=pageDriver的623集，笔记就不做了。
 
BigDecimal
BigDecimal 属于大数据，精度极高。不属于基本数据类型，属于java对象（引用数据类型）。
这是SUN提供的一个类。专门用在财务软件当中

问：你处理过财务数据吗？用的哪一种类型？
答：java.math.BigDecimal


 
随机数
第一种方法
Random random=new Random();int num=random.nextInt();//任何数int num2=random.nextInt(6);//0到5任何整数

第二种方法
第二种方法返回的数值是[0.0,1.0）的double型数值，由于double类数的精度很高，可以在一定程度下看做随机数，借助（int）来进行类型转换就可以得到整数随机数了，代码如下。
public static void main(String[] args)  &#123;    int max=100,min=1;    int ran2 = (int) (Math.random()*(max-min)+min);    System.out.println(ran2);&#125;

 
枚举：
一枚一枚可以列举出来的，才建议使用枚举类型
枚举编译后产生的也是class文件
枚举也是一种引用数据类型
枚举中的每一个值可以看做是常量

public class Main &#123;    public static void main(String[] args) &#123;        Result r = divide(10,3);        System.out.println(r);            System.out.println(r==Result.SUCCESS ? &quot;计算成功&quot;:&quot;计算失败&quot;);    &#125;    public static Result divide(int a,int b)&#123;        try&#123;            int c = a/b;            return Result.SUCCESS;        &#125;catch(Exception e)&#123;            return Result.FAIL;        &#125;    &#125;enum Result&#123;        SUCCESS,FAIL    &#125;&#125;

 
异常
什么事异常，java提供异常处理机制有什么用？
以下程序执行过成功发生了不正常的情况，这种不正常的情况叫做：异常
java是很完善的语言，提供了异常的处理方式，以下程序执行过程中出现了不正常的情况
java把改异常信息打印输出到控制糖，供程序员参考。程序员看到异常信息后，可以对程序进行修改，让程序更加健壮。
 

java语言中异常是以什么形式存在的呢？

异常在java中以类的形式存在，每一个异常类都可以创建对象。

异常对应的现实生活中是怎么样的
火灾（异常类）：
2008年8月8日，小明家着火了（异常对象。
2008年8月9日，小刚家着火了（异常对象。
2008年9月8日，小红家着火了（异常对象。


类是：模板
对象是：实际存在的个体


钱包丢了（异常类）
2008年1月8日，小明的钱包丢了（异常对象）
 



java的异常处理机制：

异常在java中以类和对象的形式存在。那么异常的继承结构是怎么样的？
我们可以使用UML图来描述一下继承结构。画UML图有很多工具，例如:Rational Rose 、starUML等
object
object下有Throwable（可抛出的）
Throwable下面有两个分支：Error(不可处理，直接退出JVM)和Exception(可处理的)    
Excepion下面有两个分支

Exception的直接子类：编译时异常（要求程序员在编写程序阶段必须预先对这些异常进行处理，如果不处理编译器就会报错，因此得名编译时异常）
RuntimeException：运行时异常。（在编写程序阶段程序员可以预先处理也可以不管，都行）



编译时异常和运行时异常，都是发生在运行阶段，编译阶段异常是不会发生的。
所有异常都是在运行阶段发生的，因此只有程序运行阶段才可以new对象。
因此异常的发生就是inew异常对象。


编译时异常和运行时异常的区别？

编译时异常一般发生的概率比较高&#x2F;&#x2F;  又叫受检异常或受控异常


例：你看到外面下雨了，倾盆大雨的。
你出门之前预料到：如果不打伞，我可能会生病（生病是一种异常）
而且这个异常发生的概率比较高，所以我们出门之前要拿一把伞。
“拿一把伞”就是对“生病异常”发生之前的一种处理方式

对于一些发生概率较高的异常，需要在运行之前对其进行预处理。



运行时异常一般发生的概率比较低&#x2F;&#x2F;  又叫未受检异常或非受控异常


例：小明走在大街上，可能会被天上的飞机轮子砸到。
被飞机轮子砸到也算一种异常。
但是这种异常发生概率较低。
在出门之前你没必要提前对这种发生概率较低的异常进行预处理。
如果你预处理这种异常，你讲获得很累。



假设java中没有对异常进行划分，没有分为：编译时异常和运行时异常，所有异常需要再编写程序阶段对其进行预处理，是怎么样的效果呢？


首先，如果这样的话，程序肯定绝对安全的

但是程序员编写程序太累的，代码到处都是处理异常的代码。








java语言中对异常的处理包括两种方式：
在方法声明的位置上使用throws关键字，抛给上一级

   谁调用我，我就抛给谁。抛给上一级。
注意：子类不能抛出比父类更宽泛&#x2F;更多的异常，比如继承了一个父类，但是这个父类没有thorws过异常，所以这个子类只能try..catch

使用try…catch语句进行异常的捕捉

   这件事发生了，谁也不知道，因为我给抓住了
   举个例子：

我是某集团的一个销售员，因为我的失误，导致公司损失了1000元
“损失”1000元，可以看做一个异常发生了。我有两种处理方式
第一种方式：我把这件事告诉领导【异常上抛】
第二种方式：我自己掏腰包把这钱补上【异常捕捉】

   java中异常发生后如果一直上抛，最后抛给了main方法，main方法继续上抛，抛给了调       用者JVM，JVM知道这个异常发生，只有一个结果。终止java程序的执行。
   注意：只要异常没有捕捉，采用上报的方式，此方法的后续代码不会执行。
   另外需要注意，try语句块的某一行出现异常，该行后面的代码不会执行。
   try..catch捕捉后，后续代码可以执行。
   
深入try..catch
catch后面的小括号中的类型可以是具体的异常类型，也可以是该异常类型的父类型。
catch可以写多个。建议catch的时候，精确的一个一个处理，这样有利于程序的调试。
catch写多个的时候，从上到下，必须遵守从小到大

   
上报和捕捉的选择：   如果希望调用者来处理，选择throws上报
   
   异常对象有两个非常重要的方法：、

获取异常简单的描述信息：
String msg &#x3D; exception.getMessage();

打印异常追踪的栈堆信息：
exception.printStackTrace();【exception是对象】
 


关于try..catch中的fianlly子句
在finally子句中的代码是最后执行的，并且是一定会执行，即使try语句块中的代码出现了异常。
finally子句必须和try一起出现，不能单独编写。

finally语句通常使用在哪些情况下呢？


 
java中任何自定义异常两步：

编写一个类继承Exception或者RuntimeException
提供两个构造方法，一个无参数的，一个带有String

public class MyException extends Exception&#123;    public MyException()&#123;            &#125;    public MyException(String s)&#123;        super(s);    &#125;&#125;public static void main(String[] args)&#123;    MyException e = new MyException(&quot;用户民不能为空！&quot;);    e.printStackTrace();//打印异常堆栈信息        //获取异常简单描述信息    String msg = e.getMessage();    System.out.print(msg);&#125;


集合概述
什么事集合？有啥用？
数组其实就是一个集合。集合实际上就是一个容器，可以用来容纳其他类型的数据。
集合为什么说在开发中使用较多？

集合是一个容器，一个载体，可以一次容纳多个对象，在实际开发中，假设连接数据库，数据库当中有10条记录，那么假设把这10条记录查询出来，在java程序中会将10条数据封装成10个java对象，然后将10个java对象放到某一个集合当中，将集合传动前端，然后遍历集合，将一个数据一个数据展现出来。



集合不能直接存储数据类型，另外集合也不能直接存储java对象，集合当中存储的都是ijava对象的内存地址。（或者说集合中存储的是引用

list.add(100);&#x2F;&#x2F;自动装箱Integer
注意：集合在java中本事是一个容器，也是一个对象。集合在任何时候存储的都是引用。



在java中年每一个不同的集合，底层会对应不同的数据结构。往不同的集合中存储元素，等于将数组放到了不同的数据结构当中。什么是数据结构？数据存储的结构就是数据结构。不同的数据结构，数据存储的方式不同。例如：



数组、二叉树、链表、哈希表…图

以上这些都是常见的数据结构

使用不同的集合等同于使用了不同的数据结构。

往集合c1中放数据，可能放到数组上了，往集合c2中放数据，可能放到二叉树上了….

在这一章节，需要掌握的不是精通数据结构。java中已经将数据结构实现了，已经写好了这些常用的集合类，你只需要掌握掌握怎么用。在什么情况下选择哪一种合适的集合去使用即可。

new ArrayList();创建一个集合对象，底层是数组

new LinkedList();创建一个集合对象，底层是链表

new TreeSet();创建一个集合对象，底层是二叉树 



集合在java JDK中哪个包下？
java.util.*;  所有的集合类和集合接口都在java.uti包下。 

最后能将集合的继承结构图背会。
集合整个这个体系是怎么样的一个结构，你需要有印象。

在java中结合分为两大类

一类是单个方式存储元素：
单个方式存储元素，这一类集合中超级父接口：java.util.Collection;

一类是以键值对儿的方式存储元素，这一类集合中的超级父接口：java.util.Map;




​        
关于java.util.Collection接口中常用的方法
Collection中能存放什么元素？
没有使用泛型之前，Collection中可以存储Object的所有子类型。
使用了“泛型”后，Collection中只能存储某个具体的类型。
集合后期我们会学习“泛型”的语法，目前先不用管。Collction中什么都能存，只要是Object的子类型就行。（集合中不能直接存储基本数据类型，也不能存java对象，只是存储java对象的内存地址。）

Collection中的常用方法
boolean add(Object e) 向集合中添加元素
int size() 获取集合中元素的个数
void clear()清空集合
boolean contain(Object o) 判断当前集合中是否包含元素o，包含返回true，不包含返回false
boolean remove(Object 0) 删除集合中的某个元素
boolean isEmpty() 判断集合中元素的个数是否为0
Object[] toArray() 调用这个方法可以把集合转换成数组。

迭代集合
   Collection c  new HashSet();   c.add(&quot;abc&quot;);   c.add(&quot;def&quot;);   c.add(100);   c.add(new Object());   //进行迭代   //第一步，获取集合对象的迭代器对象Iterator   Iterator it = c.iterator();   //第二步，通过以上获取的的迭代器对象开始迭代集合   /*   一以下两个方法是迭代器对象Iterator中的方法   boolean hasNext()如果仍有元素可以迭代，则返回true。   Objext next()返回迭代的下一个集合。   */   while(it.hasNext())&#123;       Object obj = it.next();       System.out.println(obj);          /*存进去是什么类型，取出来就是什么类型，   只不过输出的时候回转换成字符串。因为println会调用toString()方法。      */&#125;

总结重点：

把集合继承结构图背会。

把Collection接口中常用方法测试几遍


把迭代器弄明白

Collection接口中的remove方法和contain方法底层都会调用（重写）equals。

 


关于集合元素的remove
重点：当集合的结构发生改变是，迭代器萹蓄重新获取，如果还是用以前老的迭代器，会出现异常：java.util.ConcurrentModificationException

重点：在迭代集合元素的过程中，不能调用集合对象的remove方法，删除元素：
c.remove(0); 迭代过程中不能这样
否则会出现 java.util.ConcurrentModificationException

重点：在迭代元素的过程中，一定要使用迭代器的Itertator的remove方法，删除元素，不要使用集合自带的remove方法。


while(it2.hasNext())&#123;    Object o = it2.next();    /*    chu出异常的根本原因：集合中元素删除了，但没有更新迭代器（迭代器不知道集合变化了）    c2.remove(o)； 直接通过集合去删除元素，没有通知迭代器。（导致迭代器的快照和原集合状态不同    */    //使用迭代器去删除时，会自动更新迭代器，并且更新集合（删除集合中的元素）   it2.remove();//删除的一定是迭代器指向的当前元素    System.out.println(o);&#125;



  
关于java.util.list接口中常用的方法
​      List集合存储元素的特点：有序可重复
有序：List集合中的元素有下标。
从0开始，以1递增
可重复：存储一个1，还可以在存储1

List接口既然是Collection接口的子接口，那么肯定List接口有自己的”特色”的方法(以下只列出list特有的，常用的方法)

void add(int index，E element) 在列表的指定位置插入指定元素（第一个参数是下标）（后面的元素依次顺移一位）
Object get(int index) 按下标获取元素
int indexOf(Object o) 返回指定对象第一次出现处的索引
int lastIndexOf(Object o) 返回指定对象最后一次出现处的索引
Object remove(int index) 删除指定下标位置的元素
Object set(int index, E element) 修改指定位置的元素



  
ArrayList集合：
默认初始化容量为10（底层先创建了一个长度为0的数组，当前添加第一个元素的时候初始化容量10）

集合底层是一个Object[]数组

构造方法：
new ArrayList();
new ArrayList(20);

ArrayList集合的扩容：
增长到原容量的1.5倍。
ArrayList集合底层是数组，怎么优化：尽可能少的扩容。因为数组扩容效率比较低，建议在使用ArrayList集合的时候预估元素的个数，给定一个初始化容量。

这么多集合中，用哪个集合最多？
ArrayList集合
因为往数组末尾添加元素，效率不受影响。
另外，我们检索、查找某个元素的操作比较多

另一个构造方法
Collection c = new HashSet();//创建HashSet集合c.add(100);c.add(200);c.add(900);//通过这个构造方法可以将HashSet结合转换成List集合List myList3 = new ArrayList(c);for(int i = 0 ; i &lt; myList3.size() ; i++)&#123;    System.out.println(myList.get(i));&#125;

  
链表：
优点：
由于链表上的元素在空间存储上的内存地址不连续。
所有随记增删元素的时候不会有大量的元素位移，因此随记增删效率较高。
在以后的开发中，如果遇到随机增删集合中元素的业务比较多时，建议使用LinkedList。

缺点：
不能通过数学表达式计算被查找元素的内存地址，每一次查找都是从头节点开始遍历，直到找到为止。所以LinkedList集合检索、查找的效率较低。


ArrayList 数组的特点，把检索发挥到机制（但ArrayList是非线程安全的。不是线程安全的集合。）

LinkedList 链表特点（双向链表），把随机增删发挥到机制
LinkedList有初始容量吗？没有
最初这个链表中没有任何元素。first和last引用都是null
不管是LinkedList还是ArrayList，以后写代码不需要关心具体是哪个集合。
因为我们要面向接口编程，调用的方法都是接口中的方法


  
Vector
底层也是一个数组

初始化容量：10

怎么扩容的？
扩容之后是原容量的2倍

ArrayList集合扩容特点：
ArrayList集合扩容是原容量的1.5倍

Vector所有方法都是线程同步的，都带有synchronized关键字，是线程安全的。效率比较低，使用较少了。

怎么讲一个线程不安全的ArrayList集合转换成线程安全的呢？
使用集合工具类：
java.util.Collections;
java.util.Collection是集合接口；java.util.Collections是集合工具类
List myList = new ArrayList();//非线程安全的//变成线程安全的Collections.synchronizedList(myList);//myList集合线程就是安全的了myList.add(&quot;111&quot;);myList.add(&quot;222&quot;);myList.add(&quot;333&quot;);

  


泛型
JDK5.0之后推出的新特性：泛型

泛型这种语法机制，只在程序编译阶段起作用，只是给编译器参考的。（运行阶段泛型没用！）
//创建Animal Cat Bird类的代码省略List&lt;Animal&gt; myList = new ArrayList&lt;Animal&gt;();cat c = new Cat();Bird b = new Bird();myList.add(c);myList.add(b);/*JDK8之后，ArrayList&lt;这里的类型会自动推断&gt;(),前提是JDK8之后才允许自动类型推断，钻石表达式List&lt;Animal&gt; myList = new ArrayList&lt;&gt;();*/Iterator&lt;Animal&gt; it = myList.iterator();while(it.hasNext())&#123;    Animal a = it.next();    &#125;

使用了泛型的好处是什么？

集合中存储的元素类型同意了。
从集合中取出的元素类型是泛型指定的类型，不需要进行大量的“向下转型”


泛型的缺点是什么？

导致集合中存储的元素缺乏多样性！
大多数业务中，集合中元素的类型还是统一的。所以这种·泛型特性被大家所认可


自定义泛型可以吗？可以

自定义泛型的时候，&lt;&gt;尖括号中的是一个标识符，随便下。

java源代码中经常出现的是：&lt;E&gt;和&lt;T&gt;
E:Element元素
T:Type类型




  
增强for循环：foreach/*for(元素类型 变量名 : 数组或集合)&#123; System.out.println(变量名);&#125;*/int [] arr =&#123;1,2,3,4&#125;for(int data : arr)&#123;    //data就是数组中的元素    System.out.println(data);&#125;

  
Set下的子类
HashSet集合：无序不可重复

TreeSet集合存储元素的特点：

无序不可重复，但是存储的元素可以自动按照大小顺序排序！ 
称为：可排序集合

无序：这里的无序指的是存进去的顺序和取出来的顺序不同。并且没有下标


  


java.util.Map接口中常用的方法
Map和Collection没有继承关系

Map集合以 key 和 value 的方式存储数据：键值对
key和value都是引用数据类型，都是存储对象的内存地址
key起到主导地位，value是key的一个附属品

Map接口中常用方法

V put(K key，V vaLue) 向Map集合中添加键值对

V get(Object key)  通过key获取vaLue

void clear() 清空Map集合

boolean containsKey(Object key) 判断Map中是否包含某个key

boolean containsVaLue(Object vaLue) 判断Map中是否包含某个value

boolean isEmpty() 判断Map集合中元素个数是否为0

Set&lt;K&gt; keySet() 获取Map集合所有的key（所有的键是个set集合）

V remove(Object key)通过key删除键值对

int size()获取Map集合中键值对的个数

ColLection&lt;V&gt; vaLues() 获取Map集合中所有的value，返回一个Collection


Set&lt;Map.Entry&lt;K,V&gt;&gt; entry Set() 将Map集合转换成set集合
例：Set&lt;Map.Entry&lt;Integer,String&gt;&gt; set = map.entry Set() 
假设现在有有一个Map集合 “map1”
Set set &#x3D; map1.entrySet();
【注意：Map集合通过entrySet()方法转换成的这个Set集合，Set集合中元素的类型是Map.Entry&lt;K,V&gt;】
【Map.Entry和String一样，都是一种类的名字，只不过：Map.Entry是静态内部类，是Map中的静态内部类】
package SelfTest;import java.util.HashSet;import java.util.Set;public class Myclass&#123;    //声明一个静态内部类    public static class InnerClass&#123;        //静态方法        public static void m1()&#123;            System.out.println(&quot;静态内部类的m1方法实行&quot; );        &#125;        //实例方法        public void m2()&#123;            System.out.println(&quot;静态内部类中的实例方法执行！&quot;);        &#125;    &#125;    public static void main(String[] args) &#123;        //类名叫做：MyClass.InnerClass        Myclass.InnerClass.m1();        //创建静态内部类对象        Myclass.InnerClass mi = new Myclass.InnerClass();        mi.m2();        //给一个Set集合        //该Set集合中存储的对象是Myclass.InnerClass类型        Set&lt;Myclass.InnerClass&gt; set = new HashSet&lt;&gt;();        //这个Set集合中存储的是字符串对象        Set&lt;String&gt; set2 = new HashSet&lt;&gt;();        Set&lt;MyMap.MyEntry&lt;Integer,String&gt;&gt; set3= new HashSet&lt;&gt;();    &#125;&#125;class MyMap&#123;    public static class MyEntry&lt;K,V&gt;&#123;    &#125;&#125;


遍历Map集合（重点！！！）遍历集合

第一种方式：
获取所有·的key，通过遍历key，来遍历value
获取所有key，所有key是一个Set集合
Set&lt;Integer&gt; keys = map.keySet();
通过key获取value

第二种方式：
Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()
以上方法就是把Map集合直接全部转换成Set集合
Set集合中的元素的类型是：Map.Entry


package SelfTest;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Set;public class MapTest01 &#123;    public static void main(String[] args) &#123;        Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;();        map.put(1,&quot;zs&quot;);        map.put(2,&quot;ls&quot;);        map.put(3,&quot;ww&quot;);        map.put(4,&quot;zl&quot;);        /**         * 第一种方法 获取所有key，所有key是一个Set集合         */        Set&lt;Integer&gt; keys = map.keySet();        //foreach        for (Integer key: keys) &#123;            System.out.println(key + &quot;=&quot; + map.get(key));        &#125;        //迭代器        Iterator it = keys.iterator();        while(it.hasNext())&#123;            Object o = it.next();            System.out.println(o + &quot;=&quot; + map.get(o));        &#125;        /**         * 第二种方法 把Map集合直接全部转换成Set集合         */        Set&lt;Map.Entry&lt;Integer,String&gt;&gt; set = map.entrySet();//将Map集合变成Set集合        //迭代器        Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; it2 = set.iterator();        while(it2.hasNext())&#123;            Map.Entry&lt;Integer,String&gt; node = it2.next();            Integer key = node.getKey();            String value = node.getValue();            System.out.println(key+&quot;=&quot;+value);        &#125;        //foreach        for (Map.Entry&lt;Integer,String&gt; node : set) &#123;            System.out.println(node.getKey()+&quot;=&quot;+node.getValue());        &#125;    &#125;&#125;

  
HshMap集合
HashMap集合底层是哈希表&#x2F;散链表数据结构

哈希表是一个怎样的数据结构？
哈希表是一个数组和单向链表的结合体

HashMap集合的key部分特点：
无序，不可重复
为什么无序？因为不一定挂到哪个单向链表上。
不可重复是怎么保证的？equals方法来保证HashMap集合的key不可重复。
如果key重复了，value会覆盖


放在HashMap集合key部分的元素其实就是放到HashSet集合中了。
所以HashSet集合中的元素也需要同时重写hashCode()+equals()方法

哈希表HashMap使用不当时无法发挥性能！
要求散列分布均匀，需要你重写hashCode()方法时有一定的技巧。

重点：放在HashMap集合key部分的元素，以及放在HashSet集合中的元素，同时重写equals方法和hashCode方法

HashMap集合的默认初始化容量为16，默认加载因子是0.75
这个默认加载因子是当HashMap集合底层数组的容量达到75%的时候，数组开始扩容，扩容之后是原容量的2倍
重点：HashMap初始化容量必须是2的倍数，这是为了散列分布均匀，提高HashMap集合的存储效率，所必须的。


 
HashMap的equals方法和hashCode方法重写
向Map集合中存以及取，都是先调用key的hashCode方法，然后再调用equals方法！
equals方法有可能调用，也有可能不调用
比如put(k,v):k.hashCode()方法返回哈希值，哈希值经过哈希算法转换成下标，数组下标位置如果是null，equals不需要执行，get(k)方法同理

注意：如果一个类的equals方法重写了，那么hashCode()方法必须重写。
并且equals方法返回如果是true，HashCode()方法返回的值必须一样。

equals方法返回true表示两个对象相同，在同一个单向链表上比较，那么对于同一个单向链表的节点来说，他们的哈希值是相同的，所以hashCode()方法返回值也应该相同


hashCode()方法和equals()方法不用研究了，直接使用IDEA工具生成，不过这两个方法需要同时生成

对于哈希表数据结构来说：
如果o1和o2的值先沟通，一定是放在同一个单向链表上。
当然如果o1和o2的hash值不同，但由于哈希算法，执行结束之后转换的数组下标可能相同，此时会发生“哈希碰撞”

终极结论：放在HashMap集合key部分，以及方法HashSet集合中的元素，需要同时重写hashCode方法和equals方法。


  
Properties类
目前只需要掌握Properties属性类对象的相关方法即可。

Properties是一个Map集合，继承Hashtable，Properties的key和value都是String类型

Properties被称为属性类对象

Properties是线程安全的

需要掌握Properties的两个方法，一个存一个取
package SelfTest;import java.util.Properties;public class PropertiesTest &#123;    public static void main(String[] args) &#123;        //创建一个Properties对象        Properties pro = new Properties();        //存        pro.setProperty(&quot;zd&quot;,&quot;nb&quot;);        pro.setProperty(&quot;xjb&quot;,&quot;sb&quot;);        //通过key获取value        String zd = pro.getProperty(&quot;zd&quot;);        String xjb = pro.getProperty(&quot;xjb&quot;);        System.out.println(zd);        System.out.println(xjb);    &#125;&#125;

  
TreeSet和TreeMap
TreeSet集合底层实际上是一个TreeMap

TreeMap集合底层是一个二叉树

放在TreeSet集合中的元素，等同于放到TreeMap集合key部分了

TreeSet集合中的元素：无序不可重复，但是可以按照元素的大小顺序自动排序（升序）。
称为：可排序集合

TreeSet无法对自定义类型排序

放在TreeSet集合中的元素需要实现java.lang.Comparable接口

并且实现compareTo方法，equals可以不写
class Customer implements Comparable&lt;Customer&gt;&#123;    ...    public int compareTo(Customer c)&#123;        ...    &#125;&#125;

怎么写比较规则
compareTo方法的返回值很重要：
返回0表示相同，value会覆盖
返回&gt;0，会继续在右子树上找，
返回&lt;0，会继续在左子树上找。
public int compareTo(vip v)&#123;    int (this.age==v.age&#123;     //年龄相同时按照名字排序     //姓名是String类型，可以直接比。调用compareTo来完成比较        return this.name.compareTo(v.name);    &#125;else&#123;        return this.age - v.age;    &#125;&#125;

实现比较器接口
package SelfTest;import java.util.Comparator;import java.util.TreeSet;//Tree集合中元素课排序的第二种方式：使用比较器public class TreeMapTest &#123;    public static void main(String[] args) &#123;        //创建Tree集合的时候，需要使用这个比较器        //通过构造方法传递一个比较器进去        //给构造方法传递一个比较器        TreeSet&lt;WuGui&gt; wuGuis = new TreeSet&lt;&gt;(new WuGuiComparator());                wuGuis.add(new WuGui(1000));        wuGuis.add(new WuGui(800));        wuGuis.add(new WuGui(810));        for(WuGui wuGui:wuGuis)&#123;            System.out.println(wuGui);        &#125;    &#125;&#125;class WuGui&#123;    int age;    public WuGui() &#123;    &#125;    public WuGui(int age)&#123;        this.age=age;    &#125;    @Override    public String toString() &#123;        return &quot;WuGui&#123;&quot; +                &quot;age=&quot; + age +                &#x27;&#125;&#x27;;    &#125;&#125;//单独在这里编写一个比较器//比较器实现java.util.Comparator接口。（Comparable是java.lang包下的  。Comparator是java1。util包下的。Comparable是第一种方式）class WuGuiComparator implements Comparator&lt;WuGui&gt; &#123;    @Override    public int compare (WuGui o1,WuGui o2) &#123;        return o1.age-o2.age;    &#125;&#125;

/*

使用匿名内部类的方式，作用和上面一样

*/
package SelfTest;

import java.util.Comparator;
import java.util.TreeSet;

//Tree集合中元素课排序的第二种方式：使用比较器
public class TreeMapTest &#123;
    public static void main(String[] args) &#123;
        //创建Tree集合的时候，需要使用这个比较器
        //通过构造方法传递一个比较器进去

        //给构造方法传递一个比较器,匿名内部类
        TreeSet&lt;WuGui&gt; wuGuis = new TreeSet&lt;&gt;(new Comparator&lt;WuGui&gt;() &#123;
            @Override
            public int compare(WuGui o1, WuGui o2) &#123;
                return o1.age-o2.age;
            &#125;
        &#125;);


        wuGuis.add(new WuGui(1000));
        wuGuis.add(new WuGui(800));
        wuGuis.add(new WuGui(810));
        for(WuGui wuGui:wuGuis)&#123;
            System.out.println(wuGui);
        &#125;
    &#125;
&#125;
class WuGui&#123;
    int age;

    public WuGui() &#123;
    &#125;

    public WuGui(int age)&#123;
        this.age=age;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;WuGui&#123;&quot; +
                &quot;age=&quot; + age +
                &#39;&#125;&#39;;
    &#125;
&#125;
6. 最终结论：放TreeSet或者TreeMap集合key部分的元素要想做到排序，包括以下两种方式：   1. 放在集合中的元素实现java.lang.Comparable接口   2. 在构造TreeSet或者TreeMap集合的时候给它传一个比较器对象7. Comparable和Comparator怎么选择呢？   - 当比较规则不会发生改表的时候。或者说比较规则只有一个的时候，建议实现Comparable接口   - 如果比较规则有多个，并且是需要多个比较规则之间频繁切换，建议使用Comparator接口     Comparator接口的设计符合OCP原则 &lt;br&gt;&lt;br&gt; &lt;br&gt;&lt;br&gt;## Collections工具类注意：java.util.Collection 集合接口；java.util.Collections集合工具类，方便集合的操作 &lt;br&gt;&lt;br&gt; &lt;br&gt;&lt;br&gt;## IO流，什么是IO?- I:input ; O:output- java IO流这块有四大家族：  四大家族首领：  java.io.InputStream 字节输入流  java.io.OutputStream 字节输出流  &lt;br&gt;  java.io.Reader 字符输入流  java.io.Writer 字符输出流  &lt;br&gt;  四大家族的首领都是抽象类。（abstract class）- **所有流**都实现了：java.io.Closeable接口，都是可关闭，都有close（）方法。  养成好习惯，用完流一定要关闭。- **所有的输出流**都实现了java.io.Flushable接口，都是可刷新的，都有flush()方法。养成好习惯，输出流在最终输出之后，一定要记得flush()刷新一下，表示将通道、管道当中剩余未输出的数据，强行输出玩（清空管道！）刷新的作用就是清空管道。  如果没有flush()可能会导致丢失数据- **注意：在java中只要“类名”以Stream结尾的都是字节流。以&quot;Reader/Writer&quot;结尾的都是字符流**	- java.io包下需要掌握的流有16个：  **文件专属**：  java.io.FileInputstream  java.io.FileOutputstream  java.io.FileReader  java.io.FileWriter  &lt;br&gt;  **转换流**：（将字节流转换成字符流）  java.io.InputStreamReader  java.io.OutputStreamWriter  &lt;br&gt;  **缓冲流专属**：  java.io.BufferedReader  java.io.BufferedWriter  java.io.BufferedInputStream  java.io.BufferedOutputStream  &lt;br&gt;  **数据流专属**：  java.io.DataInputStream  java.io.DataOutputStream  &lt;br&gt;  **标准输出流**：  java.io.PrintWriter  java.io.PrintStream  &lt;br&gt;  **对象专属流**：  java.io.ObjectInputStream 反序列化  java.io.ObjectOutputStream 序列化 &lt;br&gt;&lt;br&gt; &lt;br&gt;&lt;br&gt;  ## 关于FileInputStream- 读取文件内容  ```java  package SelfTest;      import java.io.FileInputStream;  import java.io.FileNotFoundException;  import java.io.IOException;    public class FileInputStreamTest &#123;      public static void main(String[] args) &#123;          FileInputStream fis = null;          try&#123;              fis = new FileInputStream(&quot;F:\\idea\\IOstudy\\temp&quot;);              //准备一个byte数组              byte[] bytes = new byte[4];             /* while( true)&#123;                  int readCount = fis.read(bytes);                  if(readCount==-1) break;                  //把byte数组转换成字符串，读到多少个就转换成多少个                  System.out.print(new String(bytes,0,readCount));              &#125;*/              //对前一个方法的优化              int readCount = 0;              while( (readCount=fis.read(bytes))!=-1)&#123;                  System.out.println(new String(bytes,0,readCount));              &#125;          &#125; catch (FileNotFoundException e) &#123;              e.printStackTrace();          &#125; catch (IOException e) &#123;              e.printStackTrace();          &#125; finally &#123;              if (fis!=null);&#123;                  try&#123;                      fis.close();                  &#125;catch (IOException e)&#123;                      e.printStackTrace();                  &#125;              &#125;          &#125;      &#125;  &#125;






IDEA的相对路径：相对路径一定是从当前的位置作为起点开始找！
IDEA默认的当前路径是哪里？ 工程Project的根就是IDEA的默认当前路径

FileInputStream类的其他常用方法：
int available()  :返回流当中剩余的没有读到的字节数量
long skip(long n) :跳过几个字节不读


  
关于FileOutputStreampackage SelfTest;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;public class FileOutputStreamTest &#123;    public static void main(String[] args) &#123;        FileOutputStream fos = null;        try&#123;            //myfile文件不存在的时候会自动新建            //这种方式谨慎使用，这个方式会将源文件清空，然后重新写入            fos = new FileOutputStream(&quot;myfile&quot;);            byte[] bytes=&#123;97,98,99,100&#125;;            //将byte数组全部写出！            fos.write(bytes);            //将byte数组的一部分写出！            fos.write(bytes,0,2);//再写出ab            //以追加的方式在文件末尾写入。不会清空源文件内容            fos = new FileOutputStream(&quot;myfile&quot;,true);            fos.write(bytes,0,2);//再写出ab            String str = &quot;我是中国人！&quot;;            byte [] bt = str.getBytes();//会将字符串转换成数组            fos.write(bt);            //写完之后，最后一定要刷新            fos.flush();        &#125; catch (FileNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (IOException e)&#123;            e.printStackTrace();        &#125; finally&#123;            if(fos !=null)&#123;                try &#123;                    fos.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;


以追加的方式在文件末尾写入。不会清空源文件内容       fos = new FileOutputStream(&quot;myfile&quot;,true);

想要换行的话：
out.write(&quot;\n&quot;);


  
文件的复制使用FileInputStream + FileOutputStream完成文件的拷贝。
拷贝的过程应该是一边读，一边写。
使用以上的字节流拷贝文件的时候，文件类型随意，万能的。什么样的文件都能拷贝。
package SelfTest;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;public class CopyTest &#123;    public static void main(String[] args) &#123;        FileInputStream fis = null;        FileOutputStream fos = null;        try&#123;            fis = new FileInputStream(&quot;C:\\Users\\lcdzzz\\Videos\\Captures\\解决 java “错误：编码GBK 的不可映射字符” _ lcdzzz的博客 - Google Chrome 2021-01-21 15-50-05.mp4&quot;);//创建一个输入流对象            fos = new FileOutputStream(&quot;E:\\解决 java “错误&quot;);//创建一个输出流对象            //最核心的：一边读，一边写            byte[] bytes = new byte[1024*1024];//1MB(一次最多拷贝1MB)            int readCount=0;            while((readCount= fis.read(bytes))!=-1)&#123;                fos.write(bytes,0,readCount);            &#125;            //刷新，输入流最后要刷新            fos.flush();        &#125; catch (FileNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally&#123;            //分开try,不要一起try            if(fos!=null);&#123;                try&#123;                    fos.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if(fis!=null);&#123;                try&#123;                    fis.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;







  
java.io.File类
File类和四大家族没有关系，所以File类不能完成文件的读和写

File对象代表什么？
文件和目录名的抽象表达形式。
C:\Drivers
C:\Drivers\Lan\Realtek\Readme.txt 也是File对象

需要掌握File类的常用方法


package SelfTest;import java.io.File;public class FileTest01 &#123;    public static void main(String[] args)throws Exception &#123;        //创建一个File对象        File f1 = new File(&quot;D:\\zhoudianniubi.txt&quot; );        //判断是否出在！        System.out.println(f1.exists());        //如果文件不存在，则以文件的形式创建出来        if (!f1.exists())&#123;            f1.createNewFile();        &#125;        //如果文件不存在，则以目录的形式创建出来        if(!f1.exists())&#123;            f1.mkdir();        &#125;        //创建多层目录        File f2 = new File(&quot;D:a/b/c/d&quot;);        if (!f2.exists())&#123;            //以多重目录的形式新建、            f2.mkdirs();        &#125;    &#125;&#125;





package SelfTest;import java.io.File;import java.text.SimpleDateFormat;import java.util.Date;public class FileTest02 &#123;    public static void main(String[] args) &#123;        //获取文件、目录的父路径        File f3 = new File(&quot;D:\\javase\\homework\\HotelMgtSystem.png&quot;);        String parentpath = f3.getParent();        System.out.println(parentpath);        File parentFile = f3.getParentFile();        System.out.println(&quot;获取绝对路径：&quot; + parentFile.getAbsolutePath());        //获取文件名        System.out.println(&quot;文件名：&quot;+ f3.getName());        //判断是否是一目录        System.out.println(f3.isDirectory());//false        //判断是否是一个文件        System.out.println(f3.isFile());//true        //获取文件最后一次修改时间        long haoMiao = f3.lastModified();//从1970年到现在的总毫秒数        //将总毫秒数转换成日期？？？        Date time = new Date(haoMiao);        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm;ss SSS&quot;);        String strTime = sdf.format(time);        System.out.println(strTime);        //获取文件大小        System.out.println(f3.length());//单位是字节    &#125;&#125;





package SelfTest;import java.io.File;/*File中的listFile方法 */public class FileTest03 &#123;    public static void main(String[] args) &#123;        //File [] listFiles()        //获取当前目录下的所有子文件、子目录        File f = new File(&quot;D:\\javase\\homework&quot;);        File [] files = f.listFiles();        //foreach        for (File file:files             ) &#123;            System.out.println(file.getAbsoluteFile());        &#125;    &#125;&#125;


关于序列化和反序列化
java.io.NotSerializablieException
Student对象不支持序列化

参与序列化和反序列化的对象，必须实现Serializable接口。

注意：通过源代码发现，Serializable接口只是一个标志接口
public interface Serializable{
}
这个接口当中什么代码都没有。
那么它起到什么作用呢？
  起到标识的作用，java虚拟机看到这个类实现了这个接口，可能会对这个类进行特殊待遇。
Serializable 这个标志接口是给java虚拟机参考的，java虚拟机看到这个接口后，会为该类自动生成一个序列化版本号。
/*序列化*/package SelfTest;import java.io.FileOutputStream;import java.io.ObjectOutputStream;import java.io.Serializable;public class ObjectOutputStreamTest01 &#123;    public static void main(String[] args) throws Exception &#123;        //创建java对象        Student s = new Student(1111,&quot;zhangsan&quot;);        //序列化        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;students&quot;));        //序列化对象        oos.writeObject(s);        //刷新        oos.flush();        //关闭        oos.close();    &#125;&#125;class Student implements Serializable &#123;    private int no;    private String name;    public Student() &#123;    &#125;    public Student(int no, String name) &#123;        this.no = no;        this.name = name;    &#125;    public int getNo() &#123;        return no;    &#125;    public void setNo(int no) &#123;        this.no = no;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;&#125;



/*反序列化*/package SelfTest;import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInputStream;public class ObjectInputStreamTest &#123;    public static void main(String[] args) &#123;        ObjectInputStream ois = null;        try &#123;            ois = new ObjectInputStream(new FileInputStream(&quot;students&quot;));        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        //开始反序列化，读        Object obj = null;        try &#123;            obj = ois.readObject();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;        //反序列化回来是一个学生对象，所以可以调用学生对象的toString方法        System.out.println(obj);        try &#123;            ois.close();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;


序列化多个对象（序列化集合）并反序列化注意：存多个对象必须用List集合，直接存的话会报错
package SelfTest;import exception.homework.UserService;import java.io.FileOutputStream;import java.io.ObjectOutputStream;import java.io.Serializable;import java.util.ArrayList;import java.util.List;public class ObjectOutputStream02 &#123;    public static void main(String[] args)throws Exception &#123;        List&lt;User&gt; userList= new ArrayList&lt;&gt;();        userList.add(new User(1,&quot;zs&quot;));        userList.add(new User(2,&quot;ls&quot;));        userList.add(new User(3,&quot;ww&quot;));        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;Users&quot;));        oos.writeObject(userList);        oos.flush();        oos.close();    &#125;&#125;class User implements Serializable &#123;    private int no;    private String name;    public User(int no, String name) &#123;        this.no = no;        this.name = name;    &#125;    public User() &#123;    &#125;    @Override    public String toString() &#123;        return &quot;user&#123;&quot; +                &quot;no=&quot; + no +                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;



package SelfTest;import java.io.FileInputStream;import java.io.ObjectInputStream;import java.util.List;public class ObjectInputStream02 &#123;    public static void main(String[] args)throws Exception &#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;users&quot;));        List&lt;User&gt; userList =(List&lt;User&gt;)ois.readObject();        for (Object user:userList             ) &#123;            System.out.println(user);        &#125;        ois.close();    &#125;&#125;




transient关键字表示有力的，不参与序列化private transient String name  &#x2F;&#x2F;name不参与序列化操作
反序列化以后，name&#x3D;null





IO+Properties的联合应用非常好的一个设计理念：

以后经常改变的数据，可以单独写到一个文件中，使用程序动态获取。
将来只需要修改这个文件的内容，java代码不需要改动，不需要重新编译，服务器也不需要重启，就可以拿到动态的信息。

类似于以上机制的这种文件被称为配置文件。
并且当配置文件的内容格式是：
key1&#x3D;value
key2&#x3D;value的时候，我们把这种配置文件叫做属性配置文件

java规范中要求，属性配置文件建议以.properties结尾，但这不是必须的。
这种以.properties结尾的文件在java中被称为：配置文件
其中Properties是专门存放属性配置文件内容的一个类


package SelfTest;import java.io.FileReader;import java.util.Properties;public class IoPropertiesTest01 &#123;    public static void main(String[] args) throws Exception &#123;        /*        properties是一个Map集合，key和value都是String类型        香江userinfo文件中的数据加载到Propertie对象当中         */        //新建一个输入流对象        FileReader reader= new FileReader(&quot;&quot;);        //新建一个Map集合        Properties pro = new Properties();        //调用Properties对象的lode方法将文件中的数据加载到Mpa集合中        pro.load(reader);        //通过key来获取        String username = pro.getProperty(&quot;&quot;);        System.out.println(username);    &#125;&#125;


多线程
进程是一个应用程序，软件
线程是一个进程中的执行场景、执行单元
一个进程可以启动多个线程

进程A和进程B的内容独立不共享

线程A和线程B，堆内存和方法区内存共享，但是栈内存独立，一个线程一个栈

java中有多线程机制，目的就是为了提高程序的处理效率

使用多线程之后，main方法结束，程序有可能不会结束，main方法结束之时主线程结束了，主栈空了，其他的栈（线程）可能还在压栈弹栈。

关于线程对象的声明周期：
新建，就绪。运行，阻塞，死亡状态


实现线程的两种方式
第一种
用类继承Thread
package SelfTest;public class ThreadTest02 &#123;    public static void main(String[] args) &#123;        //这里是main方法，这里的代码属于主线程，在主栈中运行        //新建一个分支线程对象        MyThread myThread = new MyThread();        //启动线程        myThread.start();//start()方法的作用是：启动一个分支线程，在JVM中开辟一个新的栈空间，这段代码任务完成后，瞬间结束了        //接下来的代码还是运行在主线程中        for (int i = 0; i &lt;1000 ; i++) &#123;            System.out.println(&quot;主线程&quot;+i);        &#125;    &#125;&#125;class MyThread extends Thread&#123;    @Override    public void run() &#123;        for (int i = 0; i &lt;1000 ; i++) &#123;            System.out.println(&quot;支线程&quot;+i);        &#125;    &#125;&#125;



第二种
package SelfTest;public class ThreadTest03 &#123;    public static void main(String[] args) &#123;        /*        创建一个可运行的对象        MyRunnable r = new MyRunnable();        将可运行的对象封装成一个线程对象        Thread t = new Thread(r);         */        Thread t = new Thread(new MyRunnable());        //启动线程        t.start();        for (int i = 0; i &lt;1000 ; i++) &#123;            System.out.println(&quot;主线程&quot;+i);        &#125;    &#125;&#125;class MyRunnable implements Runnable&#123;    @Override    public void run() &#123;        for (int i = 0; i &lt;1000 ; i++) &#123;            System.out.println(&quot;支线程&quot;+i);        &#125;    &#125;&#125;

获取线程对象的名字
怎么获取当前线程对象
Thread t = Thread.currentThread();

获取线程对象的名字
String name=线程对象.getName(); 
主线程名字就叫main

修改线程对象的名字
线程对象.setName(“线程名字”)

当前没有设置名字的话，默认Thread-0，Thread-1，Thread-2



关于线程的sleep方法：ststic void sleep(long millis)

静态方法：Thread.sllep(1000)

参数是毫秒

作用：让当前线程进入休眠，进入“阻塞状态”，放弃占有CPU时间片，让给其他线程使用（出现在哪，就让谁睡）。
注意！，sleep是静态方法，sleep方法，出现在哪个线程，就 休眠，和哪个线程对象调用它没有关系！

用法：
package SelfTest;public class ThreadTest06 &#123;    public static void main(String[] args) &#123;        //让当前线程进入休眠，睡眠5秒        //当前线程是主线程！！！        try &#123;            Thread.sleep(5*1000);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        //5秒之后执行以下代码        System.out.println(&quot;hello world!&quot;);    &#125;&#125;

间隔某段特定的时间去执行某段特定的代码，每隔多久执行一次
package SelfTest;public class ThreadTest06 &#123;    public static void main(String[] args) &#123;        for (int i = 0; i &lt;10 ; i++) &#123;            System.out.println(Thread.currentThread().getName()+&quot;--&gt;&quot;+i);            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;

终断睡眠t.interrupt;&#x2F;&#x2F;t是线程的名字
这种终端睡眠的方式依靠了java的异常的处理机制
package SelfTest;public class ThreadTest08 &#123;    public static void main(String[] args) &#123;        Thread t = new Thread(new MyRunnable2());//将可运行对象封装成一个线程对象        t.start();        t.setName(&quot;t&quot;);        try &#123;            Thread.currentThread().sleep(5*1000);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        /*         这种终端睡眠的方式依靠了java的异常的处理机制         */        t.interrupt();//干扰，一盆冷水过去！给爷醒！    &#125;&#125;class MyRunnable2 implements Runnable&#123;    public MyRunnable2() &#123;    &#125;    @Override    public void run() &#123;        System.out.println(Thread.currentThread().getName()+&quot;---&gt;begin&quot;);        try &#123;            Thread.sleep(1000*60*60*24*365);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();            System.out.println(&quot;线程被唤醒！终止睡眠！&quot;);        &#125;    &#125;&#125;

java中怎么合理终止一个线程的执行package SelfTest;public class ThreadTest10 &#123;    public static void main(String[] args) &#123;        MyRunable4 r = new MyRunable4();        Thread t = new Thread(r);        t.setName(&quot;t&quot;);        t.start();        //模拟五秒        try &#123;            Thread.sleep(5000);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        //终止线程        r.run=false;    &#125;&#125;class MyRunable4 implements Runnable &#123;    //打一个布尔标记    boolean run = true;    @Override    public void run() &#123;        for (int i = 0; i &lt; 10; i++) &#123;            if (run) &#123;                System.out.println(Thread.currentThread().getName() + &quot;---&gt;&quot; + i);                try &#123;                    Thread.sleep(1000);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;else&#123;                break;            &#125;        &#125;    &#125;&#125;


怎么解决线程的安全问题呢？当多线程并发的环境下，有共享数据，并且这个数据还会被修改，此时就存在线程安全问题，怎么解决这个问题？

线程排队执行。（不能并发）
用排队执行解决线程安全问题。
这种机制被称为：线程同步机制

专业术语叫做：线程同步，实际上就是线程不能并发了，线程必须排队执行

怎么解决线程安全问题？
使用“线程同步机制”

线程同步就是线程排队


说道线程同步，设计两个专业术语

异步编程模型：并发
同步编程模型：排队


java中有三大变量
实例变量：在堆中

静态变量：在方法去中

局部变量：在栈中

以上三大变量中：局部变量永远都不会存在线程安全问题。因为局部变量不共享

实例变量在堆中，堆只有一个
静态变量在方法区中，方法去只有一个。
堆和方法区都是多线程共享的，所以可能存在线程安全问题。



在开发中怎么解决线程安全问题？
是上来就选择线程同步吗？
不是，synchronized会让程序的执行效率降低

尽量使用局部变量代替“实例变量和静态变量”

如果必须是实例变量，那么可以考虑创建多个对象，这样实例变量的内存就不共享了。（一个线程对应一个对象）

如果不能使用局部变量，对象也不能创建多个，这个时候就之后能选择synchronized了。线程同步机制。



synchronized有三种用法：
同步代码块：灵活
synchronized(线程共享对象){
同步代码块
}

在实例方法上使用synchronized
public synchronized void withdraw(double money)
表示共享对象一定是this

在静态方法上使用synchronized
class MyClass&#123;
public synchronized static void doSome()&#123;
&#125;
&#125;
表示找类锁
类锁只有一把
就算创建了100个对象，那么类锁也只有一把



守护线程
java语言中线程分为两大类：
一类是：用户线程
一类是：守护线程（后台线程）
其中具有代表性的就是：垃圾回收线程（守护线程）。

守护线程的特点：
一般守护线程就是一个死循环，所有的用户线程只要结束，守护线程自动结束。
注意：主线程main就是一个用户线程

守护线程用在什么地方呢？
每天00：00的时候系统数据自动备份，这个需要使用定时器，并且我们可以将定时器设置为守护线程。一直在那里看着，没到00:00的时候就备份一次。所有的用户线程如果结束了，守护线程自动退出，没有必要进行数据备份了。

用法：在启动线程之前，将线程设置为守护线程
t。setDaemon(true)
t.start



定时器定时器的作用：
间隔特定的时间，执行特定的程序。
每周要进行银行的总账操作。
每天要进行数据的备份操作。
在实际的开发中，每隔多久执行一段特定的程序，这种需求很常见，那么在java中其实可以采用多种方式实现



可以使用sleep方法，睡眠设置睡眠时间，每到这个时间点醒来执行任务，这种方式是最原始的。定时器（比较low）

在java的类库中已经写好了一个定时器：java.util.Timer,可以直接哪来用。

    package SelfTest;      import java.text.ParseException;   import java.text.SimpleDateFormat;   import java.util.Date;   import java.util.Timer;   import java.util.TimerTask;      /*   使用定时器定时任务    */   public class TimeTest &#123;             public static void main(String[] args) throws ParseException &#123;           //创建定时器对象           Timer timer = new Timer();           //Timer timer = new Timer(true); //守护线程的方法              //指定定时任务           //timeer.schedule(定时任务，第一次执行任务，间隔多久执行一次）           SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);           Date firstTime = sdf.parse(&quot;2021-03-04 14:39:50&quot;);           timer.schedule(new LogTimerTask(),firstTime,1000*10);          &#125;   &#125;   //编写一个定时任务类   //假设这是一个记录日志的定时任务   class LogTimerTask extends TimerTask&#123;          @Override       public void run() &#123;           //编写你需要执行的任务就行了           SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);           String strTime = sdf.format(new Date());           System.out.println(strTime+&quot;:成功完成了一次数据备份&quot;);          &#125;&#125;


实现线程的第三种方法，实现Callable接口。（JDK8新特性。）这种方式实现的线程可以获取线程的返回值。
之前讲解的那两种方式是无法获取线程返回值的，因为run方法返回void
思考：系统委派一个线程去执行一个任务，该线程执行完任务呢之后，可能会有一个执行结果，我们怎么能拿到这个执行结果呢？
​	使用第三种方法：实现Callable接口。

优点：可以获取线程的执行结果
缺点：效率比较低，在获取t线程的执行结果的时候，当前线程受阻塞，效率较低

package SelfTest;import jdk.swing.interop.SwingInterOpUtils;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;/*实现线程的第三种方式实现Callable接口 */public class ThreadTest15 &#123;    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;        //第一步：创建一个“未来任务对象“对象。        FutureTask task = new FutureTask(new Callable() &#123;            @Override            public Object call() throws Exception &#123;//call()方法就相当于run方法，只不过这个方法有返回值                System.out.println(&quot;call method begin&quot;);                Thread.sleep(1000*2);                System.out.println(&quot;call method end!&quot;);                int a= 100;                int b= 200;                return  a+b;            &#125;        &#125;);        Thread t = new Thread(task);        t.start();                //这里是main方法，这里在主线当众。        //在主线程中，怎么获取t线程的返回结果？//        Object obj = new Object();         Object obj = task.get();        System.out.println(&quot;线程执行结果：&quot;+obj);        System.out.println(&quot;hello world&quot;);    &#125;&#125;


关于Object类中的wait和notify方法（生产者和消费者模式！）
wait和notifu方法不是线程对象的方法，是java中任何一个对象都有的方法，因为这两个方式是Object类中自带的

wait()方法作用？
Object  o = new Object();
o.wait();
表示：让正在o对象上活动的线程进入等待状态，无期限等待，
直到被唤醒位置。
o.wait()方法的调用，会让“当前线程（正在o对象上活动的线程）”进入等待状态

notify()方法作用？
Object 0 = new Object();
o.notify();
表示：欢迎正在o对象上等待的线程。
还有一个notifyAll()方法：这个方法是唤醒o对象上处于等待的所有线程。

生产者和消费者程序实现！
package SelfTest;import java.util.ArrayList;import java.util.List;public class ThreadTest16 &#123;    public static void main(String[] args) &#123;        //创建一个仓库对象，共享的        List list = new ArrayList();        //创建两个线程对象        //生产者线程        Thread t1= new Thread(new Producer(list));        //消费者线程        Thread t2= new Thread(new Consumer(list));        t1.setName(&quot;生产者线程&quot;);        t2.setName(&quot;消费者线程&quot;);        t1.start();        t2.start();    &#125;&#125;//生产线程class Producer implements Runnable&#123;    private List list;    public Producer(List list) &#123;        this.list = list;    &#125;    @Override    public void run() &#123;//一直生产(用死循环模拟生产）        while(true)&#123;            //给仓库对象list枷锁            synchronized (list)&#123;                if(list.size()&gt;0)&#123;                    try &#123;                        //当前线程进入等待状态，并且释放Producer先前占有list集合的锁                        list.wait();                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                //程序能够执行到这里说明仓库是空的，可以生产                Object obj = new Object();                list.add(obj);                System.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+obj);                //唤醒消费者进行消费                try &#123;                    Thread.sleep(1000*2);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                list.notify();            &#125;        &#125;    &#125;&#125;//消费线程class Consumer implements Runnable&#123;    private List list;    public Consumer(List list) &#123;        this.list = list;    &#125;    @Override    public void run() &#123;//一直消费        while(true)&#123;            //给仓库对象list枷锁            synchronized (list)&#123;                if(list.size()==0)&#123;                    try &#123;                        //当前线程进入等待状态，并且释放list集合的锁                        list.wait();                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                //程序能够执行到次数说明仓库中有数据，进行消费                Object obj = list.remove(0);                System.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+obj);                //唤醒生产者生产                try &#123;                    Thread.sleep(1000*2);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                list.notify();            &#125;        &#125;    &#125;&#125;


反射机制
反射机制有什么用？
通过java语言中的反射机制可以操作字节码文件。
有点类似于黑客。（可以读和修改字节码文件。）
通过反射机制可以操作代码片段。（class文件。）

反射机制的相关类在哪个包下？
java.lang.reflect.*;

反射机制相关的重要的类有哪些？
java.lang.class代表整个字节码，代表一个类型，代表整个类
java.lang.reflect.Method代表字节码中的方法字节码，代表类中的方法
java.lang.class.Constructor代表字节码中的构造方法字节码，代表类中的构造方法
java.lang.class.Field代表字节码中的属性字节码， 代表类中的属性


要操作一个类的字节码，需要首先获取到这个类的字节码，怎么获取java.lang.Class实例？
Class c &#x3D; Class.forName(“完整类名带包名”)；
Class.forName()

静态方法
方法的参数是一个字符串
字符串需要的是一个完整的类名
完整类名必须带有包名。java.lang包也不能省略


Class c &#x3D; 对象.getClass();
java中任何一个对象都有一个方法：getClass()

Class c &#x3D; 任何类型.class
java语言中任何一种类型，包括基本数据类型，它都有.class属性


package ReflectTest;import java.util.Date;public class ReflectTest01 &#123;    public static void main(String[] args) &#123;        Class c1 = null;        Class c2 = null;        try &#123;            c1 =Class.forName(&quot;java.lang.String&quot;);            c2 = Class.forName(&quot;java.util.Date&quot;);            System.out.println(c1);//class java.lang.String        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;        //java中任何一个类对象都有一个方法：getClass()        String s = &quot;abc&quot;;        Class x = s.getClass();        System.out.println(x);//class java.lang.String        System.out.println(c1==x);//true        Date time = new Date();        Class y = time.getClass();        System.out.println(c2==y);//true        Class c = String.class;        System.out.println(c);//class java.lang.String    &#125;&#125;


获取到Class，能干什么？获取了Class之后，可以调用无参数构造方法来实例化对象
一定要注意：
newInstance()底层调用的是该类型的无参数构造方法。
如果没有这个无参数构造方法会出现异常
package ReflectTest;/*获取到Class。能干什么？    通过Class的newInstacne()方法来实例化对象。    注意：newInstance()方法内部实际上调用了无参构造方法，必须保证无参构造方法存在才可以 */public class ReflectTest02 &#123;    public static void main(String[] args) &#123;        try &#123;            //c代表的就是日期Date类型            Class c =Class.forName(&quot;ReflectTest.User&quot;);            //newInstance() 这个方法会调用User这个类的午餐构造方法，完成对象的创建			//实例化一个Date日期类型的对象            Object obj = c.newInstance();                        System.out.println(obj);        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (IllegalAccessException e) &#123;            e.printStackTrace();        &#125; catch (InstantiationException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;


验证反射机制的灵活性java代码写一遍，在不该表java源代码的基础上，可以做到不同对象的实例化。非常灵活（符合OCP开发原则，对扩展开放，对修改关闭）
package ReflectTest;import java.io.FileReader;import java.util.Properties;public class ReflectTest03 &#123;    public static void main(String[] args) throws Exception &#123;        //通过IO流读取classinfo.properties文件        FileReader reader = new FileReader(&quot;selfstudy\\src\\classinfo.proerties&quot;);        //创建属性类对象Map        Properties pro = new Properties();//key 和value都是String        //加载        pro.load(reader);        //关闭流        reader.close();        //通过key获取value        String classsName = pro.getProperty(&quot;className&quot;);        System.out.println(classsName);        //通过反射机制实例化        Class c =Class.forName(classsName);        Object obj = c.newInstance();        System.out.println(obj);    &#125;&#125;

以下文件是classinfo.properties
className=java.util.DateclassName1= ReflectTest.User


研究一下：Class.foeName()发生了什么？记住，重点：如果你只是希望一个类的静态代码块执行，其他代码一律不执行。
你可以使用Class.forName(“完整类名”);
这个方法的执行会导致类加载，类加载时，静态代码块执行。
package ReflectTest;public class ReflectTest04 &#123;    public static void main(String[] args) &#123;        try &#123;            Class.forName(&quot;ReflectTest.MyClass&quot;);        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;

package ReflectTest;public class MyClass &#123;    static &#123;        System.out.println(&quot;MyClass类的静态代码执行了！&quot;);    &#125;&#125;


研究一下文件路径的问题FileReader reader = new FileReader(&quot;xxx/xxx&quot;)

这个方式的路径缺点是：移植性差，在IDEA中默认的当前路径是project的根
这个代码假设离开了IDEA，换到了其他位置，可能当前路径就不是project的根了，这是这个路径就无效了



接下来说一种比较通用的路径

注意：使用以下通用方式的前提是：这个文件必须在类路径下，换句话说就是放在src下面

什么是类路径下？就是在src下的都是类路径下。

src是类的根路径
Thread.currentThread().getContextClassLoader().getResource(&quot;    &quot;).getPath();

解释：
Threader.currentThread() 当前线程对象
getContextClassLoader() 是线程对象的方法，可以获取当前线程的类加载器对象。
getResource() 【获取资源】这是类加载器对象的方法，当前线程的类加载器默认从类的根路径下加载资源
String path =Thread.currentThread().getContextClassLoader().getResource(&quot;classinfo.properties&quot;).getPath(); 
System.out.println(path);

以下实操、
package SelfTest;import java.io.FileReader;import java.util.Properties;public class IoPropertiesTest &#123;    public static void main(String[] args) throws Exception &#123;        String path = Thread.currentThread().getContextClassLoader().getResource(&quot;classinfo.properties&quot;).getPath();        FileReader reader = new FileReader(path);        Properties pro = new Properties();        pro.load(reader);        reader.close();        //通过key获取value        String className = pro.getProperty(&quot;className&quot;);        System.out.println(className);    &#125;&#125;

使用流的方式直接返回
package SelfTest;import java.io.InputStream;import java.util.Properties;public class IoPropertiesTest &#123;    public static void main(String[] args) throws Exception &#123;       /* String path = Thread.currentThread().getContextClassLoader().getResource(&quot;classinfo.properties&quot;).getPath();        FileReader reader = new FileReader(path);*/        InputStream reader = Thread.currentThread().getContextClassLoader()                .getResourceAsStream(&quot;classinfo.properties&quot;);        Properties pro = new Properties();        pro.load(reader);        reader.close();        //通过key获取value        String className = pro.getProperty(&quot;className&quot;);        System.out.println(className);    &#125;&#125;

使用资源绑定器（最终！！！！）
java.util包下提供了一个资源绑定器，便于获取属性配置文件中的内容
使用以下这种方式的时候，属性配置文件xxx.properties必须放在类路径下
package SelfTest;import java.util.ResourceBundle;public class ResourceBundleTest &#123;    public static void main(String[] args) &#123;        //资源绑定器，只能绑定xxx.properties文件。并且这个文件必须在类路径下。文件的扩展名必须是properties        //并且写路径的时候，路径后面扩展名不能写        ResourceBundle bundle = ResourceBundle.getBundle(&quot;classinfo&quot;);        String className = bundle.getString(&quot;className&quot;);        System.out.println(className);    &#125;&#125;


获取field（了解一下）package ReflectTest;import java.lang.reflect.Field;import java.lang.reflect.Modifier;public class ReflectTest05 &#123;    public static void main(String[] args) throws Exception &#123;        //获取整个类        Class studentClass = Class.forName(&quot;ReflectTest.Student&quot;);        String className = studentClass.getName();        System.out.println(&quot;完整类名 &quot;+className);        String simpleName = studentClass.getSimpleName();        System.out.println(&quot;简类名 &quot;+simpleName);        //获取类中所有的Field        Field[] fields=studentClass.getFields();        System.out.println(fields.length);//1        //取出这个Field        Field f = fields[0];        System.out.println(f);//public int ReflectTest.Student.no        String fieldName = f.getName();        System.out.println(fieldName);//no        System.out.println(&quot;---------------------------------------&quot;);        //获取所有的Field        Field[] fs = studentClass.getDeclaredFields();        System.out.println(fs.length);        for (int i = 0; i &lt; fs.length ; i++) &#123;            System.out.println(fs[i].getName()+&quot;的类型是：&quot;+fs[i].getType());        &#125;        System.out.println(&quot;以下第二种遍历，使用SimpleName和getType获取类型&quot;);        for (Field field:fs             ) &#123;            int i = field.getModifiers();//返回修饰符的代号            String modifierString = Modifier.toString(i);//将代号转换成字符串            Class fieldType = field.getType();//获取完整类型            String simpleType = fieldType.getSimpleName();//获取类型的简化            String fName = field.getName();//字节名            System.out.println(modifierString+&quot; &quot;+simpleType+&quot;---&gt;&quot;+fName);        &#125;    &#125;&#125;/*另一种拿到修饰符字符串的方法：Modifier.toString(studentClass.getModifiers())*/

运行后会返回
完整类名 ReflectTest.Student简类名 Student1public int ReflectTest.Student.nono---------------------------------------4no的类型是：intname的类型是：class java.lang.Stringage的类型是：intsex的类型是：boolean以下第二种遍历，使用SimpleName和getType获取类型public int---&gt;noprivate String---&gt;nameprotected int---&gt;age boolean---&gt;sex


反编译Field（了解一下）给我一个class文件，能够拿到java源码
package ReflectTest;import java.lang.reflect.Field;import java.lang.reflect.Modifier;public class ReflectTest06 &#123;    public static void main(String[] args) throws ClassNotFoundException &#123;        //创建这个是为了拼接字符串        StringBuilder s = new StringBuilder();        Class studentClass = Class.forName(&quot;ReflectTest.Student&quot;);        s.append(Modifier.toString(studentClass.getModifiers())+&quot;class&quot;+studentClass.getSimpleName()+&quot;&#123;\n&quot;);        Field[] fields = studentClass.getDeclaredFields();        for (Field field:fields             ) &#123;            s.append(&quot;\t&quot;);//转义符：缩进            s.append(Modifier.toString(field.getModifiers()));            s.append(&quot; &quot;);            s.append(field.getType().getSimpleName());            s.append(&quot; &quot;);            s.append(field.getName());            s.append(&quot;;\n&quot;);        &#125;        s.append(&quot;&#125;&quot;);        System.out.println(s);    &#125;&#125;


通过反射机制访问对象属性package ReflectTest;import java.lang.reflect.Field;public class ReflectTest07 &#123;    public static void main(String[] args) throws Exception &#123;        //不使用反射机制，怎么去访问一个对象的属性呢？        Student s = new Student();        s.no=1111;//给属性赋值        System.out.println(s.no);//读属性值        //使用反射机制，怎么去访问一个对象的属性        Class studentClass = Class.forName(&quot;ReflectTest.Student&quot;);        Object obj = studentClass.newInstance();        //获取no属性（根据属性的名称来获取Field        Field noField = studentClass.getDeclaredField(&quot;no&quot;);        //给obj对象（Student对象）的no属性赋值        /*        虽然使用了反射机制，但是三要素还是缺一不可：            要素1.obj对象            要素2：no属性            要素3:2222值        注意：反射机制虽然让复杂了，但是为了“灵活，是值得的。         */        noField.set(obj,22222);//给obj对象的no属性赋值22222        //读取属性的值        //两个要素：获取obj对象no属性的值        System.out.println(noField.get(obj));        //可以反问私有属性吗？        Field nameField = studentClass.getDeclaredField(&quot;name&quot;);        //打破封装（反射机制的特点：打破封装（反射机制的特点）        //这样设置完后，在外部也可以反问private的        nameField.setAccessible(true);        //给name属性配置        nameField.set(obj,&quot;jackson&quot;);        //获取name属性的值        System.out.println(nameField.get(obj));    &#125;&#125;


可变长度参数（掌握)
int… args这就是可变长度参数
语法是：类型...  注意：一定是3个点


可变长度参数要求的参数个数是0~N
可变长度参数在参数列表中必须在最后一个位置上，而且可变长度参数只能有一个

package ReflectTest;public class ArgsTest &#123;    public static void main(String[] args) &#123;        m();        m(10);        m(10,20);        m2(100);        m2(200,&quot;abd&quot;,&quot;xyz&quot;);        m3(&quot;abd&quot;,&quot;def&quot;,&quot;wqeq&quot;);        String[] strs=&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;;        //也可以传一个数组进去        m3(strs);        m3(new String[]&#123;&quot;你&quot;,&quot;很&quot;,&quot;牛&quot;,&quot;蛙&quot;&#125;);//没必要        m3(&quot;你&quot;,&quot;很&quot;,&quot;牛&quot;,&quot;蛙&quot;);    &#125;    public static void m(int... args)&#123;        System.out.println(&quot;m方法执行了！&quot; );    &#125;    public static void m2(int a,String ... args)&#123;    &#125;    public static void m3(String...args)&#123;        //args有length属性，说明args是一个数组！        for (int i = 0; i &lt;args.length ; i++) &#123;            System.out.println(args[i]);        &#125;    &#125;&#125;


反射Method（了解内容）package ReflectTest;import java.lang.reflect.Method;import java.lang.reflect.Modifier;public class ReflectTest08 &#123;    public static void main(String[] args) throws ClassNotFoundException &#123;        //获取类        Class userServiesClass = Class.forName(&quot;ReflectTest.UserService&quot;);        //获取所有的Method        Method[] methods= userServiesClass.getDeclaredMethods();//        System.out.println(methods.length);//2        for(Method method:methods)&#123;            //获取修饰符列表            System.out.println(Modifier.toString(method.getModifiers()));            //获取方法的返回值类型            System.out.println(method.getReturnType().getSimpleName());            //获取方法名            System.out.println(method.getName());            //方法的参数列表（一个方法的参数可能会有多个            Class[] parameterTypes=method.getParameterTypes();            for (Class cla:parameterTypes                 ) &#123;                System.out.println(cla.getSimpleName());            &#125;        &#125;    &#125;&#125;

反编译Method一个类的方法package ReflectTest;import java.lang.reflect.Method;import java.lang.reflect.Modifier;public class ReflectTest09 &#123;    public static void main(String[] args)throws Exception &#123;        StringBuilder s = new StringBuilder();        Class userServiceClass = Class.forName(&quot;ReflectTest.UserService&quot;);        s.append(Modifier.toString(userServiceClass.getModifiers())+&quot; class &quot;+userServiceClass.getSimpleName()+&quot;&#123;\n&quot;);        Method[] methods=userServiceClass.getDeclaredMethods();        for (Method method:methods             ) &#123;            System.out.println(&quot;\t&quot;);            s.append(Modifier.toString(method.getModifiers()));            s.append(&quot; &quot;);            s.append(method.getReturnType().getSimpleName());            s.append(&quot; &quot;);            s.append(method.getName());            s.append(&quot;(&quot;);            Class[] parameterTypes = method.getParameterTypes();            for (Class parameterType:parameterTypes                 ) &#123;                s.append(parameterType.getSimpleName());                s.append(&quot;,&quot;);            &#125;            s.deleteCharAt(s.length()-1);            s.append(&quot;)&#123;&#125;\n&quot;);        &#125;        s.append(&quot;&#125;&quot;);        System.out.println(s);    &#125;&#125;


重点：通过反射机制怎么调用一个对象的方法* * * * *反射机制，让代码很具有通用性，可变化的内容都是写到配置文件当中，将来修改配置文件之后，创建的对象不一样了，调用的方法不同了，但是java代码必须要做任何改动，这就是反射机制。
package ReflectTest;import java.lang.reflect.Method;public class ReflectTest10 &#123;    //使用反射机制来调用一个对象的方法怎么做？    public static void main(String[] args) throws Exception &#123;    Class userServiceClass = Class.forName(&quot;ReflectTest.UserService&quot;);    //创建对象    Object obj = userServiceClass.newInstance();    //获取Method    Method loginMethod = userServiceClass.getDeclaredMethod(&quot;login&quot;,String.class,String.class);        System.out.println(loginMethod);    //调用方法    /*    要素分析：    对象userService    login方法名    实参列表    返回值     */    //调用方法有几个要素，也需要4要素    Object retvalue = loginMethod.invoke(obj,&quot;admin&quot;,&quot;123&quot;);        System.out.println(retvalue);    &#125;&#125;



注：重点是ReflectTest07和10

反编译一个类的Constructor构造方法package ReflectTest;import java.lang.reflect.Constructor;import java.lang.reflect.Modifier;public class ReflectTest11 &#123;    public static void main(String[] args) throws Exception &#123;        StringBuilder s = new StringBuilder();        Class vipClass = Class.forName(&quot;ReflectTest.Vip&quot;);        s.append(Modifier.toString(vipClass.getModifiers()));//public        s.append(&quot; class &quot;);        s.append(vipClass.getSimpleName());//vip        s.append(&quot;&#123;\n&quot;);        //拼接构造方法        Constructor[] constructors = vipClass.getDeclaredConstructors();//获取所有构造方法                for(Constructor constructor:constructors)&#123;            s.append(&quot;\t&quot;);            s.append(Modifier.toString(constructor.getModifiers()));            s.append(&quot; &quot;);            s.append(vipClass.getSimpleName());            s.append(&quot;(&quot;);            //拼接参数            Class[] parameterTypes = constructor.getParameterTypes();//获取所有参数类型            for(Class parameterType:parameterTypes)&#123;                s.append(parameterType.getSimpleName());                s.append(&quot;,&quot;);            &#125;            //删除最后下标位置上的字符            if(parameterTypes.length&gt;0)&#123;                s.deleteCharAt(s.length()-1);            &#125;            s.append(&quot;)&#123;&#125;\n&quot;);        &#125;        s.append(&quot;&#125;&quot;);        System.out.println(s);    &#125;&#125;

运行结果
public ReflectTest.Vip(int)public ReflectTest.Vip(int,java.lang.String)public ReflectTest.Vip(int,java.lang.String,java.lang.String)public ReflectTest.Vip(int,java.lang.String,java.lang.String,boolean)public ReflectTest.Vip()public class Vip&#123;	public Vip(int)&#123;&#125;	public Vip(int,String)&#123;&#125;	public Vip(int,String,String)&#123;&#125;	public Vip(int,String,String,boolean)&#123;&#125;	public Vip()&#123;&#125;&#125;


通过反射机制new对象（比上一个例子重要一些）（但也不是重点）package ReflectTest;import java.lang.reflect.Constructor;import java.lang.reflect.Modifier;public class ReflectTest11 &#123;    public static void main(String[] args) throws Exception &#123;        StringBuilder s = new StringBuilder();        Class vipClass = Class.forName(&quot;ReflectTest.Vip&quot;);        s.append(Modifier.toString(vipClass.getModifiers()));//public        s.append(&quot; class &quot;);        s.append(vipClass.getSimpleName());//vip        s.append(&quot;&#123;\n&quot;);        //拼接构造方法        Constructor[] constructors = vipClass.getDeclaredConstructors();//获取所有构造方法        for(Constructor constructor:constructors)&#123;            s.append(&quot;\t&quot;);            s.append(Modifier.toString(constructor.getModifiers()));            s.append(&quot; &quot;);            s.append(vipClass.getSimpleName());            s.append(&quot;(&quot;);            //拼接参数            Class[] parameterTypes = constructor.getParameterTypes();//获取所有参数类型            for(Class parameterType:parameterTypes)&#123;                s.append(parameterType.getSimpleName());                s.append(&quot;,&quot;);            &#125;            //删除最后下标位置上的字符            if(parameterTypes.length&gt;0)&#123;                s.deleteCharAt(s.length()-1);            &#125;            s.append(&quot;)&#123;&#125;\n&quot;);        &#125;        s.append(&quot;&#125;&quot;);        System.out.println(s);    &#125;&#125;




获取父类和父接口package ReflectTest;public class ReflectTest13 &#123;    public static void main(String[] args)throws Exception &#123;        //String 举例        Class stringClass = Class.forName(&quot;java.lang.String&quot;);        //获取String的父类        Class superClass= stringClass.getSuperclass();        System.out.println(superClass.getName());        //获取String类实现的所有接口（一个类可以实现多个接口）        Class[] interfaces = stringClass.getInterfaces();        for (Class in: interfaces             ) &#123;            System.out.println(in.getName());        &#125;    &#125;&#125;


注解
又叫注释，英文单词是Annotation

注解Annotation是一种引用数据类型。编译之后也是生成xxx.class文件。

怎么自定义注解呢？语法格式：
[修饰符列表] @ interface 注解类型名{
}

注解怎么使用，用在什么地方？

注解使用时的语法格式是：
@注解类型名

注解可以出现在类上，属性上，方法上，变量上….注解还可以出现在注解类型上。



JDK中内置了有哪些注解呢？
java.lang包下的注释类型：

Deprecated用@Deprecated 注释的程序元素，不鼓励程序员使用这样的元素，通常是因为它很危险或存在更好的选择。
说明该类&#x2F;方法以过时，为了把这个信息传达出去，比如doOther（掌握）

Override 表示一个方法声明打算重写超类中的另一个方法声明。（掌握）

SuppressWarnings 只是应该在注释元素（以及包含在该注释元素中的所有程序元素）中取消显示只是的编译器警告。（不用掌握）



元注解
什么是元注解？
用来“标注”注解类型的“注解”,称为元注解

常见的元注解有哪些？
Target
Retention

关于Target注解：
这个一个元注解，用来标注“注解类型”的“注解”
这个Target注解用来标注“被标注的注解”可以出现在哪些位置上。


@Target(ElementType.METHOD):表示“被标注的注解只能出现在方法上

关于Retention注解
这个一个元注解，用来标注“注解类型”的“注解”
这个Retention注解用来标注“被标注的注解”最终保存在哪里。


@RetentionA(RetentionPolicy.SOURCE):表示该注解只能被保留在java源文件中。
@RetentionA(RetentionPolicy.CLASS):表示该注解被保存在class文件中。
@RetentionA(RetentionPolicy.RUNTIME):表示该注解被保存在class文件中，并且可以被反射机制所读取。



反射注解，获取注解里的属性值
有三个类

MyAnnotation.java【注解】
package ReflectAnnotationTest;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;//只允许注解可以标注类和方法@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)//希望这个注解可以被反射@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation &#123;    String value() default &quot;宁波江东区&quot;;    /*    username属性   */    String username();      String password();&#125;

MyAnnotationTest.java【里面包含注解的java类】
package ReflectAnnotationTest;  @MyAnnotation(username = &quot;admin&quot;,password = &quot;123&quot;)public class MyAnnotationTest &#123;        &#125;

ReflectAnnotation.java【用于测试】【所有需要了解的代码都在这里】
  package ReflectAnnotationTest;    public class ReflectAnnotation &#123;      public static void main(String[] args) throws Exception &#123;          Class c = Class.forName(&quot;ReflectAnnotationTest.MyAnnotationTest&quot;);            //判断类上面是否有@MyAnnotation  //        System.out.println(c.isAnnotationPresent(MyAnnotation.class));          if (c.isAnnotationPresent(MyAnnotation.class)) &#123;              //获取该注解对象              MyAnnotation myAnnotation = (MyAnnotation) c.getAnnotation(MyAnnotation.class);              System.out.println(&quot;类上面的注解对象&quot; + myAnnotation);              System.out.println(myAnnotation.username());              System.out.println(myAnnotation.password());                //获取注解对象的属性怎么办？和调接口没区别。              String value = myAnnotation.value();              System.out.println(value);        &#125;        &#125;&#125;




注解在开发中有什么用呢？需求：

假设有这丫昂的一个注解，叫做：@ID

这个注解只能出现在类上面，当这个类上有这个注解的时候要求这个类中必须有一个int类型的id属性，如果没有这个属性就报异常，如果有这个属性则正常执行！

答案

ID.java【注解】
  package AnnotationHomework;    import java.lang.annotation.ElementType;  import java.lang.annotation.Retention;  import java.lang.annotation.RetentionPolicy;  import java.lang.annotation.Target;  //表示这个注解只能出现在类上面  @Target(ElementType.TYPE)  //该注解可以被反射机制读取到@Retention(RetentionPolicy.RUNTIME)  public @interface ID &#123;  &#125;  //这个注解@ID用来标注类，被标注的类中必须又一个int类型的id属性，没有的话就报异常

User.java【定义类，要求有int类型的id属性】
package AnnotationHomework;@IDpublic class User &#123;  int id;    String name;  String password;&#125;

Test.java【测试类，使用了反射注解】
  package AnnotationHomework;    import java.lang.reflect.Field;    public class Test &#123;      public static void main(String[] args) throws Exception &#123;            //获取类          Class userClass = Class.forName(&quot;AnnotationHomework.User&quot;);          //判断类上是否存在ID注解          boolean isOk = false;          if(userClass.isAnnotationPresent(ID.class))&#123;              //当一个类上面有@ID注解的时候吗，要求类中必须存在int类型的id属性              //如果没有int类型的id属性则报异常              //获取类的属性              Field[] fields = userClass.getDeclaredFields();                for (Field field:fields)&#123;                  if (&quot;id&quot;.equals(field.getName())&amp;&amp;&quot;int&quot;.equals(field.getType().getSimpleName()))&#123;                      //表示这个类是合法的类。有@ID注解，则这个类必须有int类型的id                      isOk = true;                      break;                  &#125;              &#125;              if (!isOk)&#123;                throw new HasnotIDPropertyException(&quot;被@ID注解标注的类必须要有一个int类型的id属性！&quot;);              &#125;        &#125;      &#125;&#125;



AnnotationHomework.java【自定义异常类】
package AnnotationHomework;/*自定义异常 */public class HasnotIDPropertyException extends RuntimeException&#123;    public HasnotIDPropertyException()&#123;  &#125;    public HasnotIDPropertyException(String s)&#123;        super(s);    &#125;&#125;



]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用Docker，安装java调试环境的docker</title>
    <url>/2022/04/11/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Docker%EF%BC%8C%E5%AE%89%E8%A3%85java%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84docker/</url>
    <content><![CDATA[Docker的安装
查看系统的内核
[roo@www ~]$ uname -r3.10.0-1160.59.1.el7.x86_64


  .krkfnkvdkclu{width:70%}


   

查看系统配置
cat /etc/os-release


  .nvudmxkvoiws{width:70%}


   

卸载旧的版本
[root@www ~]# yum remove docker \                   docker-client \                   docker-client-latest \                   docker-common \                   docker-latest \                   docker-latest-logrotate \                   docker-logrotate \                   docker-engine


  .nueoumogemxv{width:70%}


   

下载需要的安装包
yum install -y yum-utils


  .eomfxeevautu{width:70%}


   

设置镜像的仓库
yum-config-manager \    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo  #国外的地址        # 设置阿里云的Docker镜像仓库yum-config-manager \    --add-repo \    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo  #国内的地址


  .ttlfoilzuvgm{width:70%}


   

更新yum软件包索引
yum makecache fast


  .elutffuszonr{width:70%}


   

安装docker相关的配置
docker-ce 是社区版，docker-ee 企业版
yum install docker-ce docker-ce-cli containerd.io


  .mkudatoiuqbe{width:70%}


   出现了completed即安装成功
   

启动Docker
systemctl start docker# 查看当前版本号，是否启动成功docker version# 设置开机自启动systemctl enable docker


  .zguxdklkthbb{width:70%}



hello-world
[root@www ~]# docker run hello-world


  .dfeuzbyiattm{width:70%}



查看一下下载的这个hello-world镜像
[root@www ~]# docker imagesREPOSITORY    TAG       IMAGE ID       CREATED        SIZEhello-world   latest    feb5d9fea6a5   6 months ago   13.3kB


构建自己的centos
在&#x2F;home目录下创建一个dockerfile目录，到时候所有东西就放这儿
[root@www /]# cd /home[root@www home]# lsceshi  docker-test-volume  hziee  mysql  roo[root@www home]# mkdir dockerfile[root@www home]# lsceshi  dockerfile  docker-test-volume  hziee  mysql  roo[root@www home]# cd dockerfile/[root@www dockerfile]# 


  .wqhflmqoagwl{width:70%}


   

创建一个名为mydockerfile-centos的文件，在里面编写DockerFile的指令
[root@www dockerfile]# vim mydockerfile-centos



编写dockerfile的配置文件
cat 指令表示查看mydockerfile-centos这个文件里面的内容，所以返回值就是配置文件的内容
[root@www dockerfile]# vim mydockerfile-centos [root@www dockerfile]# cat mydockerfile-centos FROM centos:7MAINTAINER lcdzzz&lt;1473220685@qq.com&gt;ENV MYPATH /usr/localWORKDIR $MYPATHRUN yum -y install vimRUN yum -y install net-toolsEXPOSE 80CMD echo $MYPATHCMD echo &quot;---end---&quot;CMD /bin/bash



通过这个文件构建镜像
#↓↓↓运行这个命令↓↓↓，注意有 “.”#命令 docker build -f dockerfile文件路径 -t 镜像名:[tag]docker build -f mydockerfile-centos -t mycentos:0.1 .


  .ezolgjhoxmma{width:70%}


   显示successfully代表成功

对比原生的centos


  .gckzopbqkywm{width:70%}



我们可以列出本地进行的变更历史 docker history 镜像id


  .vkxfblkmlsun{width:70%}



Dockerfile制作tomcat镜像
准备镜像文件tomcat压缩包，jdk压缩包


  .szueynicpicg{width:70%}


   

编写dockerfile文件，官方命名Dockerfile,build会自动寻找这个文件，就不需要 -f 去指定了
FROM centos:7MAINTAINER lcdzzz&lt;1473220685@qq.com&gt;COPY readme.txt /usr/local/readme.txtADD jdk-10.0.1_linux-x64_bin.tar.gz /usr/local/ADD apache-tomcat-9.0.62.tar.gz /usr/local/RUN yum -y install vimENV MYPATH /usr/localWORKDIR $MYPATHENV JAVA_HOME=/usr/local/jdk-10.0.1ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-9.0.62ENV CATALINA_BASE /usr/local/apache-tomcat-9.0.62ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/binEXPOSE 8080CMD /usr/local/apache-tomcat-9.0.62/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.62/bin/logs/catalina.out



构建镜像,前面说了，build会自动寻找文件，所以不需要指定
#docker build -t diytomcat .docker build -t diytomcat .

显示successfully代表成功



  .izdgorddtwoc{width:70%}


   

运行镜像
docker run -d -p 9090:8080 --name lcdzzztomcat -v /home/lcdzzz/build/test:/usr/local/apache-tomcat-9.0.62/webapps/test -v /home/lcdzzz/build/tomcatlogs/:/usr/local/apache-tomcat-9.0.62/logs diytomcat


  .bpxicvbmyewf{width:70%}


   

进入容器
docker exec -it 1d24f83eec24c5 /bin/bash



访问测试,在宿主机上测试，不是在容器里
curl localhost:9090



发布项目（由于做了卷挂载，我们直接在本地编写项目就可以发布了）
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app 	xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;	xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee 						http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; 	version=&quot;2.5&quot;&gt;&lt;/web-app&gt;


  .wgoxkloicyue{width:70%}


   

   &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;hello.lcdzzz&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello World!&lt;br/&gt;&lt;%System.out.println(&quot;---my test web logs---&quot;);%&gt;&lt;/body&gt;&lt;/html&gt;


  .pulqyicsuxsd{width:70%}


   

项目部署成功，直接访问就ok
先通过 ifconfig 查看虚拟机的ip地址



  .vgyedqqyuvsf{width:70%}


   访问

  .prbdkdiyvdjw{width:70%}



总结
通过dockerfile来构建Docker镜像


  .jcnlweqxskij{width:70%}


  


通过
docker build -t diytomcat .命令生成镜像


然后运行，进入容器


由于做了卷挂载，我们直接在本地编写项目就可以发布了



  .rugbmkwngwnp{width:70%}


  意思是容器中的&#x2F;usr&#x2F;local&#x2F;apache-tomcat-9.0.62&#x2F;webapps&#x2F;test下的文件会和宿主机（也就是虚拟机）的&#x2F;home&#x2F;lcdzzz&#x2F;build&#x2F;test的文件同步，对应的日志文件也同理
  


所以，如果要调试程序，在运行起容器以后，只需要在本地编写代码就可以发布项目了，如下图所示
日志的话会出现在主机下的 &#x2F;home&#x2F;lcdzzz&#x2F;build&#x2F;tomcatlogs下的catalina.out当中



  .jjkhqiwhymgj{width:70%}










]]></content>
      <tags>
        <tag>原创</tag>
        <tag>java</tag>
        <tag>docker</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>处理幂等性</title>
    <url>/2024/02/03/%E5%A4%84%E7%90%86%E5%B9%82%E7%AD%89%E6%80%A7/</url>
    <content><![CDATA[
代码地址
ruoyi脚手架是通过参数去判断：

把请求缓存起来到redis里面去【请求地址、请求参数…】
比如：请求地址和请求参数都是一样的话，10秒只能就拒绝重复提交

但这个方法存在一个问题：如果请求的参数是json，一旦我提取出来，将来在接口里面就提取不到了，所以我们先要把这个问题解决掉

**所需依赖：**springweb、redis、aop
&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;



请求参数格式问题io流（json）可能产生的问题复现io/github/lcdzzz/repeat_submit/interceptor/RepeatSubmitInterceptor.java
import org.springframework.stereotype.Component;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@Componentpublic class RepeatSubmitInterceptor implements HandlerInterceptor &#123;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        System.out.println(&quot;request.getReader().readLine() = &quot; + request.getReader().readLine());        return true;    &#125;    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;        HandlerInterceptor.super.postHandle(request, response, handler, modelAndView);    &#125;    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;        HandlerInterceptor.super.afterCompletion(request, response, handler, ex);    &#125;&#125;

io/github/lcdzzz/repeat_submit/config/webConfig.java
import io.github.lcdzzz.repeat_submit.interceptor.RepeatSubmitInterceptor;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class webConfig implements WebMvcConfigurer &#123;    @Autowired    RepeatSubmitInterceptor repeatSubmitInterceptor;    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        registry.addInterceptor(repeatSubmitInterceptor).addPathPatterns(&quot;/**&quot;);    &#125;&#125;

io/github/lcdzzz/repeat_submit/controller/HelloController.java
import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController &#123;    @PostMapping(&quot;/hello&quot;)    public String hello(@RequestBody String json)&#123;//@RequestBody底层也是通过io流实现的        return json;    &#125;&#125;



**【注】**访问&#x2F;hello时首先会被拦截器拦截，拦截器里面的request.getReader().readLine()与接口中的@RequestBody都是通过io流实现的，然而io流使用过一次以后数据就不存在了。所以会出现报错。

  .gyvvpumwvpeb{width:70%}



问题解决**解决思路：**用装饰者模式将HttpServletRequest重新处理一下
RepeatableReadRequestWrapper 类这个类是一个继承自 HttpServletRequestWrapper 的包装类。主要作用是：

在构造函数中，读取请求的输入流，并将其保存在 bytes 数组中。
重写 getReader() 和 getInputStream() 方法，返回一个新的 BufferedReader 和 ServletInputStream 实例，这两者都是用 bytes 数组来构造的。

实际上，这个类的目的是允许请求的输入流（请求体）能够被多次读取，因为默认情况下，Servlet的输入流只能读取一次。
io/github/lcdzzz/repeat_submit/request/RepeatableReadRequestWrapper.java
import javax.servlet.ReadListener;import javax.servlet.ServletInputStream;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import javax.servlet.http.HttpServletResponse;import java.io.*;public class RepeatableReadRequestWrapper extends HttpServletRequestWrapper &#123;    private final byte[] bytes;//把从io流拿出来的    public RepeatableReadRequestWrapper(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;        super(request);        request.setCharacterEncoding(&quot;UTF-8&quot;);        response.setCharacterEncoding(&quot;UTF-8&quot;);        bytes=request.getReader().readLine().getBytes();    &#125;    @Override    public BufferedReader getReader() throws IOException &#123;        return new BufferedReader((new InputStreamReader(getInputStream())));    &#125;    @Override    public ServletInputStream getInputStream() throws IOException &#123;        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        return new ServletInputStream() &#123;            @Override            public boolean isFinished() &#123;                return false;            &#125;            @Override            public boolean isReady() &#123;                return false;            &#125;            @Override            public void setReadListener(ReadListener readListener) &#123;            &#125;            @Override            public int read() throws IOException &#123;                return bais.read();            &#125;            @Override            public int available() throws IOException &#123;//整个数据的长度                return bytes.length;            &#125;        &#125;;    &#125;&#125;



RepeatableRequestFilter 类这个类是一个实现了 Filter 接口的过滤器。主要作用是：

检查请求的 Content-Type 是否以 “application&#x2F;json” 开头，如果是，就创建一个 RepeatableReadRequestWrapper 对象，并替换原始的 HttpServletRequest，以允许请求体的多次读取。
继续执行过滤器链，将请求和响应传递给下一个过滤器或目标 Servlet。

这个过滤器的作用是在请求为 JSON 格式时，将原始的请求对象替换为具有多次读取能力的包装类，从而防止在处理请求时由于读取请求体而导致的问题。
io/github/lcdzzz/repeat_submit/filter/RepeatableRequestFilter.java
import io.github.lcdzzz.repeat_submit.request.RepeatableReadRequestWrapper;import org.springframework.util.StringUtils;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class RepeatableRequestFilter implements Filter &#123;    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;        HttpServletRequest request = (HttpServletRequest) servletRequest;        //这通常用于在处理 HTTP 请求时，判断请求的数据格式是否为 JSON 格式        if (StringUtils.startsWithIgnoreCase(request.getContentType(),&quot;application/json&quot;))&#123;//StringUtils.startsWithIgnoreCase()以某个前缀开始的            RepeatableReadRequestWrapper requestWrapper = new RepeatableReadRequestWrapper(request, (HttpServletResponse) servletResponse);            filterChain.doFilter(requestWrapper,servletResponse);//也就是说如果请求时json格式的，那就来个偷梁换柱，换成装饰者模式处理之后的请求。使她可以重复读            return;        &#125;        filterChain.doFilter(servletRequest,servletResponse);    &#125;&#125;



webConfig 类这个类是一个Spring Boot的配置类，实现了 WebMvcConfigurer 接口。主要作用是：

注册一个自定义的拦截器 RepeatSubmitInterceptor，该拦截器用于防止表单重复提交。
注册一个自定义的过滤器 RepeatableRequestFilter，该过滤器用于处理重复请求。这里通过 FilterRegistrationBean 配置了过滤器的注册。

io/github/lcdzzz/repeat_submit/config/webConfig.java
import io.github.lcdzzz.repeat_submit.filter.RepeatableRequestFilter;import io.github.lcdzzz.repeat_submit.interceptor.RepeatSubmitInterceptor;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configuration//声明这是一个配置类，Spring会在启动时加载并处理它。public class webConfig implements WebMvcConfigurer &#123;//实现了 WebMvcConfigurer 接口，用于配置Spring MVC。    @Autowired    RepeatSubmitInterceptor repeatSubmitInterceptor;//使用Spring的依赖注入，注入一个 RepeatSubmitInterceptor 的实例。这个拦截器是用于防止表单重复提交的自定义拦截器。    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        //重写 addInterceptors 方法，向拦截器注册表中添加自定义的拦截器。这里注册了 RepeatSubmitInterceptor，并指定了拦截路径为 &quot;/**&quot;，即拦截所有请求。        registry.addInterceptor(repeatSubmitInterceptor).addPathPatterns(&quot;/**&quot;);    &#125;        //声明一个Bean，该Bean是 FilterRegistrationBean 类型的，用于注册过滤器。在这里，注册了一个 RepeatableRequestFilter 过滤器，并设置其拦截路径为 &quot;/*&quot;，即拦截所有请求。这个过滤器可能是用于处理重复请求的自定义过滤器。    @Bean    FilterRegistrationBean&lt;RepeatableRequestFilter&gt; repeatableRequestFilterFilterRegistrationBean()&#123;        FilterRegistrationBean&lt;RepeatableRequestFilter&gt; bean = new FilterRegistrationBean&lt;&gt;();        bean.setFilter(new RepeatableRequestFilter());        bean.addUrlPatterns(&quot;/*&quot;);//拦截所有请求        return bean;    &#125;&#125;

综合来看，这三段代码一起实现了一个防止重复提交的机制，在请求为 JSON 格式时，通过替换请求对象的方式，允许请求体的多次读取。同时，通过拦截器和过滤器的配置，使这个机制能够在整个应用中生效。

  .mjjdzmtpybcn{width:70%}


过滤器先执行，拦截器后执行。因为拦截器是servlet调用的，过滤器比servlet先执行。所以顺序应该是在过滤器中先把请求的格式切换过来。
对应ruoyi&#x2F;tienchin的实现tienchin-common/src/main/java/com/lcdzzz/common/filter/RepeatedlyRequestWrapper.java&#x3D;&#x3D;&#x3D;io/github/lcdzzz/repeat_submit/request/RepeatableReadRequestWrapper.java
tienchin-common/src/main/java/com/lcdzzz/common/filter/RepeatableFilter.java&#x3D;&#x3D;&#x3D;io/github/lcdzzz/repeat_submit/filter/RepeatableRequestFilter.java
tienchin-framework/src/main/java/com/lcdzzz/framework/config/FilterConfig.java&#x3D;&#x3D;&#x3D;io/github/lcdzzz/repeat_submit/config/webConfig.java

防止重复提交思路：把【你是谁、请求地址、请求参数…】存到redis里面去。
定义注解@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface RepeatSubmit &#123;    /**     * 两个请求之间的间隔时间     * @return     */    int interval() default 5000;    /**     * 重复提交时的提示文本     * @return     */    String message() default &quot;不允许重复提交，请稍后再试&quot;;&#125;

redis工具类@Componentpublic class RedisCahe &#123;    @Autowired    RedisTemplate redisTemplate;    public &lt;T&gt; void setRedisTemplate(final String key, final T value, Integer timeout, final TimeUnit timeUnit)&#123;        /**         * opsForValue() 方法，你可以获取一个用于操作字符串值的操作对象。然后，调用 set() 方法，将指定的键与值关联起来。         */        redisTemplate.opsForValue().set(key,value,timeout,timeUnit);    &#125;    public &lt;T&gt; T getCacheObject(final String key)&#123;        ValueOperations&lt;String,T&gt; valueOperations = redisTemplate.opsForValue();        return valueOperations.get(key);    &#125;&#125;

配置注解之前配置注解都是用aop的，这次试一试在拦截器地方配置
HandlerMethod： 会把我每定义的一个接口方法封装成一个对象。就是接口方法的各种信息【说属于哪个类的，方法泛型是什么，方法地址，方法参数，返回值…】又被分装成一个新的类，就叫HandlerMethod。
如果所有的像这样的接口方法，最终都会被封装成HandlerMethod。
@PostMapping(&quot;/hello&quot;)public String hello(@RequestBody String json)&#123;//@RequestBody底层也是通过io流实现的    return json;&#125;



RepeatSubmitInterceptor代码：
@Componentpublic class RepeatSubmitInterceptor implements HandlerInterceptor &#123;    public static final String REPEAT_PARAMS = &quot;repeat_params&quot;;    public static final String REPEAT_TIME = &quot;repeat_time&quot;;    public static final String REPEAT_SUBMIT_KEY = &quot;repeat_submit_key&quot;;    public static final String HEADER = &quot;Authorization&quot;;    @Autowired    RedisCahe redisCahe;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        if (handler instanceof HandlerMethod) &#123;            HandlerMethod handlerMethod = (HandlerMethod) handler;            Method method = handlerMethod.getMethod();            RepeatSubmit repeatSubmit = method.getAnnotation(RepeatSubmit.class);            if (repeatSubmit != null) &#123;//说明method上有这个注解，所以要请求校验判断是否重复                if (isRepeatSubmit(request, repeatSubmit)) &#123;//判断是否是重复提交                    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();                    map.put(&quot;status&quot;, 500);                    map.put(&quot;message&quot;, repeatSubmit.message());                    response.setContentType(&quot;application/json;charset=utf-8&quot;);                    response.getWriter().write(new ObjectMapper().writeValueAsString(map));                    return false;//拦截下来了                &#125;            &#125;        &#125;        return true;    &#125;    private boolean isRepeatSubmit(HttpServletRequest request, RepeatSubmit repeatSubmit) &#123;        String nowParams = &quot;&quot;;//请求参数字符串        if (request instanceof RepeatableReadRequestWrapper) &#123;            try &#123;                nowParams = ((RepeatableReadRequestWrapper) request).getReader().readLine();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;        //否则说明请求参数是key-value 格式的        if (StringUtils.isEmpty(nowParams)) &#123;            try &#123;                nowParams = new ObjectMapper().writeValueAsString(request.getParameterMap());            &#125; catch (JsonProcessingException e) &#123;                throw new RuntimeException(e);            &#125;        &#125;        Map&lt;String, Object&gt; nowDataMap = new HashMap&lt;&gt;();        nowDataMap.put(REPEAT_PARAMS, nowParams);        nowDataMap.put(REPEAT_TIME, System.currentTimeMillis());        String requestURI = request.getRequestURI();        String header = request.getHeader(HEADER);//用来提取出用户是谁        String cacheKey = REPEAT_SUBMIT_KEY + requestURI + header.replace(&quot;Bearer &quot;, &quot;&quot;);        Object cacheObject = redisCahe.getCacheObject(cacheKey);        if (cacheObject != null) &#123;            Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;) cacheObject;            if (compareParams(map, nowDataMap) &amp;&amp; compareTime(map, nowDataMap, repeatSubmit.interval())) &#123;                return true;            &#125;        &#125;        redisCahe.setRedisTemplate(cacheKey, nowDataMap, repeatSubmit.interval(), TimeUnit.MILLISECONDS);        return false;    &#125;    /**     * 判断是否重复提交，返回true就代表是重复提交     *     * @param map     * @param nowDataMap     * @param interval     * @return     */    private boolean compareTime(Map&lt;String, Object&gt; map, Map&lt;String, Object&gt; nowDataMap, int interval) &#123;        Long time1 = (Long) map.get(REPEAT_TIME);//redis里的时间        Long time2 = (Long) nowDataMap.get(REPEAT_TIME);//现在的时间        if ((time2 - time1) &lt; interval) &#123;            return true;        &#125;        return false;    &#125;    //比较参数是否一样    private boolean compareParams(Map&lt;String, Object&gt; map, Map&lt;String, Object&gt; nowDataMap) &#123;        String nowParams = (String) nowDataMap.get(REPEAT_PARAMS);        String dataParams = (String) map.get(REPEAT_PARAMS);        return nowParams.equals(dataParams);    &#125;    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;        HandlerInterceptor.super.postHandle(request, response, handler, modelAndView);    &#125;    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;        HandlerInterceptor.super.afterCompletion(request, response, handler, ex);    &#125;&#125;

解释：
这段代码是一个拦截器（Interceptor）中的一个方法
具体来说，这个方法用于在处理请求之前检查是否存在重复提交。它接收三个参数：

HttpServletRequest request：表示 HTTP 请求的对象，包含了客户端发送的请求信息。
HttpServletResponse response：表示 HTTP 响应的对象，用于向客户端发送响应信息。
Object handler：表示处理请求的处理器对象。

该方法首先判断handler是否是HandlerMethod类型的实例，这是因为处理请求的方法通常是通过HandlerMethod来表示的。如果是，则获取对应的方法对象Method。
接着，通过method.getAnnotation(RepeatSubmit.class)获取该方法上是否标注了RepeatSubmit注解。如果存在该注解，说明该方法需要进行重复提交的校验。
然后，调用isRepeatSubmit(request, repeatSubmit)方法来判断当前请求是否是重复提交。如果是重复提交，则返回一个错误响应，其中包括状态码和消息，并设置响应内容类型为 JSON 格式。
最后，如果不需要拦截该请求（即不是重复提交），则返回true，表示允许继续执行后续的请求处理；如果需要拦截该请求（即是重复提交），则返回false，表示不允许继续执行后续的请求处理。
测试在&#x2F;hello接口上添加@RepeatSubmit(interval = 10000)，表示两个请求之间的间隔时间是10秒

  .tlebncyrcqdi{width:70%}



  .vuwjlyhzyoeb{width:70%}




对标ruoyi拦截器：com/lcdzzz/framework/interceptor
 【问题】若是两个不一样的人来请求一个接口，同样有可能被拦截下来，但这其实是不合理的	但是在ruoyi这个项目里面是没关系的，因为它肯定有Header。
]]></content>
      <tags>
        <tag>tienchin</tag>
        <tag>幂等性</tag>
        <tag>ruoyi源码</tag>
        <tag>原创笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/2022/06/28/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[
线程*是程序中执行的线程。 Java虚拟机允许应用程序同时执行多个执行线程。
每个线程都有优先权。
创建一个新的执行线程有两种方法。 一个是将一个类声明为Thread的子类。 这个子类应该重写run类的方法Thread 。 然后可以分配并启动子类的实例。

继承Thread类简单示例//创建线程方式一：继承Thread类，重写run()方法，调用start开启线程//总结：注意，线程开启不一定立即执行，由cpu调度执行public class TestThread1 extends Thread &#123;    @Override    public void run() &#123;        //run方法线程体        for (int i = 0; i &lt; 20; i++) &#123;            System.out.println(&quot;我在看代码---&quot;+i);        &#125;    &#125;    public static void main(String[] args) &#123;        //main线程，主线程        //创建一个线程对象        TestThread1 testThread1 = new TestThread1();        //调用start()方法开启线程        testThread1.start();        for (int i = 0; i &lt; 20; i++) &#123;            System.out.println(&quot;我在学习多线程---&quot;+i);        &#125;    &#125;&#125;

现在网图maven导入工具类
&lt;dependency&gt;    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;    &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-beanutils&lt;/groupId&gt;    &lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt;    &lt;version&gt;1.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-codec&lt;/groupId&gt;    &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;    &lt;version&gt;1.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;    &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-lang&lt;/groupId&gt;    &lt;artifactId&gt;commons-lang&lt;/artifactId&gt;    &lt;version&gt;2.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-cli&lt;/groupId&gt;    &lt;artifactId&gt;commons-cli&lt;/artifactId&gt;    &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-collections&lt;/groupId&gt;    &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;    &lt;version&gt;3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-net&lt;/groupId&gt;    &lt;artifactId&gt;commons-net&lt;/artifactId&gt;    &lt;version&gt;3.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;    &lt;artifactId&gt;commons-math3&lt;/artifactId&gt;    &lt;version&gt;3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-validator&lt;/groupId&gt;    &lt;artifactId&gt;commons-validator&lt;/artifactId&gt;    &lt;version&gt;1.4.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-httpclient&lt;/groupId&gt;    &lt;artifactId&gt;commons-httpclient&lt;/artifactId&gt;    &lt;version&gt;3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-dbcp&lt;/groupId&gt;    &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;    &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-logging&lt;/groupId&gt;    &lt;artifactId&gt;commons-logging-api&lt;/artifactId&gt;    &lt;version&gt;1.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-pool&lt;/groupId&gt;    &lt;artifactId&gt;commons-pool&lt;/artifactId&gt;    &lt;version&gt;1.6&lt;/version&gt;&lt;/dependency&gt;



实现代码
package com.lcdzzz.demo01;//练习Thread，实现多线程同步下载图片import org.apache.commons.io.FileUtils;import java.io.File;import java.io.IOException;import java.net.URL;public class TestThread2 extends Thread&#123;    private String url;//网络图片地址    private String name;//保存的文件名    public TestThread2(String url,String name)&#123;        this.url=url;        this.name=name;    &#125;    //下载图片线程的执行体    @Override    public void run() &#123;        WebDownloader webDownloader = new WebDownloader();        webDownloader.downloader(url,name);        System.out.println(&quot;下载了文件名为&quot;+name);    &#125;    public static void main(String[] args) &#123;        TestThread2 t1 = new TestThread2(&quot;https://img0.baidu.com/it/u=3497851059,26175775&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPG?w=288&amp;h=285&quot;,&quot;1.jpg&quot;);        TestThread2 t2 = new TestThread2(&quot;https://img0.baidu.com/it/u=3497851059,26175775&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPG?w=288&amp;h=285&quot;,&quot;2.jpg&quot;);        TestThread2 t3 = new TestThread2(&quot;https://img0.baidu.com/it/u=3497851059,26175775&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPG?w=288&amp;h=285&quot;,&quot;3.jpg&quot;);        t1.start();        t2.start();        t3.start();    &#125;&#125;//下载器class WebDownloader&#123;    //下载方法    public void downloader(String url,String name)&#123;        try &#123;            FileUtils.copyURLToFile(new URL(url),new File(name));        &#125; catch (IOException e) &#123;            e.printStackTrace();            System.out.println(&quot;IO异常，downloader方法出现问题&quot;);        &#125;    &#125;&#125;

控制台输出结果
下载了文件名为3.jpg下载了文件名为2.jpg下载了文件名为1.jpg//线程不一定立即执行，cpu安排调度



]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>微人事项目笔记</title>
    <url>/2022/01/24/%E5%BE%AE%E4%BA%BA%E4%BA%8B%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[服务端菜单接口设计
实体类设计

菜单menu
package com.lcdzzz.demo.model;import java.io.Serializable;import java.util.List;public class Menu implements Serializable &#123;    private Integer id;    private String url;    private String path;    private String component;    private String name;    private String iconCls;    private Meta meta;    private Integer parentId;    private Boolean enabled;    private List&lt;Menu&gt; children;    private List&lt;Role&gt; roles;    public List&lt;Role&gt; getRoles() &#123;        return roles;    &#125;    public void setRoles(List&lt;Role&gt; roles) &#123;        this.roles = roles;    &#125;    public Meta getMeta() &#123;        return meta;    &#125;    public void setMeta(Meta meta) &#123;        this.meta = meta;    &#125;    public List&lt;Menu&gt; getChildren() &#123;        return children;    &#125;    public void setChildren(List&lt;Menu&gt; children) &#123;        this.children = children;    &#125;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getUrl() &#123;        return url;    &#125;    public void setUrl(String url) &#123;        this.url = url;    &#125;    public String getPath() &#123;        return path;    &#125;    public void setPath(String path) &#123;        this.path = path;    &#125;    public String getComponent() &#123;        return component;    &#125;    public void setComponent(String component) &#123;        this.component = component;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getIconCls() &#123;        return iconCls;    &#125;    public void setIconCls(String iconCls) &#123;        this.iconCls = iconCls;    &#125;    public Integer getParentId() &#123;        return parentId;    &#125;    public void setParentId(Integer parentId) &#123;        this.parentId = parentId;    &#125;    public Boolean getEnabled() &#123;        return enabled;    &#125;    public void setEnabled(Boolean enabled) &#123;        this.enabled = enabled;    &#125;&#125;



虽然menu表中有keepAlive和requiredAuth字段，但是一般这种“额外的数据”，会额外地放在一个meta实体类中
package com.lcdzzz.demo.model;public class Meta &#123;    private Boolean keepAlive;    private Boolean requireAuth;    public Boolean getKeepAlive() &#123;        return keepAlive;    &#125;    public void setKeepAlive(Boolean keepAlive) &#123;        this.keepAlive = keepAlive;    &#125;    public Boolean getRequireAuth() &#123;        return requireAuth;    &#125;    public void setRequireAuth(Boolean requireAuth) &#123;        this.requireAuth = requireAuth;    &#125;&#125;


创建一个controller去查询所需要的数据,SystemConfigController
@RestController@RequestMapping(&quot;/system/config&quot;)public class SystemConfigController &#123;    @Autowired    MenuService menuService;    @GetMapping(&quot;/menu&quot;)    public List&lt;Menu&gt; getMenusByHrId()&#123;        return menuService.getMenusByHrId();    &#125;&#125;



Service类，MenuService,先得到当前登录的用户对象，然后通过getId()来得到id值
@Servicepublic class MenuService &#123;    @Autowired    MenuMapper menuMapper;    public List&lt;Menu&gt; getMenusByHrId() &#123;        return  menuMapper.getMenusByHrId(((Hr) SecurityContextHolder.getContext().getAuthentication().getPrincipal()).getId());        /*这个Principal就是这个当前登录的用户对象*/    &#125;&#125;



所以MenuMapper接口中会有这么一个方法定义
List&lt;Menu&gt; getMenusByHrId(Integer hrid);

对应的xml文件里的sql语句
&lt;select id=&quot;getMenusByHrId&quot; resultMap=&quot;Menus2&quot;&gt;        select distinct m1.*,    m2.`id` as id2,    m2.`component` as component2,    m2.`enabled` as enabled2,    m2.`iconCls` as iconCls2,    m2.`keepAlive` as keepAlive2,    m2.`name` as name2,    m2.`parentId` as parentId2,    m2.`requireAuth` as requireAuth2,    m2.`path` as path2    from menu m1,menu m2,hr_role hrr,menu_role mr    where m1.`id`=m2.`parentId`    and hrr.`hrid`=#&#123;hrid&#125;    and hrr.`rid`=mr.`rid`    and mr.`mid`=m2.`id`    and m2.`enabled`=1    order by m1.`id`,m2.`id`&lt;/select&gt;

里面用到的resultMap有
&lt;resultMap id=&quot;Menus2&quot; type=&quot;com.lcdzzz.demo.model.Menu&quot; extends=&quot;BaseResultMap&quot;&gt;  &lt;collection property=&quot;children&quot; ofType=&quot;com.lcdzzz.demo.model.Menu&quot;&gt;    &lt;id column=&quot;id2&quot; property=&quot;id&quot; jdbcType=&quot;INTEGER&quot; /&gt;    &lt;result column=&quot;url2&quot; property=&quot;url&quot; jdbcType=&quot;VARCHAR&quot; /&gt;    &lt;result column=&quot;path2&quot; property=&quot;path&quot; jdbcType=&quot;VARCHAR&quot; /&gt;    &lt;result column=&quot;component2&quot; property=&quot;component&quot; jdbcType=&quot;VARCHAR&quot; /&gt;    &lt;result column=&quot;name2&quot; property=&quot;name&quot; jdbcType=&quot;VARCHAR&quot; /&gt;    &lt;result column=&quot;iconCls2&quot; property=&quot;iconCls&quot; jdbcType=&quot;VARCHAR&quot; /&gt;    &lt;result column=&quot;parentId2&quot; property=&quot;parentId&quot; jdbcType=&quot;INTEGER&quot; /&gt;    &lt;result column=&quot;enabled2&quot; property=&quot;enabled&quot; jdbcType=&quot;BIT&quot; /&gt;    &lt;association property=&quot;meta&quot; javaType=&quot;com.lcdzzz.demo.model.Meta&quot;&gt;      &lt;result column=&quot;keepAlive2&quot; property=&quot;keepAlive&quot; jdbcType=&quot;BIT&quot; /&gt;      &lt;result column=&quot;requireAuth2&quot; property=&quot;requireAuth&quot; jdbcType=&quot;BIT&quot; /&gt;    &lt;/association&gt;  &lt;/collection&gt;&lt;/resultMap&gt;    &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.lcdzzz.demo.model.Menu&quot;&gt;      &lt;id column=&quot;id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;id&quot;/&gt;      &lt;result column=&quot;url&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;url&quot;/&gt;      &lt;result column=&quot;path&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;path&quot;/&gt;      &lt;result column=&quot;component&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;component&quot;/&gt;      &lt;result column=&quot;name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;name&quot;/&gt;      &lt;result column=&quot;iconCls&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;iconCls&quot;/&gt;      &lt;result column=&quot;parentId&quot; jdbcType=&quot;INTEGER&quot; property=&quot;parentId&quot;/&gt;      &lt;result column=&quot;enabled&quot; jdbcType=&quot;BIT&quot; property=&quot;enabled&quot;/&gt;      &lt;association property=&quot;meta&quot; javaType=&quot;com.lcdzzz.demo.model.Meta&quot;&gt;          &lt;result column=&quot;keepAlive&quot; jdbcType=&quot;BIT&quot; property=&quot;keepAlive&quot;/&gt;          &lt;result column=&quot;requireAuth&quot; jdbcType=&quot;BIT&quot; property=&quot;requireAuth&quot;/&gt;      &lt;/association&gt;  &lt;/resultMap&gt;   

测试

登录




  .fwmlfdyuffbf{width:70%}



菜单


  .qkipcrahblmp{width:70%}



后端接口权限设计注：目前项目不需要用到，暂不学习
整体的判断过程
根据用户发送过来的url地址提取出来它需要的角色
判断当前用户是否具备相应的角色

代码实现
根据用户发送过来的url地址提取出来它需要的角色
实体类Menu，添加一个这个属性private List&lt;Role&gt; roles;  //意思是这个菜单项需要哪些角色才可以访问意思是这个菜单项需要哪些角色才可以访问




职位管理后端接口设计
实体类
public class Position implements Serializable &#123;    private Integer id;    private String name;    @JsonFormat(pattern = &quot;yyyy-MM-dd&quot;,timezone = &quot;Asia/Shanghai&quot;)    private Date createDate;    private Boolean enabled;    private static final long serialVersionUID = 1L;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public Date getCreateDate() &#123;        return createDate;    &#125;    public void setCreateDate(Date createDate) &#123;        this.createDate = createDate;    &#125;    public Boolean getEnabled() &#123;        return enabled;    &#125;    public void setEnabled(Boolean enabled) &#123;        this.enabled = enabled;    &#125;    @Override    public String toString() &#123;        StringBuilder sb = new StringBuilder();        sb.append(getClass().getSimpleName());        sb.append(&quot; [&quot;);        sb.append(&quot;Hash = &quot;).append(hashCode());        sb.append(&quot;, id=&quot;).append(id);        sb.append(&quot;, name=&quot;).append(name);        sb.append(&quot;, createDate=&quot;).append(createDate);        sb.append(&quot;, enabled=&quot;).append(enabled);        sb.append(&quot;, serialVersionUID=&quot;).append(serialVersionUID);        sb.append(&quot;]&quot;);        return sb.toString();    &#125;

controller.system.basic.PositionController（查询，添加，更新，删除）
@RestController@RequestMapping(&quot;/system/basic/pos&quot;)public class PositionController &#123;//职位管理    @Autowired    PositionService positionService;    @GetMapping(&quot;/&quot;)//查询接口    public List&lt;Position&gt; getAllPosition()&#123;        return positionService.getAllPosition();    &#125;    @PostMapping(&quot;/&quot;)    public RespBean addPosition(@RequestBody Position position)&#123;//@RequestBody主要用来接收前端传递给后端的json字符串中的数据的(请求体中的数据的);        if (positionService.addPosition(position)==1)&#123;            return RespBean.ok(&quot;添加成功！&quot;);        &#125;        return RespBean.error(&quot;添加失败！&quot;);    &#125;    @PutMapping(&quot;/&quot;)    public RespBean updatePosition(@RequestBody Position position)&#123;        if (positionService.updatePosition(position)==1)&#123;            return RespBean.ok(&quot;更新成功！&quot;);        &#125;        return RespBean.error(&quot;更新失败！&quot;);    &#125;    @DeleteMapping(&quot;/&#123;id&#125;&quot;)    public RespBean deletePositionById(@PathVariable Integer id)&#123;        if (positionService.deletePositionById(id)==1)&#123;            return RespBean.ok(&quot;删除成功！&quot;);        &#125;        return RespBean.error(&quot;删除失败！&quot;);    &#125;&#125;

与之对应的service层下的
@Servicepublic class PositionService &#123;    @Autowired    PositionMapper positionMapper;    public List&lt;Position&gt; getAllPosition() &#123;        return positionMapper.getAllPosition();//查询    &#125;    public Integer addPosition(Position position) &#123;        position.setEnabled(true);        position.setCreateDate(new Date());        return positionMapper.insert(position);//添加    &#125;    public Integer updatePosition(Position position) &#123;        return positionMapper.updateByPrimaryKeySelective(position);//更新    &#125;    public Integer deletePositionById(Integer id) &#123;        return positionMapper.deleteByPrimaryKey(id);//删除    &#125;&#125;

对应的mapper层下的PositionMapper接口
public interface PositionMapper &#123;    int deleteByPrimaryKey(Integer id);    int insert(Position record);    Position selectByPrimaryKey(Integer id);    List&lt;Position&gt; selectAll();    int updateByPrimaryKey(Position record);    int updateByPrimaryKeySelective(Position record);    List&lt;Position&gt; getAllPosition();&#125;

PositionMapper.xml下的代码大多数是可以mybatis逆向工程自动生成的，这里写自动生成以外的和需要注意的sql语句，关于mybatis逆向工程可以参考https://www.cnblogs.com/youcoding/p/14693096.html 这篇博客。
&lt;select id=&quot;getAllPosition&quot; resultMap=&quot;BaseResultMap&quot;&gt;  select * from position&lt;/select&gt;&lt;!--这个较之普通的updateByPrimaryKey语句，区别在于这个sql语句不需要所有字段都有，如果一个字段没有值，则默认为null--&gt;&lt;update id=&quot;updateByPrimaryKeySelective&quot; parameterType=&quot;com.lcdzzz.model.Position&quot; &gt;    update position    &lt;set &gt;      &lt;if test=&quot;name != null&quot; &gt;        name = #&#123;name,jdbcType=VARCHAR&#125;,      &lt;/if&gt;      &lt;if test=&quot;createDate != null&quot; &gt;        createDate = #&#123;createDate,jdbcType=TIMESTAMP&#125;,      &lt;/if&gt;      &lt;if test=&quot;enabled != null&quot; &gt;        enabled = #&#123;enabled,jdbcType=BIT&#125;,      &lt;/if&gt;    &lt;/set&gt;    where id = #&#123;id,jdbcType=INTEGER&#125;  &lt;/update&gt;

测试

登录不演示，和服务端菜单接口设计的登录是一样的

查询接口 http://localhost:8080/system/basic/pos/ 【get】





  .qvigqebkgfeq{width:70%}



添加接口 http://localhost:8080/system/basic/pos/ 【post】


  .nofwklwnxbip{width:70%}



更新接口 http://localhost:8080/system/basic/pos/ 【put】


  .zdvjuhpmrlkf{width:70%}



删除接口 http://localhost:8080/system/basic/pos/38 【delete】


  .dwtgkuqrspcm{width:70%}

   

批量删除

Controller层
@DeleteMapping(&quot;/&quot;)    public RespBean deletePositionByIds( Integer[] ids)&#123;        if (positionService.deletePositionByIds(ids)==ids.length)&#123;            return RespBean.ok(&quot;删除成功！&quot;);        &#125;        return RespBean.ok(&quot;删除失败！&quot;);    &#125;

service层
public Integer deletePositionByIds(Integer[] ids) &#123;       return positionMapper.deletePositionByIds(ids);   &#125;

mapper接口
Integer deletePositionByIds(@Param(&quot;ids&quot;) Integer[] ids);

xml文件
&lt;delete id=&quot;deletePositionByIds&quot;&gt;  delete from position where id in   &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt;    #&#123;id&#125;  &lt;/foreach&gt;&lt;/delete&gt;

测试





  .xizapchenmpd{width:70%}


   

   
员工管理数据分页及搜索
实体类，为了节省篇幅，getset方法就不放上去了（实际上有）
public class Employee implements Serializable &#123;    private Integer id;    private String name;    private String gender;    private Date birthday;    private String idCard;    private String wedlock;    private Integer nationId;    private String nativePlace;    private Integer politicId;    private String email;    private String phone;    private String address;    private Integer departmentId;    private Integer jobLevelId;    private Integer posId;    private String engageForm;    private String tiptopDegree;    private String specialty;    private String school;    private Date beginDate;    private String workState;    private String workID;    private Double contractTerm;    private Date conversionTime;    private Date notWorkDate;    private Date beginContract;    private Date endContract;    private Integer workAge;    private Nation nation;    private Politicsstatus politicsstatus;    private Department department;    private JobLevel jobLevel;    private Position position;

controller层
@RestController@RequestMapping(&quot;/emp/basic&quot;)public class EmpBasicController &#123;    @Autowired    EmployeeService employeeService;    @GetMapping(&quot;/&quot;)    public RespPageBean getEmployeeByPage(@RequestParam(defaultValue = &quot;1&quot;) Integer page,/*默认查询第一页，每页查询10个*/             @RequestParam(defaultValue = &quot;10&quot;) Integer size                                            ,String keyword)&#123;        return employeeService.getEmployeeByPage(page,size,keyword);    &#125;&#125;

service层
@Servicepublic class EmployeeService &#123;    @Autowired    EmployeeMapper employeeMapper;    public RespPageBean getEmployeeByPage(Integer page, Integer size, String keyword) &#123;        if (page != null &amp;&amp; size != null) &#123;            page = (page - 1) * size;        &#125;        List&lt;Employee&gt; data =employeeMapper.getEmployeeByPage(page,size,keyword);        Long total = employeeMapper.getTotal(keyword);        RespPageBean bean = new RespPageBean();        bean.setData(data);        bean.setTotal(total);        return bean;    &#125;&#125;

mapper接口
public interface EmployeeMapper &#123;    int deleteByPrimaryKey(Integer id);    int insert(Employee record);    Employee selectByPrimaryKey(Integer id);    List&lt;Employee&gt; selectAll();    int updateByPrimaryKey(Employee record);    List&lt;Employee&gt; getEmployeeByPage(@Param(&quot;page&quot;) Integer page, @Param(&quot;size&quot;) Integer size,@Param(&quot;keyword&quot;) String keyword);    Long getTotal(String keyword);&#125;

xml的sql语句
&lt;select id=&quot;getEmployeeByPage&quot; resultMap=&quot;AllEmployeeInfo&quot;&gt;  select e.*,p.`id` as pid,p.`name` as pname,n.`id` as nid,n.`name` as nname,d.`id` as did,d.`name` as  dname,j.`id` as jid,j.`name` as jname,pos.`id` as posid,pos.`name` as posname from employee e,nation  n,politicsstatus p,department d,joblevel j,position pos where e.`nationId`=n.`id` and e.`politicId`=p.`id` and  e.`departmentId`=d.`id` and e.`jobLevelId`=j.`id` and e.`posId`=pos.`id`      &lt;if test=&quot;keyword !=null and keyword!=&#x27;&#x27;&quot;&gt;          and e.name like concat(&#x27;%&#x27;,#&#123;keyword&#125;,&#x27;%&#x27;)      &lt;/if&gt;    limit #&#123;page&#125;,#&#123;size&#125;&lt;/select&gt;&lt;select id=&quot;getTotal&quot; resultType=&quot;java.lang.Long&quot;&gt;  select count(*) from employee  &lt;if test=&quot;keyword !=null and keyword!=&#x27;&#x27;&quot;&gt;    where name like concat(&#x27;%&#x27;,#&#123;keyword&#125;,&#x27;%&#x27;)  &lt;/if&gt;;&lt;/select&gt;

xml的resultMap定义
&lt;resultMap id=&quot;AllEmployeeInfo&quot; type=&quot;com.lcdzzz.model.Employee&quot; extends=&quot;BaseResultMap&quot;&gt;  &lt;association property=&quot;nation&quot; javaType=&quot;com.lcdzzz.model.Nation&quot;&gt;    &lt;id column=&quot;nid&quot; property=&quot;id&quot;/&gt;    &lt;result column=&quot;nname&quot; property=&quot;name&quot;/&gt;  &lt;/association&gt;  &lt;association property=&quot;politicsstatus&quot; javaType=&quot;com.lcdzzz.model.Politicsstatus&quot;&gt;    &lt;id column=&quot;pid&quot; property=&quot;id&quot;/&gt;    &lt;result column=&quot;pname&quot; property=&quot;name&quot;/&gt;  &lt;/association&gt;  &lt;association property=&quot;department&quot; javaType=&quot;com.lcdzzz.model.Department&quot;&gt;    &lt;id column=&quot;did&quot; property=&quot;id&quot;/&gt;    &lt;result column=&quot;dname&quot; property=&quot;name&quot;/&gt;  &lt;/association&gt;  &lt;association property=&quot;jobLevel&quot; javaType=&quot;com.lcdzzz.model.JobLevel&quot;&gt;    &lt;id column=&quot;jid&quot; property=&quot;id&quot;/&gt;    &lt;result column=&quot;jname&quot; property=&quot;name&quot;/&gt;  &lt;/association&gt;  &lt;association property=&quot;position&quot; javaType=&quot;com.lcdzzz.model.Position&quot;&gt;    &lt;id column=&quot;posid&quot; property=&quot;id&quot;/&gt;    &lt;result column=&quot;posname&quot; property=&quot;name&quot;/&gt;  &lt;/association&gt;&lt;/resultMap&gt;

分页测试



  .mwtuevbecljy{width:70%}



搜索＋分页测试


  .pecidpliehmv{width:70%}


   

   
   
   
   
搭建邮件服务以及消息中间件]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
        <tag>项目实战</tag>
      </tags>
  </entry>
  <entry>
    <title>点餐系统学习随记</title>
    <url>/2022/05/16/%E7%82%B9%E9%A4%90%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E9%9A%8F%E8%AE%B0/</url>
    <content><![CDATA[流程分析（小程序后端）
  .nnvmsrcauyco{width:70%}



  .icjoouwtcwli{width:70%}








下单模块在首页进行扫码，入桌，然后会跳转到buy页面，点击选好了，如果没有问题的话，则跳转到confirmOrder页面，点击最下面的总计xxx,弹窗出现。经过一系列判断和对数据的处理，向&#x2F;userOrder&#x2F;create接口发送请求，对应后端的WxOrderUtils的createOrder方法
me页面
me界面，点击注册用户，跳转到change界面
点击提交修改按钮，对数据进行处理后，向&#x2F;user&#x2F;save接口发送请求。对应后端的WxUserController

me页面，点击会员充值，跳转到vip页面
点击充值一、二年向&#x2F;user&#x2F;payVip接口发送请求，对应后端的WxUserController

在app.js里，通过向&#x2F;use,r&#x2F;getUserInfo接口发送请求，拿到用户的数据，对应后端的WxUserController

me界面，点击我的订单，跳转到myOrder页面
根据顶上的待上餐、已取消、待评价、已完成四个选项得到对应的orderStatus属性并请求&#x2F;userOrder&#x2F;listByStatus接口，对应后端的WxOrderController

在myOrder页面里，待上餐模块，点击催上餐，向&#x2F;userOrder&#x2F;cuidan接口发送请求，对应后端的WxOrderController

myOrder页面里，待评价模块，点击去评价，isShowComment变为true，跳出窗口，点击确认，对一系列数据进行处理后，对comment接口发送请求，对应后端CommentController

myOrder页面里，已完成模块，点击查看评价，跳转到mycomment页面，因为传过去的type为1，所以先显示“我的评价”
内容，通过导航栏可以切换成全部评价
全部评价同理，不赘述了，对应的后端都是CommentController，分别对应两个方法userCommentList和commentList

myOrder页面里，已取消模块同理。


排号模块取号
排号页面下，点击排小桌，传入值为0的type，并向&#x2F;paihao&#x2F;quhao接口发送请求


  .jdjfwwmlxisv{width:70%}

- /paihao/quhao接口对应后端的`WxPaihaoController`



查询我的排号
排号页面下，会首先执行getNum()方法查询排号
向&#x2F;paihao&#x2F;getNum接口发送请求，对应后端的WxPaihaoController
得到排号的VO类，包含大、小桌当前就位号码，当前客户的桌型和号

后端StringUtils.pathEquals相对equals来说，这个方法能避免空指针异常
java8特性 .stream()的使用https://blog.csdn.net/Hathwayoung/article/details/113514840
Collectors.toList()https://blog.csdn.net/L_fly_J/article/details/120099739
@EntityListeners(AuditingEntityListener.class)https://blog.csdn.net/XU906722/article/details/84778788?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-84778788-blog-91438971.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-84778788-blog-91438971.pc_relevant_default&amp;utm_relevant_index=2
BeanUtils.copyProperties()https://blog.csdn.net/dfshsdr/article/details/90513676
@Transactional数据库事务
bindingResult.getFieldError().getDefaultMessage())https://blog.csdn.net/qq78442761/article/details/99209359
T each : enumClass.getEnumConstants()JAVA 枚举详解(枚举基本使用高级用法枚举扩展)
https://blog.csdn.net/July_whj/article/details/88081010?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-88081010-blog-108746279.pc_relevant_antiscanv3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-88081010-blog-108746279.pc_relevant_antiscanv3&amp;utm_relevant_index=2
前端（小程序）e.currentTarget.datasethttps://blog.csdn.net/qq_41219586/article/details/103542804

  .mnlqlmnrdzvx{width:70%}








]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义多数据源</title>
    <url>/2022/06/18/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/</url>
    <content><![CDATA[
 项目地址

准备依赖：

Web

Spring Web


SQL

MyBatis Framework
MySQL Driver


关于@Retention注解作用可以看这个

@Target:注解的作用目标


配置文件
# 数据源配置spring:  datasource:    type: com.alibaba.druid.pool.DruidDataSource    driverClassName: com.mysql.cj.jdbc.Driver    ds:      # 主库数据源      master:        url: jdbc:mysql://localhost:3306/test01?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=true&amp;serverTimezone=GMT%2B8        username: root        password: wqeq      # 从库数据源      slave:        # 从数据源开关/默认关闭        url: jdbc:mysql://localhost:3306/test02?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=true&amp;serverTimezone=GMT%2B8        username: root        password: wqeq    # 初始连接数    initialSize: 5    # 最小连接池数量    minIdle: 10    # 最大连接池数量    maxActive: 20    # 配置获取连接等待超时的时间    maxWait: 60000    # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒    timeBetweenEvictionRunsMillis: 60000    # 配置一个连接在池中最小生存的时间，单位是毫秒    minEvictableIdleTimeMillis: 300000    # 配置一个连接在池中最大生存的时间，单位是毫秒    maxEvictableIdleTimeMillis: 900000    # 配置检测连接是否有效    validationQuery: SELECT 1 FROM DUAL    testWhileIdle: true    testOnBorrow: false    testOnReturn: false    webStatFilter:      enabled: true    statViewServlet:      enabled: true      # 设置白名单，不填则允许所有访问      allow:      url-pattern: /druid/*      # 控制台管理用户名和密码      login-username: tienchin      login-password: 123456    filter:      stat:        enabled: true        # 慢SQL记录        log-slow-sql: true        slow-sql-millis: 1000        merge-sql: true      wall:        config:          multi-statement-allow: true



步骤
自定义一个注解@DataSource,将来可以将该注解加service层在方法或者类上面，表示方法或者类中的所有方法都使用某一个数据源
对于第一步，如果某个方法上面有@DataSource注解，那么就将该方法需要使用的数据源名称存入ThreadLocal。
自定义切面，在切面中解析@DataSource注解的时候，将@DataSource注解所标记的数据源存入到ThreadLocal中。
最后，当Mapper执行的时候，需要DataSource，他会自动去AbstractRoutingDataSource类中查找需要的数据源，我们只需要在AbstractRoutingDataSource中返回ThreadLocal中的值

综上：用@DataSource注解，在一个方法或者一个类上面，去标注你想使用哪个数据源。然后将来在这个AOP(切面)里面解析这个注解，把想使用的数据源的名字找出来，存在ThreadLocal里面去。当以后真正需要用的时候，人家会自动的从AbstractRoutingDataSource里面去查找需要的数据源。
所以，我们要做的就是：重写（自己写一个类继承）AbstractRoutingDataSource，然后在它的方法里面去返回ThreadLocal里边所存储的数据源的名字。最后它会根据名字找到对应的数据源
步骤1：@DataSource自定义一个注解@DataSource,将来可以将该注解加service层在方法或者类上面，表示方法或者类中的所有方法都使用某一个数据源
import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)public @interface DataSource &#123;    String value();&#125;



步骤2：DynamicDataSourceContextHolder对于第一步，如果某个方法上面有@DataSource注解，那么就将该方法需要使用的数据源名称存入ThreadLocal。
/** * 这个类用来存储当前线程所使用的的数据源名称 */public class DynamicDataSourceContextHolder &#123;    private static ThreadLocal&lt;String&gt; CONTEXT_HOLDER = new ThreadLocal&lt;&gt;();    public static void setDataSourceType(String dsType)&#123;        CONTEXT_HOLDER.set(dsType);    &#125;    public static String getDataSourceType()&#123;        return CONTEXT_HOLDER.get();    &#125;    /**     * ThreadLocal里面的数据用完之后记得把它清空掉，不然这个线程去搞其他事情，就容易发生内存溢出【泄漏】     */    public static void clearDataSourceType()&#123;        CONTEXT_HOLDER.remove();    &#125;&#125;



步骤3：DataSourceAspect自定义切面，在切面中解析@DataSource注解的时候，将@DataSource注解所标记的数据源存入到ThreadLocal中。
用到了切面，自然需要引入AOP的依赖
&lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt;

【注】学习一下，如何拿到注解里的值
import com.lcdzzz.dd.annotation.DataSource;import com.lcdzzz.dd.datasource.DynamicDataSourceContextHolder;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;import org.aspectj.lang.reflect.MethodSignature;import org.springframework.core.annotation.AnnotationUtils;import org.springframework.stereotype.Component;@Component@Aspectpublic class DataSourceAspect &#123;    /**     * @annotation(com.lcdzzz.dd.annotation.DataSource) 表示如果方法上有@DataSource 注解，就把方法拦截下来     * @within(com.lcdzzz.dd.annotation.DataSource) 表示如果类上面有这个注解，那么就将类中的方法拦截下来     */    //定义切点    @Pointcut(&quot;@annotation(com.lcdzzz.dd.annotation.DataSource) || @within(com.lcdzzz.dd.annotation.DataSource)&quot;)    public void pc()&#123;    &#125;    //环绕通知    @Around(&quot;pc()&quot;)    public Object around(ProceedingJoinPoint pjp)&#123;        //获取方法上面的有效注解        DataSource dataSource=getDataSource(pjp);//获取自己的DataSource注解        if (dataSource!=null)&#123;            String value=dataSource.value();//获取注解里面数据源的名称            DynamicDataSourceContextHolder.setDataSourceType(value);        &#125;        try &#123;            return pjp.proceed();        &#125; catch (Throwable throwable) &#123;            throwable.printStackTrace();        &#125; finally &#123;            DynamicDataSourceContextHolder.clearDataSourceType();//数据源清除        &#125;        return null;    &#125;    //pjp里面有当前的方法的信息。核心思路：现在方法上面找，没有找到再到类上面找    private DataSource getDataSource(ProceedingJoinPoint pjp) &#123;        MethodSignature signature = (MethodSignature) pjp.getSignature();        //查找方法上的注解,AnnotationUtils是spring提供的注解操作工具类        DataSource annotation = AnnotationUtils.findAnnotation(signature.getMethod(), DataSource.class);        if (annotation!=null)&#123;//说明方法上有@DataSource注解            return annotation;        &#125;        //signature.getDeclaringType(),DataSource.class意思是获取这个方法所在的类的类型，然后看他上面有没有@DataSource注解        return AnnotationUtils.findAnnotation(signature.getDeclaringType(),DataSource.class);    &#125;&#125;



步骤4最后，当Mapper执行的时候，需要DataSource，他会自动去AbstractRoutingDataSource类中查找需要的数据源，我们只需要在AbstractRoutingDataSource中返回ThreadLocal中的值
DruidProperties@ConfigurationProperties(prefix =&quot;spring.datasource&quot; )//类型安全的属性注入public class DruidProperties &#123;    private String type;    private String driverClassName;    private Map&lt;String,Map&lt;String,String&gt;&gt; ds;    private Integer initialSize;    private Integer minIdle;    private Integer maxActive;    private Integer maxWait;    /**     * 一会在外部构造好一个 DruidDataSource 对象，但是这个对象只包含三个核心属性：url username password     * 在这个方法中，给这个对象设置公共属性     * @param druidDataSource     * @return     */    public DataSource dataSource(DruidDataSource druidDataSource)&#123;        druidDataSource.setInitialSize(initialSize);        druidDataSource.setMinIdle(minIdle);        druidDataSource.setMaxActive(maxActive);        druidDataSource.setMaxWait(maxWait);        return druidDataSource;    &#125;        /**    省略getset方法    */



LoadDataSource定义一个类去加载所有的数据源
@Component@EnableConfigurationProperties(DruidProperties.class)public class LoadDataSource &#123;    @Autowired    DruidProperties druidProperties;//需要用DruidProperties里面的ds属性    public Map&lt;String, DataSource&gt; loadAllDataSource()&#123;        Map&lt;String,DataSource&gt; map=new HashMap&lt;&gt;();        Map&lt;String, Map&lt;String, String&gt;&gt; ds = druidProperties.getDs();        try &#123;            Set&lt;String&gt; strings = ds.keySet();            for (String key : strings) &#123;//key是数据源的名字，value是数据源的各种信息                map.put(key, druidProperties.dataSource((DruidDataSource) DruidDataSourceFactory.createDataSource(ds.get(key))));//根据value创建一个数据源            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        return map;    &#125;&#125;



DynamicDataSource【核心！】当Mapper执行的时候，需要DataSource，他会自动去AbstractRoutingDataSource类中查找。这里继承的就是AbstractRoutingDataSource类
框架会调用determineCurrentLookupKey来获取数据源的名称，并且这个方法获取到的数据，会存到DynamicDataSourceContextHolder里面去。
因此，如果设计一个按钮，可以把DynamicDataSourceContextHolder里的数据修改了，就可以达到手动在网页上切换数据源的功能，请看一级标题：【手动实现网页上切换数据源】
@Componentpublic class DynamicDataSource extends AbstractRoutingDataSource &#123;    public DynamicDataSource(LoadDataSource loadDataSource) &#123;        //1.设置所有的数据源        Map&lt;String, DataSource&gt; allDs = loadDataSource.loadAllDataSource();        super.setTargetDataSources(new HashMap&lt;&gt;(allDs));        //2.设置默认的数据源        //将来，并不是所有的方法上都有@DataSource注解，对于那些没有@DataSource注解的方法，该使用哪个数据源        super.setDefaultTargetDataSource(allDs.get(DataSourceType.DEFAULT_DS_NAME));        //3.        super.afterPropertiesSet();    &#125;    /**     * 这个方法用来返回数据源名称，当系统需要获取数据源时，会自动调用该方法获取数据源的名称     * @return     */    @Override    protected Object determineCurrentLookupKey() &#123;        return DynamicDataSourceContextHolder.getDataSourceType();    &#125;&#125;

DataSourceType把默认的数据源名称设置为常量
public interface DataSourceType &#123;    String DEFAULT_DS_NAME=&quot;master&quot;;&#125;



测试实现准备两个数据源【方便起见就是两个数据库，名为test01和test02】

  .avhsggidhbtn{width:70%}


最后再测试类中使用测试，代码就是常见的mapper中写sql语句，serivce层调用，最后测试类使用service层的方法测试。
测试结果：不同名称的数据源，会查找对应不同的数据库，内容也有所不同
sql文件如下，意思意思
SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for user-- ----------------------------DROP TABLE IF EXISTS `user`;CREATE TABLE `user`  (  `id` int(0) NOT NULL,  `username` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,  `age` int(0) NULL DEFAULT NULL,  PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;-- ------------------------------ Records of user-- ----------------------------INSERT INTO `user` VALUES (1, &#x27;lcdzzz&#x27;, 22);SET FOREIGN_KEY_CHECKS = 1;





总结自定义数据源的使用分为两种情况
用@DataSource注解

@DataSource  没有参数，默认用下面定义的




  .ucudyhsrxvot{width:70%}



  .lfodwvqyqdom{width:70%}



@DataSource 有参数，就用改参数名字的数据源
@DataSource(&quot;slave&quot;)



  .srtvdbqqkqiv{width:70%}



不用@DataSource注解
默认使用master


不用@DataSource，和用了但是没有加参数，两者都是“默认”，但是在逻辑是有区别
不用@DataSource时，是在这里上默认的


  .hhhyziibsetw{width:70%}



  .anmbnymsftxn{width:70%}



用了但是没有加参数，是在这里上默认的


  .ydpzydymawmm{width:70%}



  .zknhelctabag{width:70%}


ps：idea 导出项目结构树：

输入命令： tree &gt;&gt; E:\workTreeTemp\tree.txt

ruoyi脚手架的写法
  .vwkmpfkpvlmu{width:70%}



  .ajqvbicayvom{width:70%}


联系如下

  .szykplwwzpjn{width:70%}


然后之前的写法是不用这样的，在步骤4中的DynamicDataSource中已经把所有的数据源读进来了【相比之下ruoyi写法没有这么灵活】
拓展：手动实现网页上切换数据源步骤1：controller.DataSourceControllersetDsType目的是打日志，真正有作用的是存在session里面的数据源名字
getAllUser为测试接口，测试数据源是否真的改变。方便起见，讲从数据库select出来的数据直接打印到控制台
package com.lcdzzz.dd.controller;import com.lcdzzz.dd.datasource.DataSourceType;import com.lcdzzz.dd.model.User;import com.lcdzzz.dd.service.UserService;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RestController;import javax.servlet.http.HttpSession;import java.util.List;@RestControllerpublic class DataSourceController &#123;    private static final Logger logger = LoggerFactory.getLogger(DataSourceController.class);    @Autowired    UserService userService;    /**     * 修改数据源     * @param dsType     */    @PostMapping(&quot;/dstype&quot;)    public void setDsType(String dsType, HttpSession session)&#123;//修改后存入session中去，与当前会话绑定，这样一来当前整个会话都可以统一使用这个数据源了        session.setAttribute(DataSourceType.DS_SESSION_KEY,dsType);        logger.info(&quot;数据源切换为 &#123;&#125;&quot;,dsType);    &#125;    @GetMapping(&quot;/users&quot;)    public List&lt;User&gt; getAllUser()&#123;        List&lt;User&gt; allUsers = userService.getAllUsers();        allUsers.forEach(System.out::println);        return allUsers;    &#125;&#125;

步骤2：aspect.GlobalDataSourceAspect.java和之前的DataSourceAspect一样，定义切面
【注】@Order值越小，优先级越高。但这里值得注意的是，优先级越低的，越后面执行；后面执行的，就能覆盖前面的。所以优先级越低的，才是最后真正起作用的那个。
这里定义的切点不是像之前的一样的在注解@DataSource上了。归根结底，手动实现网页上切换数据源关联的是一个service层的一个方法，所以切点应该设置如下。
环绕通知，拦截下来，设置最新（从session中）得到的数据源
package com.lcdzzz.dd.aspect;import com.lcdzzz.dd.datasource.DataSourceType;import com.lcdzzz.dd.datasource.DynamicDataSourceContextHolder;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.core.annotation.Order;import org.springframework.stereotype.Component;import javax.servlet.http.HttpSession;@Aspect@Component@Order(10)public class GlobalDataSourceAspect &#123;    @Autowired    HttpSession session;    @Pointcut(&quot;execution(* com.lcdzzz.dd.service.*.*(..))&quot;)    public void pc()&#123;    &#125;    @Around(&quot;pc()&quot;)    public Object around(ProceedingJoinPoint pjp)&#123;        //变化：原来从@DataSource注解里面找的，现在从session里面找了        DynamicDataSourceContextHolder.setDataSourceType((String) session.getAttribute(DataSourceType.DS_SESSION_KEY));        try &#123;            return pjp.proceed();//让被拦截的方法继续往下走        &#125; catch (Throwable throwable) &#123;            throwable.printStackTrace();        &#125; finally &#123;            DynamicDataSourceContextHolder.clearDataSourceType();        &#125;        return null;    &#125;&#125;

与此同时，为了让两种设置数据源的方法有合理的先后顺序,要在@DataSource直接上给11，在GlobalDataSourceAspect给10。达到的效果就是，全局，即先以全局手动设置的数据源为准，若某个service层的方法用了@DataSource注解，就以注解定义的为准
@Order(11)public class DataSourceAspect &#123;

步骤3：简单写一个网页loadData()是讲select出来的数据显示在网页上，但是不知道为什么我这里不行，应该是JSON转换的原因，不过这个不是本篇的重点，所以把它打印在控制台也行。
dsChange(value)是为了把选择的数据源名，打印出来。
&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script src=&quot;jquery-3.6.0.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;    请选择数据源    &lt;select name=&quot;&quot; id=&quot;&quot; onchange=&quot;dsChange(this.options[this.options.selectedIndex].value)&quot;&gt;&lt;!--this.options[]是个数组，                                                                                                【.value】是取值--&gt;        &lt;option value=&quot;请选择&quot;&gt;请选择&lt;/option&gt;        &lt;option value=&quot;master&quot;&gt;master&lt;/option&gt;        &lt;option value=&quot;slave&quot;&gt;slave&lt;/option&gt;    &lt;/select&gt;&lt;/div&gt;&lt;div id=&quot;result&quot; &gt;&lt;/div&gt;&lt;button onclick=&quot;loadData()&quot;&gt;加载数据&lt;/button&gt;&lt;script&gt;    function loadData()&#123;        $.get(&quot;/users&quot;,function (data)&#123;            $(&quot;#result&quot;).html(JSON.stringify(data));        &#125;)    &#125;    function dsChange(value) &#123;        $.post(&quot;/dstype&quot;,&#123;dsType:value&#125;)    &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;

用jQuery，这里就不放上来了，而且因为是简单的用，直接把文件复制过来即可。jQuery地址：https://code.jquery.com/jquery-3.6.0.js
目录结构：

  .rtzzjsckssqb{width:70%}




测试
  .bdtqoqvdapxk{width:70%}



  .periiqdsubfv{width:70%}



  .hyjwhhlofjye{width:70%}


]]></content>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
        <tag>sql</tag>
        <tag>项目实战</tag>
        <tag>tienchin</tag>
        <tag>ruoyi源码</tag>
        <tag>原创笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>纠错编码：海明码</title>
    <url>/2022/10/27/%E7%BA%A0%E9%94%99%E7%BC%96%E7%A0%81%EF%BC%9A%E6%B5%B7%E6%98%8E%E7%A0%81/</url>
    <content><![CDATA[
 分为4步

第一步 确认校验码位数r
  .qjmwdkngysww{width:70%}




第二步 确定校验码和数据的位置
为什么是10为数据位？因为4位校验码+6位信息位&#x3D;10位

校验码放到2的几次方的位置，其他的地方按顺序放已知的信息位



  .umxbhuoaonvf{width:70%}


第三步 求出校验码的值一
  .eziusntfuizz{width:70%}



数据位是1，那么二进制就是0001，至于二进制有几位，取决于最后一位数，比如这边最后一位是10，它的二进制为1010，四位，所以二进制需要四位



二
  .ljbwcqncsqkr{width:70%}


如何求校验码的值：
我们知道每一位校验位都可以校验几位数据，对于P1来说，它可以校验哪几位呢？

它数据所对应的2进制位 0001，”1”所在的位置是末尾，也就是第一位

那么我们就看接下来，还有哪些位的第一位是1，即D1,D2,D4,D5 
因此，P1的代码可以校验的数据就是P1,D1,D2,D4,D5

如何处理这几位数据呢？
只需要让所有的要校验的位异或为0，如上图


同理：

P2所对应的2进制位第2位是1，那么我们就去找谁的第2位是1，即D1,D3,D4,D6

因此，P2的代码可以校验的数据就是P2,D1,D3,D4,D6

以此类推…


以下为具体步骤

  .xtqtkymhrglm{width:70%}




第四步 检测并纠错
  .swcwcejmjsdl{width:70%}


↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓

  .wjnfqlhsoghz{width:70%}



假设在传输过程中发生了错误 ，第五位出错，由0变成1。
但是接收端是不知道哪一位发生错误的，所以需要找出错误的位，并把它纠正

其实步骤和刚才刚好相反
令所有要校验的位做异或运算
运算过程如下

  .reqfjttznklg{width:70%}


然后，从P4往P1写

  .ovxknyzfrxgg{width:70%}


最后得到出错的位数是5，即出错位是第5位，然后直接把出错的位数改正成它的反码，这里就是把1变成0
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义限流注解</title>
    <url>/2024/01/28/%E8%87%AA%E5%AE%9A%E4%B9%89%E9%99%90%E6%B5%81%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[
代码地址

依赖依赖：springweb、nosql的redis、aop
&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt;

application.properties：
spring.redis.host=localhostspring.redis.port=6379

准备工作step1：限流类型package com.lcdzzz.rate_limiter.enums;/** * 限流的类型 */public enum LimitType &#123;    /**     * 默认的限流策略，针对某一个接口进行限流     */    DEFAULT,    /**     * 针对某一个IP进行限流     */    IP&#125;

step2：定义注解package com.lcdzzz.rate_limiter.annotation;import com.lcdzzz.rate_limiter.enums.LimitType;public @interface RateLimiter &#123;    /**     * 限流的key，主要是指前缀     * @return     */    String key() default &quot;rate_limit&quot;;    /**     * 限流时间窗     * @return     */    int time() default 60;    /**     * 在时间窗内的限流次数     * @return     */    int count() default 100;    /**     * 限流类型     * @return     */    LimitType limitType() default LimitType.DEFAULT;&#125;

step3：配置redis原因因为待会去操作限流时需要lua表达式，所以先要对redis进行简单的配置

【问】
为什么要对redis进行配置？
【答】
在springDataRedis里面提供了两个我们可以直接操作redis的类：RedisTemplate、StringRedisTemplate 。
区别在于前者的key和value可以操作对象，而后者不可以是对象（只能是字符串）。
但是！虽然说RedisTemplate更方便，但是也存在问题。它的序列化方案是org.springframework.data.redis.serializer.JdkSerializationRedisSerializer。有兴趣深入了解的可以看https://cloud.tencent.com/developer/article/1863347 这篇博客。同时，想要用其他的序列化方式，也可以看这篇。
以下简单来说

假如我加入一个   key：xxx    value：good11

  .nbuprwqlxhqx{width:70%}


虽然在get时，如果依然用的是RedisTemplate，那它自己会帮忙转回去，但是如果用redis命令行去get xxx，那是行不通的。
办法所以！！！要修改的它的序列化方案，用JSON的，java代码如下
package com.lcdzzz.rate_limiter.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;@Configurationpublic class RedisConfig &#123;    @Bean    RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;        // 创建 RedisTemplate 对象        RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();        // 设置 RedisConnection 工厂。 它就是实现多种 Java Redis 客户端接入的秘密工厂        template.setConnectionFactory(redisConnectionFactory);        /**         * org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer         * 使用 Jackson 实现 JSON 的序列化方式，并且从 Generic 单词可以看出，是支持所有类。         */        //各种序列化的方案。实际线上场景，还是使用 JSON 序列化居多。        Jackson2JsonRedisSerializer&lt;Object&gt; serializer = new Jackson2JsonRedisSerializer&lt;&gt;(Object.class);        //设置key的序列化        template.setKeySerializer(serializer);        template.setHashKeySerializer(serializer);        //设置value的序列化        template.setValueSerializer(serializer);        template.setHashValueSerializer(serializer);        return template;    &#125;&#125;

step4：lua脚本
  .cmsdpjdobfhk{width:70%}





简说lua脚本
到时候会传入两个参数进来

传key：这个key就是一个list集合，就是可能传多个key进来
传多个参数进来，多个参数也是数组


--注意，这里的下标是从1开始的，而不是0。--以下的意思：一会把KEYS数组里面的第一项拿出来，交给key这个变量--tonumber是把字符串转成数字local key = KEYS[1]local time =tonumber(ARGV[1])local count=tonumber(ARGV[2])--[[当看到这行Lua脚本时，可以理解为它是用在Redis数据库上的脚本。让我们逐步解释这行代码：    1. local current: 这行声明了一个本地变量 current。        在Lua中，local 关键字用于声明局部变量，其作用范围仅限于当前代码块。    2. redis.call(&#x27;get&#x27;, key): 这是一个Redis命令，用于执行Redis数据库的GET操作。        具体来说，它是通过Lua脚本中的 redis.call 函数来调用Redis命令的。        在这里，&#x27;get&#x27; 是Redis的GET命令，而 key 是作为参数传递给GET命令的键。  所以，整体而言，这行代码的目的是从Redis数据库中获取键为 key 的值，  并将其存储在本地变量 current 中。在这之后，你可以通过对 current 变量的操作来处理从Redis中获取的值。  例如，你可能会检查是否成功获取了值，然后进行相应的逻辑处理。    ]]--这里的key，就是当前要限流的那一个接口，其存在redis里面的那个key，把它先拎出来，放进current变量中local current=redis.call(&#x27;get&#x27;,key)--但是如果这个key没有调用过，那么这个current没有值。比如第一次调用这个接口，那么current是会不存在的。所以下面还要做一个判断if current and tonumber(current)&gt;count then--[[意思是current存在，并且它的值大于count。说明已经超过限流的阈值了]]    return tonumber(current)end--[[否则就是current没有值，意味着是第一次访问]]current=redis.call(&#x27;incr&#x27;,key)--[[给current自增1。因为有可能存在并发操作，所以不能用set操作，用incr会更准确一些]]--但是在并发环境下，有可能另外一个操作也执行了current自增1的操作，所以以下需要判断，即如果对方已经设置过过期时间了，那我们就不需要多次一举了if tonumber(current)==1 then--[[等于1代表还没有其他的进程操作过current]]    redis.call(&#x27;expire&#x27;,key,time)--[[设置过期时间]]endreturn tonumber(current)--[[最后我们需要在java代码中看current的值，判断是否需要限流/放行]]



step5：加载lua脚本上一步写的lua脚本是需要加载的，springDataRedis中也为加载lua脚本提供了方法，只要定义一个bean就行了，如下 
package com.lcdzzz.rate_limiter.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.core.io.ClassPathResource;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.script.DefaultRedisScript;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import org.springframework.scripting.support.ResourceScriptSource;@Configurationpublic class RedisConfig &#123;    @Bean    RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;        // 创建 RedisTemplate 对象        RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();        // 设置 RedisConnection 工厂。 它就是实现多种 Java Redis 客户端接入的秘密工厂        template.setConnectionFactory(redisConnectionFactory);        /**         * org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer         * 使用 Jackson 实现 JSON 的序列化方式，并且从 Generic 单词可以看出，是支持所有类。         */        //各种序列化的方案。实际线上场景，还是使用 JSON 序列化居多。        Jackson2JsonRedisSerializer&lt;Object&gt; serializer = new Jackson2JsonRedisSerializer&lt;&gt;(Object.class);        //设置key的序列化        template.setKeySerializer(serializer);        template.setHashKeySerializer(serializer);        //设置value的序列化        template.setValueSerializer(serializer);        template.setHashValueSerializer(serializer);        return template;    &#125;    //这个bean是一个泛型，这里的泛型对应的是返回数据的类型    @Bean    DefaultRedisScript&lt;Long&gt; limitScript()&#123;        DefaultRedisScript&lt;Long&gt; script = new DefaultRedisScript&lt;&gt;();        script.setResultType(Long.class);//返回的类型        /*以下这行代码看起来是用于设置Lua脚本的源代码。让我们逐步解释：            1. new ClassPathResource(&quot;lua/limit.lua&quot;): 这部分创建了一个 ClassPathResource 对象，            该对象用于表示类路径下的资源。在这里，&quot;lua/limit.lua&quot; 是资源的路径，            这意味着要在类路径下找到名为 limit.lua 的Lua脚本文件。            2. new ResourceScriptSource(...): 这部分创建了一个 ResourceScriptSource 对象，            用于表示脚本的源代码来源。ResourceScriptSource 通常用于从文件、URL等资源加载脚本。            3. script.setScriptSource(...): 这部分应该是将创建好的脚本源代码对象设置到某个脚本对象中。            根据命名和上下文来看，可能是设置到一个名为 script 的Lua脚本对象中。        综合起来，这行代码的作用是将位于类路径下的 lua/limit.lua 文件的Lua脚本设置为某个脚本对象        （可能是 script）的源代码。这样做的目的是为了后续执行该脚本时能够使用该源代码。*/        script.setScriptSource(new ResourceScriptSource                (new ClassPathResource(&quot;lua/limit.lua&quot;)));/*告诉spring我的脚本搁哪呢*/        return script;    &#125;&#125;

step6：自定义异常@RestControllerAdvice 是Spring Framework中的注解，用于定义一个全局性的异常处理器（Global Exception Handler）。
在Spring应用中，@RestControllerAdvice 通常用于集中处理所有控制器（Controller）中抛出的异常。它的主要作用包括：

全局异常处理： 允许开发者定义一个全局的异常处理逻辑，捕获并处理整个应用中的异常，而不仅仅是在单个控制器中。这有助于提高代码的一致性和可维护性。
统一响应： 可以在全局异常处理器中定义统一的响应格式，使得应用的异常返回给客户端时具有一致的结构和格式。
异常日志记录： 可以在全局异常处理器中集中处理异常的日志记录，方便监控和排查问题。

一个简单的例子如下：
javaCopy code@RestControllerAdvicepublic class GlobalExceptionHandler &#123;    @ExceptionHandler(Exception.class)    public ResponseEntity&lt;String&gt; handleException(Exception e) &#123;        // 处理异常逻辑        // 可以返回自定义的错误信息        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(&quot;Internal Server Error&quot;);    &#125;    // 其他异常处理方法可以继续添加&#125;

在上述例子中，@ExceptionHandler 注解用于指定处理的异常类型，这里是 Exception.class，表示处理所有类型的异常。然后，定义了一个处理异常的方法 handleException，在这个方法中可以实现自定义的异常处理逻辑。在实际应用中，可以根据需要添加更多的 @ExceptionHandler 方法来处理不同类型的异常。
此项目中，全局异常处理如下：
package com.lcdzzz.rate_limiter.exception;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.RestControllerAdvice;import java.util.HashMap;import java.util.Map;@RestControllerAdvicepublic class GlobalException &#123;    @ExceptionHandler(RateLimitException.class)    public Map&lt;String,Object&gt; rateLimitException(RateLimitException e)&#123;        HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;status&quot;,500);        map.put(&quot;message&quot;,e.getMessage());        return map;    &#125;&#125;

自定义的异常如下：
package com.lcdzzz.rate_limiter.exception;public class RateLimitException extends Exception &#123;    public RateLimitException(String message) &#123;        super(message);    &#125;&#125;



至此准备工作算是完成了，接下来就可以去写切面，去解析注解

定义切面IpUtils请看：https://lcdzzz.github.io/2022/04/26/java-chang-yong-util-gong-ju-lei/
RateLimiterAspectpackage com.lcdzzz.rate_limiter.aspectj;import com.lcdzzz.rate_limiter.annotation.RateLimiter;import com.lcdzzz.rate_limiter.enums.LimitType;import com.lcdzzz.rate_limiter.exception.RateLimitException;import com.lcdzzz.rate_limiter.utils.IpUtils;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.reflect.MethodSignature;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.script.RedisScript;import org.springframework.stereotype.Component;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.context.request.ServletRequestAttributes;import java.lang.reflect.Method;import java.util.Collections;@Aspect@Componentpublic class RateLimiterAspect &#123;    private static final Logger logger = LoggerFactory.getLogger(RateLimiterAspect.class);    @Autowired    RedisTemplate&lt;Object, Object&gt; redisTemplate;    @Autowired    RedisScript&lt;Long&gt; redisScript;    //@Before 用于定义前置通知，即在目标方法执行前执行的代码。   /* &quot;@annotation(rateLimiter)&quot;: 这是一个切点表达式，它指定了在被 rateLimiter 注解标注的方法上执行切面逻辑。     @annotation 是一个用于匹配带有特定注解的方法的切点函数，     其中 rateLimiter 是一个注解的名字，用于匹配使用该注解的方法。*/    @Before(&quot;@annotation(rateLimiter)&quot;)//到时候加了@rateLimiter注解的方法，通通都会被洒家拦截下来    public void before(JoinPoint jp, RateLimiter rateLimiter) throws RateLimitException&#123;        int time = rateLimiter.time();        int count = rateLimiter.count();        String combineKey = getCombineKey(rateLimiter, jp);        //Collections.singletonList 是 Java 中 Collections 类提供的一个静态方法，用于创建包含单个元素的不可变列表（List）        try &#123;            Long number = redisTemplate.execute(redisScript, Collections.singletonList(combineKey), time, count);            //根据number的值去判断发生啥事了            if (number==null||number.intValue()&gt;count)&#123;                //超过阈值，需要限流                logger.info(&quot;当前接口以达到最大限流次数&quot;);                throw new RateLimitException(&quot;访问过于频繁，请稍后访问&quot;);            &#125;            logger.info(&quot;一个时间窗内请求次数:&#123;&#125;,当前请求次数:&#123;&#125;,缓存的key为&#123;&#125;&quot;,count,number,combineKey);        &#125; catch (Exception e) &#123;            throw e;        &#125;    &#125;    /**     * 这个key其实就是接口调用次数缓存在redis里面的key     * 如果基于ip限流，那combineKey就会形如：rate_limit:127.0.0.1-com.lcdzzz.rate_limiter.controller.HelloController-hello     * 如果不基于ip限流，那combineKey就会形如：rate_limit:com.lcdzzz.rate_limiter.controller.HelloController-hello     *     * @param rateLimiter     * @param jp     * @return     */    private String getCombineKey(RateLimiter rateLimiter, JoinPoint jp) &#123;        StringBuffer key = new StringBuffer(rateLimiter.key());        if (rateLimiter.limitType() == LimitType.IP) &#123;//意思是限流的类型是基于ip限流            key.append(IpUtils.getClientIp(((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest()))                    .append(&quot;-&quot;);        &#125;        MethodSignature signature = (MethodSignature) jp.getSignature();        Method method = signature.getMethod();        key.append(method.getDeclaringClass().getName())//返回声明方法的类的 Class 对象                .append(&quot;-&quot;)                .append(method.getName());        return key.toString();    &#125;&#125;



测试不限制ip地址controller层import com.lcdzzz.rate_limiter.annotation.RateLimiter;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;/** * @RestController 注解告诉 Spring 框架，这个类的每个方法的返回值都直接作为 HTTP 响应体返回给客户端， * 而不是通过视图解析器来解析成视图。因此，@RestController 通常用于构建 RESTful Web 服务， * 其中控制器的方法返回 JSON、XML 等数据格式而不是 HTML 视图。 */@RestControllerpublic class HelloController &#123;    @GetMapping(&quot;/hello&quot;)    /**     * 限流，10秒之内，这个接口可以访问三次     */    @RateLimiter(time = 10,count=3)    public String hello()&#123;        return &quot;hello&quot;;    &#125;&#125;

结果
  .llulwlpbvicm{width:70%}




限制ip地址controller层@RateLimiter(time = 10,count=3,limitType = LimitType.IP)public String hello()&#123;    return &quot;hello&quot;;&#125;

结果
  .fsqoijachpxt{width:70%}






对标tienchin&#x2F;ruoyi
tienchin-common/src/main/java/com/lcdzzz/common/annotation/RateLimiter.java 自定义注解

tienchin-common/src/main/java/com/lcdzzz/common/annotation/RateLimiter.java 切面，解析注解

tienchin-framework/src/main/java/com/lcdzzz/framework/config/RedisConfig.java 序列化+限流脚本
不同点：ruoyi是拼接字符串，而上面的方法是用lua脚本，但殊途同归


]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>tienchin</tag>
        <tag>ruoyi源码</tag>
        <tag>原创笔记</tag>
        <tag>序列化</tag>
        <tag>lua脚本</tag>
        <tag>全局异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 java “错误：编码GBK 的不可映射字符”</title>
    <url>/2021/07/04/%E8%A7%A3%E5%86%B3%20java%20%E2%80%9C%E9%94%99%E8%AF%AF%EF%BC%9A%E7%BC%96%E7%A0%81GBK%20%E7%9A%84%E4%B8%8D%E5%8F%AF%E6%98%A0%E5%B0%84%E5%AD%97%E7%AC%A6%E2%80%9D/</url>
    <content><![CDATA[解决 java “错误：编码GBK 的不可映射字符”
当java程序在idea上可以执行，但在cmd时报错：编码GBK 的不可映射字符时，通常都是因为GB2312编码的问题。

比如这个程序。在idea上运行时不会有问题的。用cmd运行时问题就出在第10行的int xd =0//向导数上，其中的“向导数”出了问题。


Scanner in = new Scanner(System.in);while (in.hasNext()) &#123;   int line = in.nextInt();    while (line-- &gt; 0) &#123;        int n = in.nextInt();//人数        int xd = 0;//向导数        int qx = n / 2;//抢险        int yl =(n-qx) *2 / 3;//医疗        int tx = n-qx - yl;//通讯        if (qx % 10 != 0) &#123;            xd = xd + qx / 10 + 1;        &#125; else &#123;            xd = xd + qx / 10;        &#125;        if (yl % 10 != 0) &#123;            xd = xd + yl / 10 + 1;        &#125; else &#123;            xd = xd + yl / 10;        &#125;        if (tx % 10 != 0) &#123;            xd = xd + tx / 10 + 1;        &#125; else &#123;            xd = xd + tx / 10;        &#125;        System.out.println(xd);    &#125;&#125;


解决方法

检查
查本机区域语言设置中文没有问题
需要把当前系统区域设置成中文（简体，中国）

在cmd中输入javac -encoding UTF-8 HelloWorlewww.java
其中  HelloWorlewww.java就是你需要运行的java程序

记事本打开java源文件，另存为选择ANSI编码


接下来重新用javac等操作编译，编译通过

说明：ANSI：美国国家标准协会，系统预设的标准文字储存格式。简体中文编码GB2312，实际上它是ＡＮＳＩ的一个代码页936
UTF-8：通用字集转换格式，这是为传输而设计的编码，2进制，以8位为单元对Unicode进行编码，如果使用只能在同类位元组内支持8个位元的重要资料一类的旧式传输媒体，可选择UTF-8格式。
在UTF-8里，英文字符仍然跟ASCII编码一样，因此原先的函数库可以继续使用。而中文的编码范围是在0080-07FF之间，因此是2个字节表示（但这两个字节和GB编码的两个字节是不同的），用专门的Unicode处理类可以对UTF编码进行处理。


]]></content>
      <categories>
        <category>解决的错误</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>java</tag>
        <tag>解决的错误</tag>
      </tags>
  </entry>
  <entry>
    <title>解决主机java项目无法连接linux上redis服务的问题</title>
    <url>/2022/01/20/%E8%A7%A3%E5%86%B3%E4%B8%BB%E6%9C%BAjava%E9%A1%B9%E7%9B%AE%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5linux%E4%B8%8Aredis%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[解决主机java项目无法连接linux上redis服务的问题
若远程主机需要访问redis服务器，可以修改redis.conf配置文件。如我的linux服务上的redis.config文件存放在 /usr/local/bin/zhouconfig下

bind字段默认为： bind 127.0.0.1 这样只能本机访问redis
若允许远程主机访问，可注释掉bind行  或者  将bind 127.0.0.1改为： bind 0.0.0.0



  .pdoktddzgtqo{width:70%}



.将protected-mod yes 修改为protected-mod no ；意思是将redis的保护模式关闭掉，这样可以供外部来访问redis访问


  .qgibqvqejurq{width:70%}



去服务器的控制台开启6379端口

]]></content>
      <categories>
        <category>解决的错误</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>redis</tag>
        <tag>解决的错误</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>谷粒商城学习记录</title>
    <url>/2022/12/18/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[微服务SpringCloud Alibaba-Nacos[作为配置中心]如何使用Nacos作为配置中心同意管理配置：
引入依赖
&lt;!--配置中心来做配置管理--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;&lt;/dependency&gt;

创建一个bootstrap.properties文件
spring.application.name=gulimall-couponspring.cloud.nacos.config.server-addr=127.0.0.1:8848



需要给配置中心默认添加一个叫数据集的(Data Id) gulimall-coupon.properties.。默认规则：应用名.properties



  .ynxhczfbkjyc{width:70%}



  .gpjupdlawlsl{width:70%}



给应用名.properties添加任何配置

动态获取配置
@RefreshScope//动态获取并刷新配置@Value(&quot;$&#123;coupon.user.name&#125;&quot;)//获取配置


  .wskokwoszvbl{width:70%}


   如果配置中心和当前应用的配置文件中都配置了相同的项，优先使用配置中心的配置
细节
命名空间:配置隔离;
默认: public(保留空间);默认新增的所有配置都在public空间。

开发，测试，生产:利用命名空间来做环境隔离。注意:在bootstrap.properties;配置上，需要使用哪个命名空间下的配置，spring,cloud,nacos,config,namespace&#x3D;67c0dde5-2912-4dd0-bd98-6d87307f5758
每一个微服务之间互相隔离配置，每一个微服务都创建自己的命名空间，只加载自己命名空间下的所有配置


配置集
所有配置的结合

配置集ID：类似文件名
Data ID:文件名

配置分组
默认所有的配置集都属于: DEFAULT GROUP;1111，618，1212每个微服务创建自己的命名空间，使用配置分组区分环境，dev，test，prod


同时加载多个配置集
微服务任何配置信息，任何配置文件都可以放在配置中心中

只需要在bootstrap.properties说明加载配置中心中哪些配置文件即可

@Value, @ConfigurationProperties。 
以前SpringBoot任何方法从配置文件中获取值，都能使用
配置中心有的优先使用配置中心中的



  .jqmkxfgejnyt{width:70%}



  .jcfxftlmpcvg{width:70%}




  .ebgnjlwqdmwp{width:70%}


]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>springsecurity</tag>
        <tag>项目实战</tag>
        <tag>springcloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>！（我太喜欢qt了）</title>
    <url>/2022/11/04/%EF%BC%81%EF%BC%88%E6%88%91%E5%A4%AA%E5%96%9C%E6%AC%A2qt%E4%BA%86%EF%BC%89/</url>
    <content><![CDATA[《这该死的qt》
最开始我看着老师给的word文档，那边mysql版本是8.0，我是5.7，那边qt版本是6.2.3，我是5.14.2。差别这么大？应该不能跟着做吧。

然后先看了看波波给的博客，四个人中，就我出现了问题，其他人都正确连通了。这个问题貌似是说，整个百度没有什么解决方法，好像是说1: error: cannot open output file F:\Git\plugins\sqldrivers\qsqlmysql.dll 有问题还是咋滴。可是qt和我自己装的Git有什么关系啊？

当时发现我的mysql版本是5.7，博客里的是5.5，我寻思着这版本差的不大吧？难道是qt的问题？

当时就准备重装下qt
前面的是前一天晚上花了一个多小时

到了第二天，我先重装了两遍qt，发现依然是同一个原因，于是继续百度找解决办法，弄着弄着，报错往我不可掌控的方向发展下去了，我眼看远走越远，准备换一条路。

既然mysql版本不匹配，那我重装下mysql吧

后来就把mysql5.7换成了mysql8

好吧，继续，还是有问题

这时候再看看老师给word



  .iesgjmwtoblf{width:70%}



当时觉得我俩的qt版本还是不一样，要不我手动编译去吧


  .ferxsydryecv{width:70%}



好家伙，用cmake编译一样出了奇奇怪怪的问题，上网差了查，发现基本上全是linux上的报错，好吧，看来这条路走不通

继续，现在摆在我面前的还有几条路，我慢慢的试

于是上网去找准备下一个6.2.3的版本，但是怎么找都找不到，就连老师发的课件里面



  .qtlyoqpfnhmd{width:70%}




真正弄下来也是6.2.4的版本，很奇怪，而6.2.4的版本进去，它的项目结构是这样的

  .vhjepzgoywpp{width:70%}


我寻思着和我这学期学的差别有点大呀，了解了下才知道是由于我创建的是一个基于CMake的项目，因此相应的项目文件名为CMakeLists.txt，而不是.pro文件。

好吧，看起来路又走远了

这一套流程走下来已经是晚上七点了
难道真的没有办法了吗，我得用学妹的电脑重新来一遍吗？
最后我愣着头皮按老师word里写的那样
牛头对着马头，牛腿对着马腿走了一遍流程

教程里说的是把编译文件复制到C:\Qt\6.2.3\mingw_64\plugins\sqldrivers里面去，我没有，我就复制到F:\QT\Qt5.14.2\5.14.2\mingw73_64\plugins\sqldrivers。
说复制到C:\Qt\6.2.3\mingw_64\bin，我没有，我就复制到F:\QT\Qt5.14.2\5.14.2\mingw73_64\bin里面。

然后直接运行，啥也没干
走通了

  .nzsjkmhwbxnp{width:70%}



  .shgoxnptzmpv{width:70%}



  .motncheqmgqm{width:70%}



  .egmhsrkmqmtk{width:70%}



  .mmccceusllum{width:70%}



  .ssjsdngmfjpu{width:70%}



  .bcmkehwkmczd{width:70%}






我* * * * * * * 的 * * * * 去 *
]]></content>
      <tags>
        <tag>吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title>工作流workflow</title>
    <url>/2022/10/01/%E5%B7%A5%E4%BD%9C%E6%B5%81/</url>
    <content><![CDATA[工作流workflow状态机解决流程问题工作流：一个可以处理复杂情况的状态机

例如，员工请假这个流程，首先员工请假提交申请，假设有项目经理进行审批，审批有两种结果：通过或者拒绝。

实现上面这个需求：

创建一张请假表，表中有员工id，请假的天数，请假的理由，项目经理的id，请假的状态status
当员工请假的时候，就自动向这张表中添加记录
然后，当项目经理登录到OA的时候，就来这张表查询自己需要的请假申请，查到之后，可以选择批准或者拒绝
接下来，员工登录之后，就可以查到自己的请假申请的审批结果

在这样的实现思路中，请假的流程我们是通过status这个字段控制的。例如：

status 0 代表待审批
1 代表审批通过
2 代表拒绝

上面这个例子，status就是状态码，通过这个子弹的值来控制流程的状态，这个方式我们可以称之为使用状态机来解决流程问题，但是这种思路只能解决非常简单的流程问题。
一些复杂的流程报销审批的流程
  .micqfjvpgggn{width:70%}




在这个流程中，已经没法使用status去描述这个报销走到哪一步了。如果非要用status，namestatus可能会有很多个取值 。

笔记本电脑生产流程
  .nqbredlmdozi{width:70%}


这个流程中不仅有串行任务还有并行任务,虽然技术上来说也能实现，但是如果用status字段去描述，实现起来会非常非常复杂。
三大工作流
Activiti:
侧重于云，即更靠拢spring cloud、docker、k8s等。

Camunada:
在这三个驻留的流程引擎这中，它是最轻量级的，如果我们的系统，当用户使用的过程中，需要动态的绘制流程图，那么可以使用它。这是一个小巧的工具，可以非常方便的嵌入到我们自己的系统中。它还提供了一个bpmn.js的工具，可以非常方便的实现流程图的绘制。

Flowable:

它目前的核心思路还是做一个功能非法从完善的流程引擎工具。除了常用的最最基本的工作流之外，Flowable还提供了很多扩展点。



流程图工作流执行的基础是流程图
一个完整的流程，要干嘛，先得画出来一个完整的流程图
上卖弄介绍了三种不同的工作流，那么三种不同的流程图绘制的方式是否一样？
其实，流程图的绘制，有一套统一的标准：BPMN（Business Process Model And Notation）,中文译为业务流程模型和标记法。
BPMN 就是一套图形化表示发，用图形来绘制、梳理业务流程模型。就是说，BPMN其实是一个非常古老的流程图规范，Activiti、Camunada、Flowable都是支持这个规范的，所以，无论使用哪一个流程图，都可以依照BPMN去绘制流程图。
虽然BPMN大家都支持，但是，在具体的使用细节上，不同的流程引擎还是有差别的。
BPMN流程图怎么画
  .flslkmvlsqec{width:70%}


从上图中，大致上可以归类出，流程分为：

事件
连线
任务
网关

事件开始事件、结束时间等等。

  .vfppeprxgtot{width:70%}


这是我们上面用到的时间，实际上，还有很多其他类型的事件。

  .qprldveawgki{width:70%}




连线
  .hpdbhsqmzrel{width:70%}


连接各个不同元素之间的线条，就是连线。
注意：线条之上，可能会有条件。例如，在互斥网关上，满足一定条件，流程图就继续往下走；不满足条件，流程图就回到之前的某一个位置。
任务在上面的流程图，所有的矩形，都是任务，但是任务还有许多细分。

用户任务
需要人工参与才能完成的工作建模。



  .grqjuusinyoo{width:70%}



服务任务
机器自动完成的事情，例如用户请假，经理审批通过后，想通过企业微信给用户发送一个通知，告诉他请假通过。这样的任务，就可以使用服务任务。
就是当流程走到这一步的时候，自动调用一个javabean，或者某一个远程服务去完成通知的发送，这是自动完成的，不需要人工介入。



  .mjsfuttsnpfq{width:70%}



活动
活动可以算是一个特殊的任务。活动之中，往往可以在活动中，调用另外一个流程使只作为当前流程的子流程去执行。活动一般又可以继续细分为用户活动、脚本活动等等。。。



  .jdtoqwitoeoq{width:70%}





接受任务
这个接受任务中，其实不需要做什么额外的事情，流程到这一步就自动停下来了，需要人工去助理一把，去推动流程继续向下走



  .cfxrngpdsrqx{width:70%}



发送任务
将消息发送给外部的参与者。



  .ifrcfxmuqqlu{width:70%}



脚本任务
一个自动化的活动，当流程执行到脚本任务的时候， 自动执行相应的脚本。



  .updikkcixedt{width:70%}



业务规则任务
BPMN2.0中引入的用来对接业务规则的引擎，业务规则主要用于同步执行一个或者多个规则。



  .bqrccmjlmiys{width:70%}



虽然这里分类比较多，但实际上，任务主要分两种：

用户任务：需要用户介入的任务。
服务任务：机器自动完成的任务。发送、接受、脚本等等任务，都是服务任务的细分。




网关
互斥网关
可以有多个入口，但只有一个有效出口。



  .pscessmfvkkm{width:70%}



并行网关 
并行网关一般是成对出现的，当有并行操作的时候，可以使用并行网关。



  .nbrxuoppgetj{width:70%}



相容网关
这种网关可能会存在多个有效的出口。



  .gnzbzmmuhaqm{width:70%}



事件网关
通过中间事件驱动的网关。当等待的事件触发之后，才会触发决策。



  .eeneeipjhtmi{width:70%}



流程图绘制IDEA 中有一个流程绘制插件 flowable-bpmn-visualizer
其他的绘制工具：

flowable-ui 这是官方提供的一个 flowable 的工具，里边有很多功能，包括画流程图。
bpmn.js 这个工具是 Camunda 提供的，可以嵌入到我们当前的项目中，利用这个 bpmn.js 可以开发一个流程绘制工具。原生的 bpmn.js 画出来的流程图只能在 Camunda 中使用，但是经过改造之后，就可以在 flowable 中使用了。

flowable-bpmn-visualizer插件安装：

  .vvcwjqcxuetq{width:70%}




装好之后重启 IDEA 即可。
在 IDEA 中，当我们安装了这个插件之后，新建文件文件的时候，就有相应的选项：

  .ovoqrbtjmgjb{width:70%}




选择这个就可以新建一个流程图了。

  .rggpkmzdvbfr{width:70%}




绘制关键节点：

  .reffuijormyr{width:70%}




注意，这里如果是传递变量需要用 ${} 表达式

  .gcoljvcdqrfl{width:70%}




如果是字符串，直接写即可，例如，这个节点由一个名为 javaboy 的用户来处理，那么写法如下：

  .qvkslshgsdbq{width:70%}




注意，从排他性网关出来的线条中，有一个 Condition expression，这个表示这个线条执行的条件。以下图为例，具体来说，就是当用户在审批的时候，本质上其实就是传递一个变量，变量值为 true 或者 false。下图中的 $&#123;approve&#125;表示这个变量的名字为 approve。

  .nnvdymjoqrtk{width:70%}




然后再来看发邮件的服务：
齿轮表示这是一个服务任务，也就是系统自动完成的，系统自动完成的方式有很多种，其中一种是提前将自己的业务逻辑在 Java 类中写好，然后这里配置一下类的完整路径即可。

  .fvicscwocchn{width:70%}




下图表示的是从网关出来之后，approve 变量如果为 false，那么就进入到请求被拒绝的服务中。

  .qrismnqhtitk{width:70%}



flowable-ui这个是 Flowable 官方推荐的一个流程引擎辅助工具。
安装有两种方式：
官方提供的是一个 war 包，这个虽然是一个 war 包，但是除了将之扔到 Tomcat 中去运行之外，也可以直接执行 java -jar xxx.war 这个命令去启动这个 war 包。
war 下载地址：https://github.com/flowable/flowable-engine/releases/download/flowable-6.7.2/flowable-6.7.2.zip.   这个 zip 包下载之后，里边有一个 wars 文件夹，里边包含了 flowable-ui 的 war 包。然后，就像启动 Spring Boot 一样，直接启动这个 war 包即可：
文件位置：

  .tenjypwsuyfg{width:70%}


启动命令：
java -jar flowable-ui.war


  .bgcmhcsltnaj{width:70%}


启动之后，默认的端口号是 8080。
启动之后，浏览器输入 http://localhost:8080/flowable-ui/idm/#/login.   如果看到如下页面，表示启动成功：

  .ntjwtbxmgcmf{width:70%}






另外，我们也可以使用 docker 来安装，命令如下：
docker run -p 8086:8080 -d  flowable/flowable-ui


  .eqjxlqfzsuci{width:70%}




最后访问http://localhost:8086/flowable-ui


登录默认的登录用户名是 admin，默认的登录密码是 test。
看到如下页面，表示登录成功。

  .uloyrvofijbl{width:70%}




功能模块flowable-ui 是完整的 flowable 体验 DEMO，而不仅仅只是一个流程图的绘制工具。所以它里边不仅可以画流程图，还可以运行流程图，既然能够运行流程图，那么就需要身份管理。

任务应用程序：我们绘制好的流程图，可以直接将之发布到一个应用中，然后在这里进行部署，这个模块其实就是这些部署的应用程序。
建模器应用程序：这个专门用来画流程图的。
管理员应用程序：这个主要用来管理应用，一些具有管理员权限的用户，可以通过这个功能模块去查询 BPMN、DMN、FORM 等等信息。
身份管理应用程序：这个功能模块，为所有的 flowable-ui 应用程序提供一个单点登录功能，并且还可以为这些用户设置用户组、用户权限等。

身份管理应用程序创建用户流程：

  .ndwhwyhxlyea{width:70%}


填入用户的基本信息，点击保存按钮，就可以完成用户的创建了。

  .fppuxshqbbyj{width:70%}


新建的用户不属于任何用户组，所以这个新建的用户是没有权限的，我们现在就可以使用这个新建的用户登录，但是登录成功后，看不到任何功能模块。
用户创建成功之后，可以点击上面的用户组功能，创建用户组：

  .lpttoahkvlka{width:70%}


将来我们在画流程图的时候，可以设置某一个 UserTask 由某一个用户组来处理，这个用户组中的所有用户，将来都可以处理这个 UserTask。
组创建成功之后，可以为这个组添加用户：

  .gnogubueldlo{width:70%}


最后，我们可以在权限控制中，为用户或者用户组添加相应的权限。

  .iuckhqtuaerg{width:70%}



访问 idm 应用：访问功能4.
访问 admin 应用：访问功能3。
访问 modeler 应用：访问功能2.
访问 workflow 应用：访问功能1.
访问 REST API：访问 REST API 接口的。



管理员应用程序
  .xuzelqpbalhg{width:70%}






建模器应用程序核心功能，主要就是画流程图。
绘制一个报销流程图，大致流程：

启动一个流程。

执行一个用户任务，这个用户任务交给流程的启动人去执行。这个用户任务中，填入报销材料，例如用户名、金额、用途。

系统自动判断一下&#x2F;或者人工判断报销金额是否大于 1000。

如果报销金额小于等于 1000，那么这个报销任务交给 组长审批：


组长审批通过，则流程结束。
组长审批不通过，则流程回到第 2 步，用户重新去填写报销资料。


如果报销金额大于 1000，那么这个报销任务先交给经理审批：


经理审批通过，则交给 CEO 审批：




CEO 审批通过，流程结束。
CEO 审批不通过，流程回到步骤 2 中。





经理审批不通过，则流程回到步骤 2 中。



绘制流程首先创建一个流程：

  .lmrjkvnrnysc{width:70%}


注意，模型的 key 在当前应用中必须是唯一的，将来我们通过 Java 代码去操作这个模型的时候，就是通过模型 key 去识别这个模型。
绘制出来的流程图：

  .rdvenhypcipv{width:70%}


注意，在一个流程图中，开始节点必须有且只有一个，结束节点可以有多个。
表单问题在流程中，传递流程参数有两种方式：

流程变量。
表单。

这两种方式都可以传递参数，区别在于，流程变量是零散的，而表单是整的。
对于通过表单传递的参数，我们也可以按照流程变量的方式去访问单个的表单参数，例如在上面的流程图中，我们有 $&#123;money &lt;= 1000&#125;，这里的 money 实际上是表单中的参数，但是我们可以直接通过 $ 表达式去访问。还有如 $&#123;managers_approve_or_reject_radio_button==&quot;拒绝&quot;&#125;，也是直接访问表单中的变量。
任务处理人对于一个 UserTask 而言，任务处理人有四种：

  .cmueootzhgnh{width:70%}



流程发起人，由流程的启动人&#x2F;发起人来处理这个流程。
单个用户，直接指定某一个具体的用户来处理这个流程，注意这里只能指定一个用户，并且这个用户将来在处理任务的时候，不需要认领，直接就可以处理。
候选用户：可以同时指定多个用户来处理这个 UserTask，将来用户在处理的时候，需要先认领（Claim）任务，然后才能处理。
候选组：可以同时指定多个用户组来处理这个 UserTask，这个处理的时候，也需要先认领，再处理。

基本概念
流程定义（ProcessDefinition）：我们绘制的流程图、流程的 XML 文件，就是我们的流程定义。
流程（ProcessInstance）：一个启动了流程实例就是一个流程，流程可以是已经执行完毕的，也可以是正在执行中的。流程的定义相当于是一个类，而流程则相当于是一个对象。
任务（Task）：一个 ProcessInstance 中，需要具体处理的节点就是一个任务。



任务应用程序在 flowable-ui 中，绘制好的流程图，可以直接部署称为一个 App。
Flowable 源码编译源码地址：https://github.com/flowable/flowable-engine编译的步骤：1clone 代码： git clone git@github.com:flowable&#x2F;flowable-engine.gi
2切换分支 git checkout -b origin&#x2F;6.7.2切换到 6.7.2 这个版本。
先来看下源码的目录结构：

LICENSE：开源协议

README.md：flowable 介绍文档。

distro：主要是保存了不同环境下的信息。

docker：将 flowable 构建成 docker 镜像的脚本。

docs：flowable 的文档。

ide-settings：这是如果想在 Eclipse 或者 IDEA 中快速使用 flowable 时候的配置。

k8s：flowable 支持 k8s 的一些脚本和配置。

modules：flowable 中所有的核心功能代码都在这个里边。

pom.xml：maven 的坐标文件。

qa：提供了很多各种各样的配置模版，例如如果我们需要在传统的 SSM 中配置 flowable，配置文件可以直接参考 qa 中的，但是我们现在主要是 Spring Boot 开发，在 Spring Boot 中，基本上用不到 qa 中的配置模版。

scripts：这个目录下放了常用的脚本文件。

tooling：这个目录中列出来了单元测试的模版。


项目编译要点：

用 IDEA 打开项目。在 IDEA 中，直接 open 源码即可，不需要 Import Project。

由于 IDEA 无法识别出所有的 Maven 工程，查看是否识别出来 Maven 工程的方式：（pom.xml 文件是蓝色的，或者工程名加粗了），如果有 IDEA 未识别出来的 Maven 工程，都需要挨个手动添加，添加方式就是打开项目的 pom.xml 文件，右键单击，选择 Add as Maven Project。

对于 Maven 工程，IDEA 会自动去下载所需要的依赖，但是由于这里需要下载的依赖比较多，所以下载的时候比较费时间，耐心等一下。最终也有可能会下载失败：i：先去本地 Maven 仓库，搜索以 .lastupdated结尾的文件，并删除。



  .bqyutipzffiq{width:70%}

   2. 然后再去项目中，重新导入依赖。

  .wdcpymycqkxs{width:70%}


ii：如果前面步骤不管用，那么就去 settings.xml 文件中，修改远程仓库地址，切换为 阿里云或者华为云等提供的镜像站，然后再重新导入。
&lt;mirrors&gt;  &lt;!-- mirror   | Specifies a repository mirror site to use instead of a given repository. The repository that   | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used   | for inheritance and direct lookup purposes, and must be unique across the set of mirrors.   |  &lt;mirror&gt;    &lt;id&gt;mirrorId&lt;/id&gt;    &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt;    &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt;    &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt;  &lt;/mirror&gt;   --&gt;    &lt;mirror&gt;    &lt;id&gt;alimaven&lt;/id&gt;    &lt;name&gt;aliyun maven&lt;/name&gt;    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;          &lt;/mirror&gt;&lt;/mirrors&gt;



H2 数据库
Java 编写的数据库。
可以基于内存来使用。
也可以基于文件，基于文件，类似于移动端的 Sqlite。

简单使用依赖
除去springboot的一些基本依赖外，还要有mysql驱动
 &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;        &lt;/dependency&gt; &lt;dependency&gt;            &lt;groupId&gt;org.flowable&lt;/groupId&gt;            &lt;artifactId&gt;flowable-spring-boot-starter&lt;/artifactId&gt;            &lt;version&gt;6.7.2&lt;/version&gt;        &lt;/dependency&gt;



配置
spring.datasource.username=rootspring.datasource.password=wqeqspring.datasource.url=jdbc:mysql:///flowable_idm?serverTimezone=Asia/Shanghai&amp;userSSL=false&amp;nullCatalogMeansCurrent=trueserver.port=8081logging.level.org.flowable=debug



用户操作事先准备号service类和log
/**    * IdentityService 专门负责和用户相关的操作，例如添加、删除、修改用户和用户组等    */   @Autowired   IdentityService identityService;   private static final Logger logger = LoggerFactory.getLogger(FlowableIdmApplicationTests.class);





增@Test   void test01() &#123;       //创建一个用户对象       UserEntityImpl user = new UserEntityImpl();       user.setId(&quot;lcdzzz&quot;);       user.setDisplayName(&quot;隆成&quot;);       user.setEmail(&quot;1473220685@qq.com&quot;);       user.setFirstName(&quot;mou&quot;);       user.setLastName(&quot;zhou&quot;);       user.setPassword(&quot;wqeq&quot;);       //注意：如果是添加用户，一定要加revision属性为0，表示当前用户是一个新的用户 而不是更新的用户       // flowable的用户表使用了乐观锁，而Revision字段其实就是配合乐观锁使用的       user.setRevision(0);       //保存一个用户       //这里是有两方面的功能       //1. 如果用户已经存在则更新       //2. 如果用户不存在则添加       identityService.saveUser(user);   &#125;



改/** * 更新用户信息 * &lt;p&gt; * saveUser方法可以用来更新用户信息，但是不可以用来更新密码 * 每更新一次，数据库的reversion会自增1 */@Testvoid contextLoads() &#123;    UserEntityImpl user = new UserEntityImpl();    user.setId(&quot;lcdzzz&quot;);    user.setDisplayName(&quot;隆成典周&quot;);    user.setEmail(&quot;6666@qq.com&quot;);    //注意 修改的时候 需要确保reversion的版本号和数据库的版本号保持一致    user.setRevision(2);    identityService.saveUser(user);&#125;

 

但是每次user.setRevision(2);是写死的，所以我们可以这么写
@Testvoid Test02() &#123;    User lcdzzz = identityService.createUserQuery().userId(&quot;lcdzzz&quot;).singleResult();    lcdzzz.setEmail(&quot;123321@qq.com&quot;);    identityService.saveUser(lcdzzz);&#125;



上面的方法无法连着密码一起更新，所以可以updateUserPassword
@Testvoid Test03() &#123;    User lcdzzz = identityService.createUserQuery().userId(&quot;lcdzzz&quot;).singleResult();    lcdzzz.setEmail(&quot;123321@qq.com&quot;);    lcdzzz.setPassword(&quot;888&quot;);    //修改用户密码需要调用updateUserPassword这个方法，而且这个方法也能修改用户的其他属性    identityService.updateUserPassword(lcdzzz);&#125;


删@Testvoid Test04() &#123;    identityService.deleteUser(&quot;lcdzzz&quot;);&#125;



查@Testvoid Test07() &#123;    List&lt;User&gt; email = identityService.createNativeUserQuery().sql(&quot;select * from ACT_ID_USER where EMAIL_=#&#123;email&#125;&quot;).parameter(&quot;email&quot;, &quot;javaboy@qq.com&quot;).list();    email.stream().forEach(i -&gt; logger.info(&quot;id:&#123;&#125;;display:&#123;&#125;&quot;, i.getId(), i.getDisplayName()));&#125;@Testvoid Test06() &#123;    //根据id排序，并查询所有用户    List&lt;User&gt; list = identityService.createUserQuery().orderByUserId().desc().list();    list.stream().forEach(i -&gt; logger.info(&quot;id:&#123;&#125;;display:&#123;&#125;&quot;, i.getId(), i.getDisplayName()));&#125;@Testvoid Test05() &#123;    List&lt;User&gt; list = identityService.createUserQuery().userDisplayName(&quot;%zhang%&quot;).list();    list.stream().forEach(i -&gt; logger.info(&quot;id:&#123;&#125;;display:&#123;&#125;&quot;, i.getId(), i.getDisplayName()));&#125;



用户组操作增/** * * 用户组操作的表是ACT_ID_GROUP * * 具体执行的SQL * * inserting: org.flowable.idm.engine.impl.persistence.entity.GroupEntityImpl@7bd694a5 * ==&gt;  Preparing: insert into ACT_ID_GROUP (ID_, REV_, NAME_, TYPE_) values ( ?, 1, ?, ? ) * ==&gt; Parameters: leader(String),  组长(String), null * &lt;==    Updates: 1 */@Testvoid Test08() &#123;    //添加用户组    GroupEntityImpl g =new GroupEntityImpl();    g.setName(&quot; 组长&quot;);    g.setId(&quot;leader&quot;);    //和用户一样 组的信息也使用了乐观锁 所以记得加revision    g.setRevision(0);    identityService.saveGroup(g);&#125;



删/** * 根据 ID删除一个group * * 对应SQL * *  ==&gt;  Preparing: delete from ACT_ID_MEMBERSHIP where GROUP_ID_ = ? *  ==&gt; Parameters: leader(String) *  &lt;==    Updates: 0 *  ==&gt;  Preparing: delete from ACT_ID_GROUP where ID_ = ? and REV_ = ? *  ==&gt; Parameters: leader(String), 1(Integer) *  &lt;==    Updates: 1 * *  为什么有两个删除sql？ * *  ACT_ID_MEMBERSHIP表保存的是 用户id和组id之间的关联关系。所以当删除一个用户组的时候，所以需要先删除组中的用户 * *  第二个就是删除具体的用户组 */@Testvoid Test09() &#123;   identityService.deleteGroup(&quot;leader&quot;);&#125;



改就是给用户组添加用户
/**    * 给用户组添加用户    *    * 对应的sql语句    *    * inserting: org.flowable.idm.engine.impl.persistence.entity.MembershipEntityImpl@5bba9949    * ==&gt;  Preparing: insert into ACT_ID_MEMBERSHIP (USER_ID_, GROUP_ID_) values ( ?, ? )    * ==&gt; Parameters: zhangsan(String), leader(String)    * &lt;==    Updates: 1    */   @Test   void Test10() &#123;       String groupId=&quot;leader&quot;;       String userId=&quot;zhangsan&quot;;       //添加用户和用户之间的关联关系       //注意 表的底层使用了外键 所以这里需要确保传递的参数都是真实存在的       identityService.createMembership(userId,groupId);   &#125;



修改用户组：将managers这个用户的name改成CEO
/**    * 修改用户组：将managers这个用户的name改成CEO    * &lt;p&gt;    * 跟之前user的更新一样，更新之前先查询，否则revision可能不对，会导致更新失败    * &lt;p&gt;    * sql语句：    * ==&gt;  Preparing: update ACT_ID_GROUP SET REV_ = ?, NAME_ = ?, TYPE_ = ? where ID_ = ? and    * ==&gt; Parameters: 2(Integer), CEO(String), null, managers(String), 1(Integer)    * &lt;==    Updates: 1    * &lt;p&gt;    * 这个sql中 我们可以看出乐观锁的具体使用方式，先查出来一个Group，revision为1 然后更新的时候将revision设置为2 ，    * 但是在更新条件中，revision还是使用1    * 这样我们更新的时候 就可以确保我们更新之前 这条记录没有被人更新过（如果被人更新过，则这条记录的revision就变成2了，本次更新就会失败）    */   @Test   void Test11() &#123;       //注意：更新之前先查询，因为上了乐观锁       Group managers = identityService.createGroupQuery().groupId(&quot;managers&quot;).singleResult();       managers.setName(&quot;CEO&quot;);       identityService.saveGroup(managers);   &#125;



查查询用户组：根据用户组名称去查询，注意的是，用户组名称不唯一
/** * 查询用户组：根据用户组名称去查询，注意的是，用户组名称不唯一 * &lt;p&gt; * 对应的SQL如下： * &lt;p&gt; * ==&gt;  Preparing: SELECT RES.* from ACT_ID_GROUP RES WHERE RES.NAME_ = ? order by RES.ID_ asc * ==&gt; Parameters: CEO(String) * &lt;==      Total: 1 */@Testvoid Test12() &#123;    List&lt;Group&gt; ceo = identityService.createGroupQuery().groupName(&quot;CEO&quot;).list();    for (Group group : ceo) &#123;        logger.info(&quot;id:&#123;&#125;,name:&#123;&#125;&quot;, group.getId(), group.getName());    &#125;&#125;



按照用户组的用户去查询  这个需要多表联合查询  下面案例  查询包含zhangsan这个用户的用户组
/**     * 按照用户组的用户去查询  这个需要多表联合查询  下面案例  查询包含zhangsan这个用户的用户组     * &lt;p&gt;     * 对应SQL     * &lt;p&gt;     * ==&gt; Preparing: SELECT RES.* from ACT_ID_GROUP RES WHERE exists(select 1 from ACT_ID_MEMBERSHIP M where M.GROUP_ID_ = RES.ID_ and M.USER_ID_ = ?) order by RES.ID_ asc     * ==&gt; Parameters: zhangsan(String)     * &lt;==       Total: 1     */    @Test    void Test13() &#123;        List&lt;Group&gt; list = identityService.createGroupQuery().groupMember(&quot;zhangsan&quot;).list();        for (Group group : list) &#123;            logger.info(&quot;id:&#123;&#125;,name:&#123;&#125;&quot;, group.getId(), group.getName());        &#125;    &#125;



自定义查询SQL
/**     * 自定义查询SQL     */    @Test    void Test14() &#123;        /**         * ==&gt;  Preparing: select * from ACT_ID_PROPERTY         * ==&gt; Parameters:         * &lt;==      Total: 1         */        List&lt;Group&gt; list = identityService.createNativeGroupQuery().sql(&quot;SELECT RES.* from ACT_ID_GROUP RES WHERE exists(select 1 from ACT_ID_MEMBERSHIP M where M.GROUP_ID_ = RES.ID_ and M.USER_ID_ = #&#123;userId&#125;) order by RES.ID_ asc&quot;).                parameter(&quot;userId&quot;, &quot;zhangsan&quot;).list();        for (Group group : list) &#123;            logger.info(&quot;id:&#123;&#125;,name:&#123;&#125;&quot;, group.getId(), group.getName());        &#125;    &#125;



查询系统信息或表信息等
@Test    void Test15() &#123;        //查询系统信息 本质上是查询ACT_ID_PROPERTY        Map&lt;String, String&gt; properties = idmManagementService.getProperties();        Set&lt;String&gt; key = properties.keySet();        for (String s : key) &#123;            logger.info(&quot;key:&#123;&#125;;value:&#123;&#125;&quot;,s,properties.get(s));        &#125;        //查询实体类对应的表名称        String tableName = idmManagementService.getTableName(Group.class);        logger.info(&quot;tableName:&#123;&#125;&quot;,tableName);        //获取表的详细信息        TableMetaData tableMetaData = idmManagementService.getTableMetaData(tableName);        logger.info(&quot;列名&#123;&#125;&quot;,tableMetaData.getColumnNames());        logger.info(&quot;列的类型&#123;&#125;&quot;,tableMetaData.getColumnTypes());        logger.info(&quot;表名&#123;&#125;&quot;,tableMetaData.getColumnTypes());    &#125;


流程定义与流程实例
流程定义在使用 flowable 的时候，我们首先需要画一个流程图，要在我们的代码中使用流程图，就必须先把流程图部署到项目中。加载到系统中的流程图，就是流程定义：ProcessDefinition。
流程实例我们启动的每一个具体的流程，就是一个流程实例 ProcessInstance。ProcessDefinition 相当于 Java 中的类，ProcessInstance 则相当于根据这个类创建出来的对象。

在 Flowable 中，所有跟流程部署相关的表，都是以 ACT_RE_前缀开始的。
流程定义 ProcessDefinition自动部署在 Spring Boot 中，凡是放在 resources&#x2F;processes 目录下的流程文件，默认情况下，都会被自动部署。
创建 Spring Boot 项目，添加 flowable 依赖，并配置 application.properties：
spring.datasource.username=rootspring.datasource.password=wqeqspring.datasource.url=jdbc:mysql:///flowable_process?serverTimezone=Asia/Shanghai&amp;useSSL=false&amp;nullCatalogMeansCurrent=truelogging.level.org.flowable=debug

任意绘制一个流程图，放到 resources&#x2F;processes 目录下：

  .ejnuupcllyce{width:70%}




启动 Spring Boot 项目，启动之后，这个流程就被自动部署了。
ACT_RE_DEPLOYMENT和 ACT_RE_PROCDEF分别保存了流程定义相关的信息。ACT_GE_BYTEARRAY表则保存了刚刚定义的流程的 XML 文件以及根据这个 XML 文件所自动生成的流程图。
三张表的关系：

ACT_RE_DEPLOYMENT和 ACT_RE_PROCDEF是一对一的关系。
ACT_RE_DEPLOYMENT和ACT_GE_BYTEARRAY是一对多的关系，一个流程部署 ID 对应两条ACT_GE_BYTEARRAY表中的记录（默认）。

流程 部署好之后，如果想要修改，可以直接修改，修改之后，流程会自动升级（数据库中的记录会自动更新）。
举个例子：

假设我们现在修改了流程定义的名字，然后重新启动 Spring Boot 项目，那么 ACT_RE_DEPLOYMENT 表中会增加一条部署记录，同时 ACT_RE_PROCDEF 表也会增加一条新的流程定义信息，新的流程信息中，该变的字段会自动变，同时版本号 VERSION_会自增 1。ACT_GE_BYTEARRAY 表中也会新增两条记录，和最新的版本号的定义相对应。

注意：流程图的更新，主要是以流程定义的 id 为依据，如果流程定义的内容发生变化，但是流程 id 没有变，则流程定义升级；如果流程图定义的 id 发生变化，则直接重新部署新的流程。


在流程的定义中，XML 文件中的 targetNamespace属性，其实就是流程的分类定义：
&lt;definitions xmlns=&quot;http://www.omg.org/spec/BPMN/20100524/MODEL&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:flowable=&quot;http://flowable.org/bpmn&quot; xmlns:bpmndi=&quot;http://www.omg.org/spec/BPMN/20100524/DI&quot; xmlns:omgdc=&quot;http://www.omg.org/spec/DD/20100524/DC&quot; xmlns:omgdi=&quot;http://www.omg.org/spec/DD/20100524/DI&quot; typeLanguage=&quot;http://www.w3.org/2001/XMLSchema&quot; expressionLanguage=&quot;http://www.w3.org/1999/XPath&quot; targetNamespace=&quot;http://www.flowable.org/processdef&quot; exporter=&quot;Flowable Open Source Modeler&quot; exporterVersion=&quot;6.7.2&quot;&gt;  &lt;process id=&quot;javaboy_submit_an_expense_account2&quot; name=&quot;javaboy的报销流程2&quot; isExecutable=&quot;true&quot;&gt;    &lt;documentation&gt;javaboy的报销流程&lt;/documentation&gt;    &lt;startEvent id=&quot;startEvent1&quot; flowable:formFieldValidation=&quot;true&quot;&gt;&lt;/startEvent&gt;    &lt;userTask id=&quot;sid-71C33AD7-E892-4037-AFBB-464957E41378&quot; name=&quot;填写报销材料&quot; flowable:assignee=&quot;$INITIATOR&quot; flowable:formKey=&quot;submit_an_expense_account&quot; flowable:formFieldValidation=&quot;true&quot;&gt;      &lt;extensionElements&gt;        &lt;modeler:activiti-idm-initiator xmlns:modeler=&quot;http://flowable.org/modeler&quot;&gt;&lt;![CDATA[true]]&gt;&lt;/modeler:activiti-idm-initiator&gt;      &lt;/extensionElements&gt;    &lt;/userTask&gt;

如果想要修改流程定义的分类，直接修改该属性即可。
Spring Boot 中，关于流程定义的几个重要属性：
# 是否在项目启动的时候，自动去检查流程定义目录下是否有对应的流程定义文件，如果这个属性为 true（默认既此），就表示去检查，否则不检查（意味着不会自动部署流程）flowable.check-process-definitions=true# 设置流程定义文件的位置，默认位置就是 classpath*:/processes/flowable.process-definition-location-prefix=classpath*:/javaboy/# 这个是指定流程定义 XML 文件的后缀，默认后缀有两个：**.bpmn20.xml,**.bpmnflowable.process-definition-location-suffixes=**.bpmn20.xml,**.bpmn



手动部署手动部署项目启动成功之后，再去部署流程。
首先，定义一个返回实体类model
/**省略有参构造 无参构造函数 和getset方法*/public class RespBean &#123;    private Integer status;    private String msg;    private Object data;    public static RespBean ok(String msg,Object data)&#123;        return new RespBean(200,msg,data);    &#125;    public static RespBean ok(String msg)&#123;        return new RespBean(200,msg,null);    &#125;    public static RespBean error(String msg,Object data)&#123;        return new RespBean(500,msg,data);    &#125;    public static RespBean error(String msg)&#123;        return new RespBean(500,msg,null);    &#125;



手动部署流程接口如下：
/** * 这个是我自定义的流程部署接口 */@RestControllerpublic class ProcessDeployController &#123;    //RepositoryService 这个实体类可以用来操作 ACT_RE_XXX 这种表    @Autowired    RepositoryService repositoryService;    /**     * 这个就是我的流程部署接口，流程部署将来要上传一个文件，这个文件就是流程的 XML 文件     *     * @param file     * @return     */    @PostMapping(&quot;/deploy&quot;)    public RespBean deploy(MultipartFile file) throws IOException &#123;        DeploymentBuilder deploymentBuilder = repositoryService                //开始流程部署的构建                .createDeployment()                .name(&quot;JAVABOY的工作流&quot;)//ACT_RE_DEPLOYMENT 表中的 NAME_ 属性                .category(&quot;我的流程分类&quot;)//ACT_RE_DEPLOYMENT 表中的 CATEGORY_ 属性                .key(&quot;我的自定义的工作流的 KEY&quot;)//ACT_RE_DEPLOYMENT 表中的 KEY_ 属性                //也可以用这个方法代替 addInputStream，但是注意，这个需要我们自己先去解析 IO 流程，将 XML 文件解析为一个字符串，然后就可以调用这个方法进行部署了//                .addString()                //设置文件的输入流程，将来通过这个输入流自动去读取 XML 文件                .addInputStream(file.getOriginalFilename(), file.getInputStream());        //完成项目的部署        Deployment deployment = deploymentBuilder.deploy();        return RespBean.ok(&quot;部署成功&quot;, deployment.getId());    &#125;    @PostMapping(&quot;/deploy2&quot;)    public RespBean deploy2(MultipartFile file) throws IOException &#123;        ByteArrayOutputStream baos = new ByteArrayOutputStream();        int len;        byte[] buf = new byte[1024];        InputStream is = file.getInputStream();        while ((len = is.read(buf)) != -1) &#123;            baos.write(buf, 0, len);        &#125;        is.close();        DeploymentBuilder deploymentBuilder = repositoryService                //开始流程部署的构建                .createDeployment()                .name(&quot;JAVABOY的工作流&quot;)//ACT_RE_DEPLOYMENT 表中的 NAME_ 属性                .category(&quot;我的流程分类&quot;)//ACT_RE_DEPLOYMENT 表中的 CATEGORY_ 属性                .key(&quot;我的自定义的工作流的 KEY&quot;)//ACT_RE_DEPLOYMENT 表中的 KEY_ 属性                //也可以用这个方法代替 addInputStream，但是注意，这个需要我们自己先去解析 IO 流程，将 XML 文件解析为一个字符串，然后就可以调用这个方法进行部署了//                .addString()                //设置文件的输入流程，将来通过这个输入流自动去读取 XML 文件//                .addInputStream(file.getOriginalFilename(), file.getInputStream());                //注意这里需要设置资源名称，这个资源名称不能随意取值，建议最好和文件名保持一致                .addBytes(file.getOriginalFilename(), baos.toByteArray());        //完成项目的部署        Deployment deployment = deploymentBuilder.deploy();        return RespBean.ok(&quot;部署成功&quot;, deployment.getId());    &#125;&#125;



查询流程定义查询所有的流程定义：
@SpringBootTestpublic class ActReTest &#123;    @Autowired    RepositoryService repositoryService;    private static final Logger logger = LoggerFactory.getLogger(ActReTest.class);    /**     * 查询流程定义     *     * 对应的 SQL 如下：     *     * : ==&gt;  Preparing: SELECT RES.* from ACT_RE_PROCDEF RES order by RES.ID_ asc     * : ==&gt; Parameters:     * : &lt;==      Total: 2     */    @Test    void test01() &#123;        //查询所有定义的流程        List&lt;ProcessDefinition&gt; list = repositoryService.createProcessDefinitionQuery().list();        for (ProcessDefinition pd : list) &#123;            logger.info(&quot;id:&#123;&#125;,name:&#123;&#125;,version:&#123;&#125;,category:&#123;&#125;&quot;,pd.getId(),pd.getName(),pd.getVersion(),pd.getCategory());        &#125;    &#125;&#125;



查询所有流程的最新版本：
/** * 查询所有流程的最新版本 *  * 对应的 SQL： *  * : ==&gt;  Preparing: SELECT RES.* from ACT_RE_PROCDEF RES WHERE RES.VERSION_ = (select max(VERSION_) from ACT_RE_PROCDEF where KEY_ = RES.KEY_ and ( (TENANT_ID_ IS NOT NULL and TENANT_ID_ = RES.TENANT_ID_) or (TENANT_ID_ IS NULL and RES.TENANT_ID_ IS NULL) ) ) order by RES.ID_ asc * : ==&gt; Parameters:  * : &lt;==      Total: 1 */@Testvoid test02() &#123;    List&lt;ProcessDefinition&gt; list = repositoryService.createProcessDefinitionQuery()            //设置查询流程定义的最新版本            .latestVersion()            .list();    for (ProcessDefinition pd : list) &#123;        logger.info(&quot;id:&#123;&#125;,name:&#123;&#125;,version:&#123;&#125;,category:&#123;&#125;&quot;,pd.getId(),pd.getName(),pd.getVersion(),pd.getCategory());    &#125;&#125;


根据流程定义的 key 去查询
/** * 根据流程定义的 key 去查询 *  * : ==&gt;  Preparing: SELECT RES.* from ACT_RE_PROCDEF RES WHERE RES.KEY_ = ? order by RES.VERSION_ desc * : ==&gt; Parameters: javaboy_submit_an_expense_account(String) * : &lt;==      Total: 2 *  */@Testvoid test03() &#123;    List&lt;ProcessDefinition&gt; list = repositoryService.createProcessDefinitionQuery()            //根据流程定义的 XML 文件中的 id 去查询一个流程，注意，XML 文件中的 id 对应 ACT_RE_PROCDEF 表中的 KEY_            .processDefinitionKey(&quot;javaboy_submit_an_expense_account&quot;)            //按照版本号排序            .orderByProcessDefinitionVersion()            .desc()            .list();    for (ProcessDefinition pd : list) &#123;        logger.info(&quot;id:&#123;&#125;,name:&#123;&#125;,version:&#123;&#125;,category:&#123;&#125;&quot;,pd.getId(),pd.getName(),pd.getVersion(),pd.getCategory());    &#125;&#125;



自定义查询
/** * 根据流程定义的 key 去查询 */@Testvoid test04() &#123;    List&lt;ProcessDefinition&gt; list = repositoryService.createNativeProcessDefinitionQuery()            .sql(&quot;SELECT RES.* from ACT_RE_PROCDEF RES WHERE RES.KEY_ = #&#123;key&#125; order by RES.VERSION_ desc&quot;)            .parameter(&quot;key&quot;,&quot;javaboy_submit_an_expense_account&quot;)            .list();    for (ProcessDefinition pd : list) &#123;        logger.info(&quot;id:&#123;&#125;,name:&#123;&#125;,version:&#123;&#125;,category:&#123;&#125;&quot;,pd.getId(),pd.getName(),pd.getVersion(),pd.getCategory());    &#125;&#125;

查询流程部署/** * 查询流程部署信息，本质上就是查询 ACT_RE_DEPLOYMENT 表 * * : ==&gt;  Preparing: SELECT RES.* from ACT_RE_DEPLOYMENT RES order by RES.ID_ asc * : ==&gt; Parameters:  * : &lt;==      Total: 2 */@Testvoid test05() &#123;    List&lt;Deployment&gt; list = repositoryService.createDeploymentQuery().list();    for (Deployment d : list) &#123;        logger.info(&quot;id:&#123;&#125;,category:&#123;&#125;,,name:&#123;&#125;,key:&#123;&#125;&quot;,d.getId(),d.getCategory(),d.getName(),d.getKey());    &#125;&#125;



根据流程部署的分类名称去查询：
/** * 根据流程部署的分类，去查询流程部署信息 *  * : ==&gt;  Preparing: SELECT RES.* from ACT_RE_DEPLOYMENT RES WHERE RES.CATEGORY_ = ? order by RES.ID_ asc * : ==&gt; Parameters: 我的流程分类(String) * : &lt;==      Total: 2 *  */@Testvoid test06() &#123;    List&lt;Deployment&gt; list = repositoryService.createDeploymentQuery()            //根据流程部署的分类去查询            .deploymentCategory(&quot;我的流程分类&quot;)            .list();    for (Deployment d : list) &#123;        logger.info(&quot;id:&#123;&#125;,category:&#123;&#125;,,name:&#123;&#125;,key:&#123;&#125;&quot;,d.getId(),d.getCategory(),d.getName(),d.getKey());    &#125;&#125;



根据流程部署信息，查询流程定义信息：
/** * 根据流程部署的 ID 去查询流程定义 *  * : ==&gt;  Preparing: SELECT RES.* from ACT_RE_DEPLOYMENT RES order by RES.ID_ asc * : ==&gt; Parameters:  * : &lt;==      Total: 2 * : Flushing dbSqlSession * : flush summary: 0 insert, 0 update, 0 delete. * : now executing flush... * : --- DeploymentQueryImpl finished -------------------------------------------------------- * : --- starting ProcessDefinitionQueryImpl -------------------------------------------------------- * : Running command with propagation REQUIRED * : Operation class org.flowable.engine.impl.interceptor.CommandInvoker$1 added to agenda * : Executing operation class org.flowable.engine.impl.interceptor.CommandInvoker$1 * : ==&gt;  Preparing: SELECT RES.* from ACT_RE_PROCDEF RES WHERE RES.DEPLOYMENT_ID_ = ? order by RES.ID_ asc * : ==&gt; Parameters: 9a5d421d-3c95-11ed-99f7-acde48001122(String) * : &lt;==      Total: 1 * : Flushing dbSqlSession * : flush summary: 0 insert, 0 update, 0 delete. * : now executing flush... * : --- ProcessDefinitionQueryImpl finished -------------------------------------------------------- * : id:9b09aec0-3c95-11ed-99f7-acde48001122,name:javaboy的报销流程,version:1,category:http://www.flowable.org/processdef * : --- starting ProcessDefinitionQueryImpl -------------------------------------------------------- * : Running command with propagation REQUIRED * : Operation class org.flowable.engine.impl.interceptor.CommandInvoker$1 added to agenda * : Executing operation class org.flowable.engine.impl.interceptor.CommandInvoker$1 * : ==&gt;  Preparing: SELECT RES.* from ACT_RE_PROCDEF RES WHERE RES.DEPLOYMENT_ID_ = ? order by RES.ID_ asc * : ==&gt; Parameters: a31bea4a-3c96-11ed-9ebe-acde48001122(String) * : &lt;==      Total: 1 * : Flushing dbSqlSession * : flush summary: 0 insert, 0 update, 0 delete. * : now executing flush... * : --- ProcessDefinitionQueryImpl finished -------------------------------------------------------- * : id:a3d7e74d-3c96-11ed-9ebe-acde48001122,name:javaboy的报销流程666,version:2,category:http://www.flowable.org/processdef *  */@Testvoid test07() &#123;    List&lt;Deployment&gt; list = repositoryService.createDeploymentQuery().list();    for (Deployment d : list) &#123;        List&lt;ProcessDefinition&gt; list1 = repositoryService.createProcessDefinitionQuery().deploymentId(d.getId()).list();        for (ProcessDefinition pd : list1) &#123;            logger.info(&quot;id:&#123;&#125;,name:&#123;&#125;,version:&#123;&#125;,category:&#123;&#125;&quot;, pd.getId(), pd.getName(), pd.getVersion(), pd.getCategory());        &#125;    &#125;&#125;



自定义流程部署查询 SQL：
/** * 也可以自定义流程部署的查询 SQL */@Testvoid test08() &#123;    List&lt;Deployment&gt; list = repositoryService.createNativeDeploymentQuery()            .sql(&quot;SELECT RES.* from ACT_RE_DEPLOYMENT RES WHERE RES.CATEGORY_ = #&#123;category&#125; order by RES.ID_ asc&quot;)            .parameter(&quot;category&quot;,&quot;我的流程分类&quot;)            .list();    for (Deployment d : list) &#123;        logger.info(&quot;id:&#123;&#125;,category:&#123;&#125;,,name:&#123;&#125;,key:&#123;&#125;&quot;,d.getId(),d.getCategory(),d.getName(),d.getKey());    &#125;&#125;


流程定义删除这个删除操作，涉及到流程定义的表，都会被删除掉。
/** * 删除一个流程部署 */@Testvoid test09() &#123;    List&lt;Deployment&gt; list = repositoryService.createDeploymentQuery().list();    for (Deployment deployment : list) &#123;        repositoryService.deleteDeployment(deployment.getId());    &#125;&#125;


流程实例 Process Instance两个概念：

流程实例：ProcessInstance：通过流程定义启动的一个流程，这个启动后的流程就是流程实例，这个表示一个流程从开始到结束的最大流程分支，在一个流程中，只存在一个流程实例（执行实例可能有多个），前面说的流程定义相当于是 Java 类，这里的流程实例相当于是 Java 对象。

执行实例：Execution：简单来说，在一个流程中，开始节点和结束节点是流程实例，其余节点是执行实例。从类的继承关系来说，ProcessInstance 实际上是 Execution 的子类，所以，流程实例可以算是执行实例的一种特殊情况。


如果一个流程图中，只有一条线，那么一般来说，流程实例和执行实例就不同。
如果一个流程图中，包含多条线，那么每一条线就是一个执行实例。



启动流程启动流程方式如下：
@SpringBootTestpublic class ActRuTest &#123;    //跟流程运行相关的操作，都在这个 Bean 中，在 Spring Boot 中，该 Bean 已经配置好，可以直接使用    @Autowired    RuntimeService runtimeService;    private static final Logger logger = LoggerFactory.getLogger(ActRuTest.class);    @Test    void test01() &#123;        //设置流程的发起人        Authentication.setAuthenticatedUserId(&quot;wangwu&quot;);        //这个流程定义的 key 实际上就是流程 XML 文件中的流程 id        String processDefinitionKey = &quot;leave&quot;;        //流程启动成功之后，可以获取到一个流程实例        ProcessInstance pi = runtimeService.startProcessInstanceByKey(processDefinitionKey);        logger.info(&quot;definitionId:&#123;&#125;,id:&#123;&#125;,name:&#123;&#125;&quot;, pi.getProcessDefinitionId(), pi.getId(), pi.getName());        //也可以通过流程定义的 id 去启动一个流程，但是需要注意，流程定义的 id 需要自己去查询，这个 id 并不是 XML 文件中定义的流程 ID//        String processDefinitionId = &quot;&quot;;//        runtimeService.startProcessInstanceById(processDefinitionId);    &#125;&#125;



当一个流程启动成功后，我们首先去查看 ACT_RU_EXECUTION表，该表中保存了所有的流程执行实例信息，包括启动节点以及其他的任务节点信息都保存在这个表中。同时，如果这个节点，还是一个 UserTask，那么这个节点的信息还会保存在 ACT_RU_TASK表中（该表用来保存 UserTask）。
另外还有 ACT_RU_ACTINST表中，会保存流程活动的执行情况。
当然，无论哪张表，只要流程执行结束，ACT_RU_相关的表中的数据都会被删除。
另外一种启动方式
@SpringBootTestpublic class ActRuTest &#123;    //跟流程运行相关的操作，都在这个 Bean 中，在 Spring Boot 中，该 Bean 已经配置好，可以直接使用    @Autowired    RuntimeService runtimeService;    private static final Logger logger = LoggerFactory.getLogger(ActRuTest.class);    @Autowired    IdentityService identityService;    @Autowired    RepositoryService repositoryService;    /**     * 另外一种流程启动的例子和流程发起人设置的例子     */    @Test    void test02() &#123;        //设置流程的发起人        identityService.setAuthenticatedUserId(&quot;wangwu&quot;);        //查询最新版本的 leave 流程的定义信息        ProcessDefinition pd = repositoryService.createProcessDefinitionQuery().processDefinitionKey(&quot;leave&quot;).latestVersion().singleResult();        //也可以通过流程定义的 id 去启动一个流程，但是需要注意，流程定义的 id 需要自己去查询，这个 id 并不是 XML 文件中定义的流程 ID        ProcessInstance pi = runtimeService.startProcessInstanceById(pd.getId());        logger.info(&quot;definitionId:&#123;&#125;,id:&#123;&#125;,name:&#123;&#125;&quot;, pi.getProcessDefinitionId(), pi.getId(), pi.getName());    &#125;



接下来，根据用户名去查询每一个用户需要处理的流程，并处理：
/** * 查询 wangwu 需要执行的任务，并处理 * * 查询 wangwu 需要处理的任务，对应的 SQL： * * : ==&gt;  Preparing: SELECT RES.* from ACT_RU_TASK RES WHERE RES.ASSIGNEE_ = ? order by RES.ID_ asc * : ==&gt; Parameters: wangwu(String) * : &lt;==      Total: 1 * * wangwu 去处理任务： * * 首先去 ACT_RU_TASK 表中添加一条记录，这个新的记录，就是主管审批。 * 然后从 ACT_RU_TASK 表中删除掉之前的需要 wangwu 完成的记录。 * * 上面这两个操作是在同一个事务中完成的。 * */@Testvoid test03() &#123;    List&lt;Task&gt; list = taskService.createTaskQuery().taskAssignee(&quot;javaboy&quot;).list();    for (Task task : list) &#123;        logger.info(&quot;id:&#123;&#125;,assignee:&#123;&#125;,name:&#123;&#125;&quot;,task.getId(),task.getAssignee(),task.getName());        //王五完成自己的任务        taskService.complete(task.getId());    &#125;&#125;



查看流程是否结束查的是ACT_RU_EXECUTION表的PROC_INST_ID属性
/** * 查询一个流程是否执行结束 * 如果 ACT_RU_EXECUTION 表中，由于关于这个流程的记录，说明这个流程还在执行中 * 如果 ACT_RU_EXECUTION 表中，没有关于这个流程的记录，说明这个流程已经执行结束了 * * 注意，虽然我们是去 ACT_RU_EXECUTION 表中查询，且该表中同一个流程实例 ID 对应了多条记录，但是大家注意，这里查询到的其实还是一个流程实例。 * */@Testvoid test04() &#123;    String processId = &quot;cc189d50-3cac-11ed-8459-acde48001122&quot;;    ProcessInstance pi = runtimeService.createProcessInstanceQuery().processInstanceId(processId).singleResult();    if (pi == null) &#123;        logger.info(&quot;流程执行结束&quot;);    &#125;else&#123;        logger.info(&quot;流程正在执行中&quot;);    &#125;&#125;



查看运行的活动节点就是当前这个流程，走到哪一步了
/** * 查看运行活动节点，本质上其实就是查看 ACT_RU_EXECUTION 表 */@Testvoid test05() &#123;    List&lt;Execution&gt; executions = runtimeService.createExecutionQuery().list();    for (Execution execution : executions) &#123;        //查询某一个执行实例的活动节点        List&lt;String&gt; activeActivityIds = runtimeService.getActiveActivityIds(execution.getId());        for (String activeActivityId : activeActivityIds) &#123;            //这里拿到的其实就是 ACT_RU_EXECUTION 表中的 ACT_ID_ 字段            logger.info(&quot;activeActivityId:&#123;&#125;&quot;, activeActivityId);        &#125;    &#125;&#125;





删除流程实例/** *  * 删除一个正在执行的流程，注意这个只会删除正在执行的流程实例信息，并不会删除历史流程信息（历史信息被更新）。 *  * : ==&gt;  Preparing: delete from ACT_RU_VARIABLE where EXECUTION_ID_ = ? * : ==&gt; Parameters: 87df7272-3cad-11ed-9026-acde48001122(String) * : &lt;==    Updates: 1 * : ==&gt;  Preparing: delete from ACT_RU_IDENTITYLINK where PROC_INST_ID_ = ? * : ==&gt; Parameters: 87df7272-3cad-11ed-9026-acde48001122(String) * : &lt;==    Updates: 2 * : ==&gt;  Preparing: delete from ACT_RU_TASK where ID_ = ? and REV_ = ? * : ==&gt; Parameters: 87e4c9a9-3cad-11ed-9026-acde48001122(String), 1(Integer) * : &lt;==    Updates: 1 * : ==&gt;  Preparing: delete from ACT_RU_TASK where EXECUTION_ID_ = ? * : ==&gt; Parameters: 87df7272-3cad-11ed-9026-acde48001122(String) * : &lt;==    Updates: 0 * : ==&gt;  Preparing: delete from ACT_RU_ACTINST where PROC_INST_ID_ = ? * : ==&gt; Parameters: 87df7272-3cad-11ed-9026-acde48001122(String) * : &lt;==    Updates: 3 * : ==&gt;  Preparing: delete from ACT_RU_ACTINST where PROC_INST_ID_ = ? * : ==&gt; Parameters: 87df7272-3cad-11ed-9026-acde48001122(String) * : &lt;==    Updates: 0 * : ==&gt;  Preparing: delete from ACT_RU_EXECUTION where ID_ = ? and REV_ = ? * : ==&gt; Parameters: 87e035c5-3cad-11ed-9026-acde48001122(String), 2(Integer) * : &lt;==    Updates: 1 * : ==&gt;  Preparing: delete from ACT_RU_EXECUTION where ID_ = ? and REV_ = ? * : ==&gt; Parameters: 87df7272-3cad-11ed-9026-acde48001122(String), 2(Integer) * : &lt;==    Updates: 1 */@Testvoid test06() &#123;    String processInstanceId = &quot;87df7272-3cad-11ed-9026-acde48001122&quot;;    String deleteReason = &quot;想删除了&quot;;    runtimeService.deleteProcessInstance(processInstanceId, deleteReason);&#125;




流程的挂起和恢复
流程定义的挂起和恢复。
流程实例的挂起和恢复。

流程定义查看流程定义是否挂起：
act_re_procdef表中的SUSPENSION_STATE_字段
/** * 查看一个已经定义好的流程，是否是一个挂起状态 * * 挂起的流程定义，是无法开启一个流程实例的 * */@Testvoid test10() &#123;    //查询所有的流程定义    List&lt;ProcessDefinition&gt; list = repositoryService.createProcessDefinitionQuery().list();    for (ProcessDefinition pd : list) &#123;        //根据流程定义的 id 判断一个流程定义是否挂起        boolean processDefinitionSuspended = repositoryService.isProcessDefinitionSuspended(pd.getId());        if (processDefinitionSuspended) &#123;            logger.info(&quot;流程定义 &#123;&#125; 已经挂起&quot;, pd.getId());        &#125;else &#123;            logger.info(&quot;流程定义 &#123;&#125; 没有挂起&quot;, pd.getId());        &#125;    &#125;&#125;



挂起一个流程定义：
/** * 挂起一个流程定义 * * 挂起的流程定义，是无法启动一个流程实例的 * * 执行的 SQL 如下： * * : ==&gt;  Preparing: update ACT_RE_PROCDEF SET REV_ = ?, SUSPENSION_STATE_ = ? where ID_ = ? and REV_ = ? : ==&gt; Parameters: 2(Integer), 2(Integer), leave:1:48375905-43e2-11ed-ba47-acde48001122(String), 1(Integer) : &lt;==    Updates: 1 所以，挂起一个流程定义，本质上，其实就是修改 ACT_RE_PROCDEF 表中，对应的记录的 SUSPENSION_STATE_ 字段的状态值为 2 * */@Testvoid test11() &#123;    List&lt;ProcessDefinition&gt; list = repositoryService.createProcessDefinitionQuery().list();    for (ProcessDefinition pd : list) &#123;        //根据流程定义的 id 挂起一个流程定义        repositoryService.suspendProcessDefinitionById(pd.getId());        logger.info(&quot;&#123;&#125; 流程定义已经挂起&quot;,pd.getId());    &#125;&#125;



对于一个已经挂起的流程定义，是无法据此启动一个流程实例的，强行启动，会抛出如下错误：
org.flowable.common.engine.api.FlowableException: Cannot start process instance. Process definition javaboy的请假流程图666 (id = leave:1:f1f2c354-4ed6-11ed-a142-6e6a7761cc27) is suspended



激活一个已经挂起的流程定义：
/** * 激活一个已经挂起的流程定义 *  * : ==&gt;  Preparing: update ACT_RE_PROCDEF SET REV_ = ?, SUSPENSION_STATE_ = ? where ID_ = ? and REV_ = ? * : ==&gt; Parameters: 3(Integer), 1(Integer), leave:1:48375905-43e2-11ed-ba47-acde48001122(String), 2(Integer) * : &lt;==    Updates: 1 *  * 激活一个流程定义，本质上，其实就是将 ACT_RE_PROCDEF 表中相应记录的 SUSPENSION_STATE_ 字段的值改为 1 *  */@Testvoid test12() &#123;    List&lt;ProcessDefinition&gt; list = repositoryService.createProcessDefinitionQuery().list();    for (ProcessDefinition pd : list) &#123;        repositoryService.activateProcessDefinitionById(pd.getId());        logger.info(&quot;&#123;&#125; 流程定义已经被激活&quot;, pd.getId());    &#125;&#125;



流程实例挂起一个流程实例：
/** * 挂起一个流程实例 * &lt;p&gt; * 对于一个挂起的流程实例，我们是无法执行相应的 Task 的 * * 流程实例的挂起，最终也会挂起流程定义 * * 一个被挂起的流程实例： * 1。 流程实例本身被挂起 * 2。 流程的 Task 被挂起。 *  * : ==&gt;  Preparing: update ACT_RU_EXECUTION SET REV_ = ?, SUSPENSION_STATE_ = ? where ID_ = ? and REV_ = ? * : ==&gt; Parameters: 2(Integer), 2(Integer), dd7000f0-43e5-11ed-bbdc-acde48001122(String), 1(Integer) * : &lt;==    Updates: 1 * : updating: Execution[ id &#x27;dd709d33-43e5-11ed-bbdc-acde48001122&#x27; ] - activity &#x27;sid-2F900F54-E047-40AC-A09C-71181386A6C1&#x27; - parent &#x27;dd7000f0-43e5-11ed-bbdc-acde4800112 * : ==&gt;  Preparing: update ACT_RU_EXECUTION SET REV_ = ?, SUSPENSION_STATE_ = ? where ID_ = ? and REV_ = ? * : ==&gt; Parameters: 2(Integer), 2(Integer), dd709d33-43e5-11ed-bbdc-acde48001122(String), 1(Integer) * : &lt;==    Updates: 1 * : updating: Task[id=dd746dc7-43e5-11ed-bbdc-acde48001122, name=提交请假申请] * : ==&gt;  Preparing: update ACT_RU_TASK SET REV_ = ?, SUSPENSION_STATE_ = ? where ID_= ? and REV_ = ? * : ==&gt; Parameters: 2(Integer), 2(Integer), dd746dc7-43e5-11ed-bbdc-acde48001122(String), 1(Integer) * : &lt;==    Updates: 1 * : updating: ProcessDefinitionEntity[leave:1:cc46d851-43e5-11ed-bdc3-acde48001122] * : ==&gt;  Preparing: update ACT_RE_PROCDEF SET REV_ = ?, SUSPENSION_STATE_ = ? where ID_ = ? and REV_ = ? * : ==&gt; Parameters: 2(Integer), 2(Integer), leave:1:cc46d851-43e5-11ed-bdc3-acde48001122(String), 1(Integer) * : &lt;==    Updates: 1 *  * 流程实例的挂起，一共涉及到三张表，分别是 ACT_RU_EXECUTION（流程实例被挂起）、ACT_RU_TASK（流程的 Task 被挂起） 以及 ACT_RE_PROCDEF（流程定义被挂起） * */@Testvoid test07() &#123;    //查询所有的流程定义    List&lt;ProcessDefinition&gt; list = repositoryService.createProcessDefinitionQuery().list();    for (ProcessDefinition pd : list) &#123;        //1. 流程定义的 ID        //2. 是否挂起这个流程定义所对应的流程实例        //3。这是挂起的时间，null 表示立即挂起，也可以给一个具体的时间，表示到期之后才会被挂起。        repositoryService.suspendProcessDefinitionById(pd.getId(), true, null);    &#125;&#125;



对于一个挂起的流程实例，是无法执行其 Task 的，如果强行执行，报错信息如下：
org.flowable.common.engine.api.FlowableException: Cannot complete a suspended task

激活一个已经挂起的流程：
/** * 激活一个挂起的流程实例 * * 激活就是挂起的一个反向操作： * * 激活，也会涉及到三张表，分别是：ACT_RU_EXECUTION、ACT_RU_TASK 以及 ACT_RE_PROCDEF * * 挂起是将这三张表中的 SUSPENSION_STATE_ 字段，由 1 改为 2 * 激活就是将这三张表中的 SUSPENSION_STATE_ 由 2 改为 1 *  * : ==&gt;  Preparing: update ACT_RE_PROCDEF SET REV_ = ?, SUSPENSION_STATE_ = ? where ID_ = ? and REV_ = ? : ==&gt; Parameters: 3(Integer), 1(Integer), leave:1:cc46d851-43e5-11ed-bdc3-acde48001122(String), 2(Integer) : &lt;==    Updates: 1 : updating: ProcessInstance[dd7000f0-43e5-11ed-bbdc-acde48001122] : ==&gt;  Preparing: update ACT_RU_EXECUTION SET REV_ = ?, SUSPENSION_STATE_ = ? where ID_ = ? and REV_ = ? : ==&gt; Parameters: 3(Integer), 1(Integer), dd7000f0-43e5-11ed-bbdc-acde48001122(String), 2(Integer) : &lt;==    Updates: 1 : updating: Execution[ id &#x27;dd709d33-43e5-11ed-bbdc-acde48001122&#x27; ] - activity &#x27;sid-2F900F54-E047-40AC-A09C-71181386A6C1&#x27; - parent &#x27;dd7000f0-43e5-11ed-bbdc-acde48001122&#x27; : ==&gt;  Preparing: update ACT_RU_EXECUTION SET REV_ = ?, SUSPENSION_STATE_ = ? where ID_ = ? and REV_ = ? : ==&gt; Parameters: 3(Integer), 1(Integer), dd709d33-43e5-11ed-bbdc-acde48001122(String), 2(Integer) : &lt;==    Updates: 1 : updating: Task[id=dd746dc7-43e5-11ed-bbdc-acde48001122, name=提交请假申请] : ==&gt;  Preparing: update ACT_RU_TASK SET REV_ = ?, SUSPENSION_STATE_ = ? where ID_= ? and REV_ = ? : ==&gt; Parameters: 3(Integer), 1(Integer), dd746dc7-43e5-11ed-bbdc-acde48001122(String), 2(Integer) : &lt;==    Updates: 1 * */@Testvoid test08() &#123;    List&lt;ProcessDefinition&gt; list = repositoryService.createProcessDefinitionQuery().list();    for (ProcessDefinition pd : list) &#123;        repositoryService.activateProcessDefinitionById(pd.getId(), true, null);    &#125;&#125;



DataObject这个用来设置流程的一些全局的属性。
这个东西，本质上就是给流程设置一些全局属性。我们可以在绘制流程图的时候进行设置，设置时候，记得不要选择任何流程节点。

  .nqduwlwwongo{width:70%}



  .nslvsowuboys{width:70%}


生成的 XML 文件如下：
&lt;process id=&quot;leave&quot; name=&quot;javaboy的请假流程图&quot; isExecutable=&quot;true&quot;&gt;  &lt;documentation&gt;javaboy的请假流程图&lt;/documentation&gt;  &lt;dataObject id=&quot;name&quot; name=&quot;流程定义的名称&quot; itemSubjectRef=&quot;xsd:string&quot;&gt;    &lt;extensionElements&gt;      &lt;flowable:value&gt;javaboy的请假流程&lt;/flowable:value&gt;    &lt;/extensionElements&gt;  &lt;/dataObject&gt;  &lt;dataObject id=&quot;date&quot; name=&quot;流程绘制时间&quot; itemSubjectRef=&quot;xsd:datetime&quot;&gt;    &lt;extensionElements&gt;      &lt;flowable:value&gt;2022-10-10T00:00:00&lt;/flowable:value&gt;    &lt;/extensionElements&gt;  &lt;/dataObject&gt;  &lt;dataObject id=&quot;site&quot; name=&quot;流程作者网站&quot; itemSubjectRef=&quot;xsd:string&quot;&gt;    &lt;extensionElements&gt;      &lt;flowable:value&gt;www.javaboy.org&lt;/flowable:value&gt;    &lt;/extensionElements&gt;  &lt;/dataObject&gt;  &lt;startEvent id=&quot;startEvent1&quot; flowable:initiator=&quot;INITIATOR&quot; flowable:formFieldValidation=&quot;true&quot;&gt;&lt;/startEvent&gt;  &lt;userTask id=&quot;sid-2F900F54-E047-40AC-A09C-71181386A6C1&quot; name=&quot;提交请假申请&quot; flowable:assignee=&quot;$INITIATOR&quot; flowable:formFieldValidation=&quot;true&quot;&gt;    &lt;extensionElements&gt;      &lt;modeler:activiti-idm-initiator xmlns:modeler=&quot;http://flowable.org/modeler&quot;&gt;&lt;![CDATA[true]]&gt;&lt;/modeler:activiti-idm-initiator&gt;    &lt;/extensionElements&gt;  &lt;/userTask&gt;  &lt;sequenceFlow id=&quot;sid-5173B338-945D-4266-8FF6-1CEAA4BC9BDF&quot; sourceRef=&quot;startEvent1&quot; targetRef=&quot;sid-2F900F54-E047-40AC-A09C-71181386A6C1&quot;&gt;&lt;/sequenceFlow&gt;  &lt;userTask id=&quot;sid-745B2D5D-599B-42E6-98F4-78833C81B6E9&quot; name=&quot;主管审批&quot; flowable:assignee=&quot;zhangsan&quot; flowable:formFieldValidation=&quot;true&quot;&gt;    &lt;extensionElements&gt;      &lt;modeler:initiator-can-complete xmlns:modeler=&quot;http://flowable.org/modeler&quot;&gt;&lt;![CDATA[false]]&gt;&lt;/modeler:initiator-can-complete&gt;    &lt;/extensionElements&gt;  &lt;/userTask&gt;  &lt;sequenceFlow id=&quot;sid-09948146-3573-4F5C-875B-2ECF03BBAB9B&quot; sourceRef=&quot;sid-2F900F54-E047-40AC-A09C-71181386A6C1&quot; targetRef=&quot;sid-745B2D5D-599B-42E6-98F4-78833C81B6E9&quot;&gt;&lt;/sequenceFlow&gt;  &lt;userTask id=&quot;sid-9462F815-6A53-4E32-879F-5E030C003790&quot; name=&quot;经理审批&quot; flowable:assignee=&quot;javaboy&quot; flowable:formFieldValidation=&quot;true&quot;&gt;    &lt;extensionElements&gt;      &lt;modeler:initiator-can-complete xmlns:modeler=&quot;http://flowable.org/modeler&quot;&gt;&lt;![CDATA[false]]&gt;&lt;/modeler:initiator-can-complete&gt;    &lt;/extensionElements&gt;  &lt;/userTask&gt;  &lt;sequenceFlow id=&quot;sid-9BA1715D-77DD-4B9A-A9DB-549A0284BDAF&quot; sourceRef=&quot;sid-745B2D5D-599B-42E6-98F4-78833C81B6E9&quot; targetRef=&quot;sid-9462F815-6A53-4E32-879F-5E030C003790&quot;&gt;&lt;/sequenceFlow&gt;  &lt;endEvent id=&quot;sid-B8B67E20-8935-4645-9959-A1B51795AFAC&quot;&gt;&lt;/endEvent&gt;  &lt;sequenceFlow id=&quot;sid-9058115E-EB5B-4238-ADB6-A89B8979A31E&quot; sourceRef=&quot;sid-9462F815-6A53-4E32-879F-5E030C003790&quot; targetRef=&quot;sid-B8B67E20-8935-4645-9959-A1B51795AFAC&quot;&gt;&lt;/sequenceFlow&gt;&lt;/process&gt;

dataObject 这个节点是属于 process 的，而不是属于某一个具体的节点，因此，这里的 dataObject 可以理解为一个全局的属性。

由于默认识别的流程图的 XML 文件，后缀是 bpmn20.xml 或者是 bpmn，所以，如果我们重复下载的流程文件名，可能会不满足要求，这里注意，需要自行修改一下。

当流程启动成功之后，dataObject 中的数据，实际上是保存在 ACT_RU_VARIABLE表中的。

  .srubmvwmkrqs{width:70%}


我们一开始设置的流程启动人的数据，也是记录在这个表中的。
查询流程的 dataObject 数据：
/** * 查询一个流程的所有 DataObject 对象 */@Testvoid test10() &#123;    List&lt;Execution&gt; list = runtimeService.createExecutionQuery().list();    for (Execution execution : list) &#123;        Map&lt;String, DataObject&gt; dataObjects = runtimeService.getDataObjects(execution.getId());        Set&lt;String&gt; keySet = dataObjects.keySet();        for (String key : keySet) &#123;            DataObject data = dataObjects.get(key);            logger.info(&quot;id:&#123;&#125;,name:&#123;&#125;,value:&#123;&#125;,type:&#123;&#125;&quot;,data.getId(),data.getName(),data.getValue(),data.getType());        &#125;    &#125;&#125;/** * 流程执行实例，在一个流程中，查询 DataObject 的数据 * * : ==&gt;  Preparing: select * from ACT_RU_VARIABLE WHERE EXECUTION_ID_ = ? AND TASK_ID_ is null AND NAME_ = ? * : ==&gt; Parameters: 0e557214-43f6-11ed-a596-acde48001122(String), 流程作者网站(String) * : &lt;==      Total: 1 * * 查询某一个具体的 dataObject 对象 * */@Testvoid test09() &#123;    DataObject data = runtimeService.getDataObject(&quot;0e557214-43f6-11ed-a596-acde48001122&quot;, &quot;流程作者网站&quot;);    logger.info(&quot;id:&#123;&#125;,name:&#123;&#125;,value:&#123;&#125;,type:&#123;&#125;&quot;,data.getId(),data.getName(),data.getValue(),data.getType());&#125;

注意，当一个流程执行完毕后，ACT_RU_VARIABLE 表中，dataObject 的数据会被清除掉。

Flowable 中的租户
tenant

假如我们有 A、B、C、D 四个子系统，现在四个子系统都需要部署一个名为 leave 的流程，那么如何区分这个流程呢？通过租户 Tenant 可以解决。

如果我们在部署一个流程定义的时候，使用到了租户 ID，那么流程启动的时候，也必须指定租户 ID。

当我们部署一个流程定义的时候，可以通过如下方式指定这个流程的租户 ID：
/** * 这个就是我的流程部署接口，流程部署将来要上传一个文件，这个文件就是流程的 XML 文件 * * @param file * @param tenantId 这个是租户 id，用来区分这个流程是属于哪一个租户的 * @return */@PostMapping(&quot;/deploy&quot;)public RespBean deploy(MultipartFile file,String tenantId) throws IOException &#123;    DeploymentBuilder deploymentBuilder = repositoryService            //开始流程部署的构建            .createDeployment()            .name(&quot;JAVABOY的工作流&quot;)//ACT_RE_DEPLOYMENT 表中的 NAME_ 属性            .category(&quot;我的流程分类&quot;)//ACT_RE_DEPLOYMENT 表中的 CATEGORY_ 属性            .key(&quot;我的自定义的工作流的 KEY&quot;)//ACT_RE_DEPLOYMENT 表中的 KEY_ 属性            .tenantId(tenantId)            //也可以用这个方法代替 addInputStream，但是注意，这个需要我们自己先去解析 IO 流程，将 XML 文件解析为一个字符串，然后就可以调用这个方法进行部署了              .addString()            //设置文件的输入流程，将来通过这个输入流自动去读取 XML 文件            .addInputStream(file.getOriginalFilename(), file.getInputStream());    //完成项目的部署    Deployment deployment = deploymentBuilder.deploy();    return RespBean.ok(&quot;部署成功&quot;, deployment.getId());&#125;

部署成功之后，在 ACT_RE_PROCDEF 表中，可以看到 TENANT_ID_ 字段的具体值：

  .xtijxqjwomrx{width:70%}




一个流程在定义的时候，如果指定了租户 ID，那么启动的时候，也必须指定租户 ID。
如果在启动流程的时候，没有指定租户 ID，强行启动，会抛出如下错误：

  .cmkjlwesqltx{width:70%}


启动一个带租户 ID 的流程，应该按照如下方式来启动；
/** * 启动参数中，携带租户 ID */@Testvoid test11() &#123;    //设置流程的发起人    Authentication.setAuthenticatedUserId(&quot;wangwu&quot;);    //这个流程定义的 key 实际上就是流程 XML 文件中的流程 id    String processDefinitionKey = &quot;leave&quot;;    //流程启动成功之后，可以获取到一个流程实例    ProcessInstance pi = runtimeService.startProcessInstanceByKeyAndTenantId(processDefinitionKey,&quot;javaboy&quot;);    logger.info(&quot;definitionId:&#123;&#125;,id:&#123;&#125;,name:&#123;&#125;&quot;, pi.getProcessDefinitionId(), pi.getId(), pi.getName());&#125;



对于带有租户 ID 的流程，在执行具体的 Task 的时候，是不需要指定租户 ID 的。
但是在 ACT_RU_TASK表中，存在 TENANT_ID_字段，这个字段表示这个 Task 所属的租户。所以，虽然我们执行 Task 不需要租户 ID，但是，我们可以利用租户 ID 去查询一个 Task。
/** * 根据租户 ID 查询一个 Task *  * : ==&gt;  Preparing: SELECT RES.* from ACT_RU_TASK RES WHERE RES.TENANT_ID_ = ? order by RES.ID_ asc * : ==&gt; Parameters: javaboy(String) * : &lt;==      Total: 1 * */@Testvoid test12() &#123;    List&lt;Task&gt; list = taskService.createTaskQuery().taskTenantId(&quot;javaboy&quot;).list();    for (Task task : list) &#123;        logger.info(&quot;name:&#123;&#125;,assignee:&#123;&#125;&quot;,task.getName(),task.getAssignee());    &#125;&#125;


流程任务 ReceiveTask
这个就是一个接收任务，任务到达这个节点之后，一般来说，不需要额外做什么事情，但是需要用户手动 trigger 一下。
如果一个需要等待的任务，可以自动判断各种条件是否成熟，则可以通过并行网关去处理，但是如果无法自动判断，则需要通过 ReceiveTask 去处理，所以 ReceiveTask 就是让流程停在某一个节点上，然后人工判断一下流程是否继续往下走。

  .ikrftyhennyf{width:70%}


这种带信封图标的任务，就是一个 ReceiveTask，不同于 UserTask，这种 ReceiveTask 是不需要设置处理人的。
绘制好流程图之后，部署并启动。
启动代码：
@Testvoid test01() &#123;    ProcessInstance pi = runtimeService.startProcessInstanceByKeyAndTenantId(&quot;ReceiveTaskDemo&quot;, &quot;javaboy&quot;);    logger.info(&quot;id:&#123;&#125;,name:&#123;&#125;&quot;, pi.getId(), pi.getName());&#125;

启动成功之后，流程就会停在 统计今日销售额 这个节点上，然后执行如下代码，流程进入到下一个节点：
@Testvoid test02() &#123;    List&lt;Execution&gt; list = runtimeService.createExecutionQuery().activityId(&quot;统计今日销售额节点 ID&quot;).list();    for (Execution execution : list) &#123;        //触发一个 ReceiveTask 继续向下执行，但是这里需要的参数是一个        runtimeService.trigger(execution.getId());    &#125;&#125;

ps: 统计今日销售额节点 ID要在导出的xml文件里面copy

  .isjsnqsyqfsm{width:70%}


再继续，执行最后一个节点：
@Testvoid test02() &#123;    List&lt;Execution&gt; list = runtimeService.createExecutionQuery().activityId(&quot;发送报告给老板的节点 ID&quot;).list();    for (Execution execution : list) &#123;        //触发一个 ReceiveTask 继续向下执行，但是这里需要的参数是一个        runtimeService.trigger(execution.getId());    &#125;&#125;

**注意，**ReceiveTask 是不进 ACT_RU_TASK 表的，它默认被记录在 ACT_RU_EXECUTION表和 ACT_RU_ACTINST表中。
UserTask这个就是用户任务，是 Flowable 中使用最多的一种任务类型，流程走到这个节点的时候，需要用户手动处理，然后才会继续向下走。
设置单个用户这种 UserTask，指定它的处理人，有四种不同的方式。
直接指定具体用户
  .spyccyiijmve{width:70%}


然后启动流程：
@Testvoid test01() &#123;    ProcessInstance pi = runtimeService.startProcessInstanceByKey(&quot;UserTaskDemo&quot;);    logger.info(&quot;id:&#123;&#125;,name:&#123;&#125;&quot;, pi.getId(), pi.getName());&#125;

流程启动成功之后，就自动进入到用户审批这个节点了，需要用户处理的 UserTask 都保存在 ACT_RU_TASK表中。

  .qjsupsneqabu{width:70%}


接下来，查询某一个用户需要处理的 Task：
/** * 查询某一个用户需要处理的任务 * * 这个查询对应的 SQL： * * SELECT RES.* from ACT_RU_TASK RES WHERE RES.ASSIGNEE_ = ? order by RES.ID_ asc */@Testvoid test02() &#123;    List&lt;Task&gt; list = taskService.createTaskQuery().taskAssignee(&quot;javaboy&quot;).list();    for (Task task : list) &#123;        logger.info(&quot;name:&#123;&#125;,assignee:&#123;&#125;&quot;, task.getName(), task.getAssignee());    &#125;&#125;

查询到用户需要处理的任务之后，有两种不同的处理思路：

委派给其他人处理
直接自己处理了

委派给其他人/** * 将 javaboy 需要处理的任务委派给 zhangsan 去处理 *  * 具体的 SQL 如下： *  * update ACT_RU_TASK SET REV_ = ?, ASSIGNEE_ = ? where ID_= ? and REV_ = ? */@Testvoid test03() &#123;    List&lt;Task&gt; list = taskService.createTaskQuery().taskAssignee(&quot;javaboy&quot;).list();    for (Task task : list) &#123;        //为某一个 Task 设置处理人        taskService.setAssignee(task.getId(), &quot;zhangsan&quot;);    &#125;&#125;

这个委派，本质上就是修改了 ACT_RU_TASK表中相应的 Task 的记录的 ASSIGNEE_的值。
直接自己处理了/** * 自己来处理任务 */@Testvoid test04() &#123;    List&lt;Task&gt; list = taskService.createTaskQuery().taskAssignee(&quot;zhangsan&quot;).list();    for (Task task : list) &#123;        //查询到 zhangsan 的任务，并自己处理        taskService.complete(task.getId());    &#125;&#125;



通过变量来设置
  .cbmwukwiqrbu{width:70%}


设置任务的处理人的时候，使用变量，${xxx} 就是一个变量引用。
对应的 XML 内容如下：
&lt;userTask id=&quot;sid-E37FEEFF-D8D5-4450-9D2D-67F9B2EBEE2A&quot; name=&quot;用户审批&quot; flowable:assignee=&quot;$&#123;manager&#125;&quot; flowable:formFieldValidation=&quot;true&quot;&gt;  &lt;extensionElements&gt;    &lt;modeler:initiator-can-complete xmlns:modeler=&quot;http://flowable.org/modeler&quot;&gt;&lt;![CDATA[false]]&gt;&lt;/modeler:initiator-can-complete&gt;  &lt;/extensionElements&gt;&lt;/userTask&gt;

启动流程，启动的时候顺便指定任务的处理人：
/** * 启动一个流程，在启动的时候，指定任务的处理人 */@Testvoid test05() &#123;    Map&lt;String, Object&gt; vars = new HashMap&lt;&gt;();    vars.put(&quot;manager&quot;, &quot;lisi&quot;);    //在流程启动的时候，通过变量去指定任务的处理人    ProcessInstance pi = runtimeService.startProcessInstanceByKey(&quot;UserTaskDemo&quot;, vars);    logger.info(&quot;id:&#123;&#125;,name:&#123;&#125;&quot;, pi.getId(), pi.getName());&#125;

启动成功之后，在 ACT_RU_TASK表中，可以看到任务的处理人已经是 lisi 了。

  .wyigclmkxoaw{width:70%}




通过监听器来设置利用监听器，我们可以在一个任务创建的时候，为这个任务设置一个处理人。

  .tpaacaiclffm{width:70%}



  .avazwllrgboy{width:70%}


此时对应的 UserTask 节点内容如下：
&lt;userTask id=&quot;sid-E37FEEFF-D8D5-4450-9D2D-67F9B2EBEE2A&quot; name=&quot;用户审批&quot; flowable:formFieldValidation=&quot;true&quot;&gt;  &lt;extensionElements&gt;    &lt;flowable:taskListener event=&quot;create&quot; class=&quot;org.javaboy.flowableprocess.listener.MyTaskListener&quot;&gt;&lt;/flowable:taskListener&gt;  &lt;/extensionElements&gt;&lt;/userTask&gt;

对应的监听器代码如下：
public class MyTaskListener implements TaskListener &#123;    /**     * 当任务被创建的时候，这个方法会被触发     * @param delegateTask     */    @Override    public void notify(DelegateTask delegateTask) &#123;        //可以在这里设置任务的处理人        delegateTask.setAssignee(&quot;wangwu&quot;);    &#125;&#125;





设置为流程的发起人首先在开始节点上，设置流程的发起人，这个地方给出的流程发起人，实际上是一个变量的名称，所以，这个名字怎么取都行。

  .pjvdeqmfrlqp{width:70%}


然后，给 UserTask 设置处理人的时候，采用第二种方案，然后变量的名称就是发起人这个变量名称：

  .rfufbdqilznc{width:70%}


接下来，在流程启动的时候，需要指定流程的发起人：
/** * 启动一个流程，并设置流程的发起人 * * 流程的发起人有两种不同的设置方式： * * 第一种： */@Testvoid test06() &#123;    //设置流程当前的处理人（一会流程启动的时候，会将这里设置的作为流程的发起人）    Authentication.setAuthenticatedUserId(&quot;zhaoliu&quot;);    ProcessInstance pi = runtimeService.startProcessInstanceByKey(&quot;UserTaskDemo&quot;);    logger.info(&quot;id:&#123;&#125;,name:&#123;&#125;&quot;, pi.getId(), pi.getName());&#125;

Authentication.setAuthenticatedUserId(&quot;zhaoliu&quot;);实际上就是用来指定流程的发起人的。
第二种设置流程发起人的方式：
@AutowiredIdentityService identityService;/** * 第二种流程发起人的设置方式 */@Testvoid test07() &#123;    identityService.setAuthenticatedUserId(&quot;fengqi&quot;);    ProcessInstance pi = runtimeService.startProcessInstanceByKey(&quot;UserTaskDemo&quot;);    logger.info(&quot;id:&#123;&#125;,name:&#123;&#125;&quot;, pi.getId(), pi.getName());&#125;


设置多个用户直接指定直接指定多个候选用户：

  .uotvluvovqxf{width:70%}


对应的 XML 内容如下：
&lt;process id=&quot;UserTaskDemo&quot; name=&quot;UserTaskDemo&quot; isExecutable=&quot;true&quot;&gt;  &lt;documentation&gt;UserTaskDemo&lt;/documentation&gt;  &lt;startEvent id=&quot;startEvent1&quot; flowable:initiator=&quot;INITATOR&quot; flowable:formFieldValidation=&quot;true&quot;&gt;&lt;/startEvent&gt;  &lt;userTask id=&quot;sid-E37FEEFF-D8D5-4450-9D2D-67F9B2EBEE2A&quot; name=&quot;用户审批&quot; flowable:candidateUsers=&quot;zhangsan,lisi,wangwu&quot; flowable:formFieldValidation=&quot;true&quot;&gt;&lt;/userTask&gt;  &lt;sequenceFlow id=&quot;sid-3CC50988-362A-4917-8E96-7DC71CA18A76&quot; sourceRef=&quot;startEvent1&quot; targetRef=&quot;sid-E37FEEFF-D8D5-4450-9D2D-67F9B2EBEE2A&quot;&gt;&lt;/sequenceFlow&gt;  &lt;endEvent id=&quot;sid-4691C57C-BABD-4D39-BB14-FA2D78C951AE&quot;&gt;&lt;/endEvent&gt;  &lt;sequenceFlow id=&quot;sid-098AAEF6-D1F2-4CAB-B365-0C7A85353222&quot; sourceRef=&quot;sid-E37FEEFF-D8D5-4450-9D2D-67F9B2EBEE2A&quot; targetRef=&quot;sid-4691C57C-BABD-4D39-BB14-FA2D78C951AE&quot;&gt;&lt;/sequenceFlow&gt;&lt;/process&gt;

flowable:candidateUsers=&quot;zhangsan,lisi,wangwu&quot;就是设置流程可以由多个用户来处理，多个用户之间使用 ,隔开。
接下来部署并启动流程。
@Test    void Test01()&#123;        ProcessInstance pi = runtimeService.startProcessInstanceByKey(&quot;UserTaskDemo&quot;);        logger.info(&quot;id:&#123;&#125;,name:&#123;&#125;&quot;,pi.getId(),pi.getName());    &#125;



接下来，查询某一个用户需要处理的任务的时候，不能再继续使用之前的方案了，因为当一个 UserTask 有多个用户可以处理的时候，那么在 ACT_RU_TASK这个表中，是无法完全记录这个 Task 的处理人的，所以此时该表中的 ASSIGNEE_字段就为 null。
流程启动之后，如果想要根据用户名去查询该用户能够处理的任务，方式如下：
/** * 根据候选人去查询任务 * * 对应的 SQL 如下： * * SELECT RES.* from ACT_RU_TASK RES WHERE RES.ASSIGNEE_ is null and exists(select LINK.ID_ from ACT_RU_IDENTITYLINK LINK  * where LINK.TYPE_ = &#x27;candidate&#x27; and LINK.TASK_ID_ = RES.ID_ and ( LINK.USER_ID_ = ? ) ) order by RES.ID_ asc * * 从 SQL 中 ，可以看到，任务由哪些用户来处理，主要是由 ACT_RU_IDENTITYLINK 表来维护。 * */@Testvoid test08() &#123;    List&lt;Task&gt; tasks = taskService.createTaskQuery().taskCandidateUser(&quot;zhangsan&quot;).list();    for (Task task : tasks) &#123;        logger.info(&quot;name:&#123;&#125;,CreateTime:&#123;&#125;&quot;, task.getName(), task.getCreateTime());    &#125;&#125;

上面这个是根据候选人来查询一个任务。
有的时候，我们已知流程的信息，想去查询流程的参与人，那么可以使用如下方式：
/** * 根据流程的 ID 查询流程的参与者 *  * 对应的 SQL： *  * select * from ACT_RU_IDENTITYLINK where PROC_INST_ID_ = ? */@Testvoid test09() &#123;    ProcessInstance pi = runtimeService.createProcessInstanceQuery().singleResult();    //根据流程的 ID 去查询流程的参与者    List&lt;IdentityLink&gt; links = runtimeService.getIdentityLinksForProcessInstance(pi.getId());    for (IdentityLink link : links) &#123;        logger.info(&quot;流程参与人：&#123;&#125;&quot;,link.getUserId());    &#125;&#125;

从上面这个查询中可以看到，ACT_RU_IDENTITYLINK表实际上有两方面的功能：

记录了每一个 Task 的候选人 TASK_ID_
记录了流程的参与人 PROC_INST_ID_

根据候选人找到 Task 之后，此时需要首先认领这个任务。认领的本质，其实就是给 ACT_RU_TASK表的 ASSIGNEE_字段设置值。
任务认领：
/** * 认领任务 * * 这个认领，对应的 SQL： * * update ACT_RU_TASK SET REV_ = ?, ASSIGNEE_ = ?, CLAIM_TIME_ = ? where ID_= ? and REV_ = ? */@Testvoid test10() &#123;    List&lt;Task&gt; tasks = taskService.createTaskQuery().taskCandidateUser(&quot;zhangsan&quot;).list();    for (Task task : tasks) &#123;        //认领，zhangsan 来认领这个任务        taskService.claim(task.getId(), &quot;zhangsan&quot;);    &#125;&#125;

已经被认领的任务，能不能再次被认领？
已经被认领的任务，无法再次被认领，但是如果你认领了之后，又不想自己处理，可以使用之前说的委派的方式，交给其他人去处理。
如下：
@Test    void test03() &#123;        List&lt;Task&gt; list = taskService.createTaskQuery().taskAssignee(&quot;zhangsan&quot;).list();        for (Task task : list) &#123;            //为某一个 Task 设置处理人            taskService.setAssignee(task.getId(), &quot;lisi&quot;);        &#125;    &#125;

使用变量或者监听器变量
  .ggylfwqxjlwg{width:70%}


将来启动流程的时候，必须要指定候选人：
@Testvoid test12() &#123;    Map&lt;String, Object&gt; vars = new HashMap&lt;&gt;();    //设置多个处理用户，多个处理用户之间用 , 隔开    vars.put(&quot;userIds&quot;, &quot;zhangsan,lisi,wangwu&quot;);    runtimeService.startProcessInstanceByKey(&quot;UserTaskDemo&quot;, vars);&#125;

监听器也可以通过监听器来设置：
public class MyTaskCandidateUsersListener implements TaskListener &#123;    @Override    public void notify(DelegateTask delegateTask) &#123;        delegateTask.addCandidateUser(&quot;zhangsan&quot;);        delegateTask.addCandidateUser(&quot;lisi&quot;);        delegateTask.addCandidateUser(&quot;wangwu&quot;);    &#125;&#125;

然后删除掉任务的处理人，再为任务设置监听器。
接下来启动处理，和前面基本一致。
任务回退就是已经认领的任务，再退回去（这样其他人就可以认领了）。
/** * 任务回退 *  * 对应的 SQL 如下： *  * update ACT_RU_TASK SET REV_ = ?, ASSIGNEE_ = ? where ID_= ? and REV_ = ? */@Testvoid test13() &#123;    List&lt;Task&gt; tasks = taskService.createTaskQuery().taskAssignee(&quot;lisi&quot;).list();    for (Task task : tasks) &#123;        //设置任务的处理人为 null，就表示任务回退        taskService.setAssignee(task.getId(), null);    &#125;&#125;





流程候选人的添加与删除/** * 删除一个任务的候选人 * * 对应的 SQL 如下： * * delete from ACT_RU_IDENTITYLINK where ID_ = ? * * 实际上，是根据 wangwu + taskId 去 ACT_RU_IDENTITYLINK 表中查询到记录的详细信息 select * from ACT_RU_IDENTITYLINK where TASK_ID_ = ? and USER_ID_ = ? and TYPE_ = ?，然后再去删除 */@Testvoid test15() &#123;    Task task = taskService.createTaskQuery().singleResult();    taskService.deleteCandidateUser(task.getId(),&quot;wangwu&quot;);&#125;/** * 为任务增加候选人 * * 对应的 SQL 如下： * * insert into ACT_RU_IDENTITYLINK (ID_, REV_, TYPE_, USER_ID_, GROUP_ID_, TASK_ID_, PROC_INST_ID_, PROC_DEF_ID_, SCOPE_ID_, SUB_SCOPE_ID_, SCOPE_TYPE_, SCOPE_DEFINITION_ID_)  * values (?, 1, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) , (?, 1, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) */@Testvoid test14() &#123;    Task task = taskService.createTaskQuery().singleResult();    taskService.addCandidateUser(task.getId(), &quot;zhaoliu&quot;);    taskService.addCandidateUser(task.getId(), &quot;javaboy&quot;);&#125;


按照角色分配任务处理人先准备数据：
/** * 创建 zhangsan 和 lisi 两个用户 * 创建名为 g1 的用户组 * 设置 zhangsan 和 lisi 都属于 g1 */@Testvoid test16() &#123;    UserEntityImpl u1 = new UserEntityImpl();    u1.setRevision(0);    u1.setEmail(&quot;zhangsan@qq.com&quot;);    u1.setPassword(&quot;123&quot;);    u1.setId(&quot;zhangsan&quot;);    u1.setDisplayName(&quot;张三&quot;);    identityService.saveUser(u1);    UserEntityImpl u2 = new UserEntityImpl();    u2.setRevision(0);    u2.setEmail(&quot;lisi@qq.com&quot;);    u2.setPassword(&quot;123&quot;);    u2.setId(&quot;lisi&quot;);    u2.setDisplayName(&quot;李四&quot;);    identityService.saveUser(u2);    GroupEntityImpl g1 = new GroupEntityImpl();    g1.setRevision(0);    g1.setId(&quot;manager&quot;);    g1.setName(&quot;经理&quot;);    identityService.saveGroup(g1);    identityService.createMembership(&quot;zhangsan&quot;, &quot;manager&quot;);    identityService.createMembership(&quot;lisi&quot;, &quot;manager&quot;);&#125;   



可以直接指定组名称，也可以通过变量来指定。
 直接指定名称 

  .tyqlcchfvvqw{width:70%}




对应的 XML 文件内容如下：
&lt;process id=&quot;UserTaskDemo&quot; name=&quot;UserTaskDemo&quot; isExecutable=&quot;true&quot;&gt;  &lt;documentation&gt;UserTaskDemo&lt;/documentation&gt;  &lt;startEvent id=&quot;startEvent1&quot; flowable:initiator=&quot;INITATOR&quot; flowable:formFieldValidation=&quot;true&quot;&gt;&lt;/startEvent&gt;  &lt;userTask id=&quot;sid-E37FEEFF-D8D5-4450-9D2D-67F9B2EBEE2A&quot; name=&quot;用户审批&quot; flowable:candidateGroups=&quot;manager&quot; flowable:formFieldValidation=&quot;true&quot;&gt;&lt;/userTask&gt;  &lt;sequenceFlow id=&quot;sid-3CC50988-362A-4917-8E96-7DC71CA18A76&quot; sourceRef=&quot;startEvent1&quot; targetRef=&quot;sid-E37FEEFF-D8D5-4450-9D2D-67F9B2EBEE2A&quot;&gt;&lt;/sequenceFlow&gt;  &lt;endEvent id=&quot;sid-4691C57C-BABD-4D39-BB14-FA2D78C951AE&quot;&gt;&lt;/endEvent&gt;  &lt;sequenceFlow id=&quot;sid-098AAEF6-D1F2-4CAB-B365-0C7A85353222&quot; sourceRef=&quot;sid-E37FEEFF-D8D5-4450-9D2D-67F9B2EBEE2A&quot; targetRef=&quot;sid-4691C57C-BABD-4D39-BB14-FA2D78C951AE&quot;&gt;&lt;/sequenceFlow&gt;&lt;/process&gt;

其中，flowable:candidateGroups=&quot;manager&quot;就是用来指定候选组。
接下来，可以根据候选用户去查询任务：
/** * 根据候选人去查询任务（可能 zhangsan 就是候选人，也可能 zhangsan 属于某一个或者某多个用户组，那么此时就需要先查询到 zhangsan 所属的用户组，然后再根据用户组去查询对应的任务） * * 这个查询实际上分为两步： * * 1. 执行的 SQL 如下：SELECT RES.* from ACT_ID_GROUP RES WHERE exists(select 1 from ACT_ID_MEMBERSHIP M where M.GROUP_ID_ = RES.ID_ and M.USER_ID_ = ?) order by RES.ID_ asc * 第一步这个 SQL 可以查询出来这个 zhangsan 所属的用户组 * * 2. 执行的 SQL 如下： * SELECT RES.* from ACT_RU_TASK RES WHERE RES.ASSIGNEE_ is null and * exists(select LINK.ID_ from ACT_RU_IDENTITYLINK LINK where LINK.TYPE_ = &#x27;candidate&#x27; and LINK.TASK_ID_ = RES.ID_ and * ( LINK.USER_ID_ = ? or ( LINK.GROUP_ID_ IN ( ? ) ) ) ) order by RES.ID_ asc *  * 综上： 【这个 SQL，本质上是查询 zhangsan 或者 zhangsan 所属的用户组的任务】 *  */@Testvoid test17() &#123;    Task task = taskService.createTaskQuery().taskCandidateUser(&quot;zhangsan&quot;).singleResult();    logger.info(&quot;name:&#123;&#125;,createTime:&#123;&#125;&quot;, task.getName(), task.getCreateTime());&#125;

也可以根据候选组去查询任务：
/** * 也可以根据候选用户组去查询一个任务 *  * 对应的 SQL 如下： *  * SELECT RES.* from ACT_RU_TASK RES WHERE RES.ASSIGNEE_ is null and exists(select LINK.ID_ from ACT_RU_IDENTITYLINK LINK where LINK.TYPE_ = &#x27;candidate&#x27;  * and LINK.TASK_ID_ = RES.ID_ and ( ( LINK.GROUP_ID_ IN ( ? ) ) ) ) order by RES.ID_ asc *  * 这个查询一步到位，直接指定候选组即可 *  */@Testvoid test18() &#123;    Task task = taskService.createTaskQuery().taskCandidateGroup(&quot;manager&quot;).singleResult();    logger.info(&quot;name:&#123;&#125;,createTime:&#123;&#125;&quot;, task.getName(), task.getCreateTime());&#125;

这种任务在具体执行的过程中，也需要先认领，再执行。
@Testvoid Test19()&#123;    Task task = taskService.createTaskQuery().taskCandidateGroup(&quot;manager&quot;).singleResult();    taskService.claim(task.getId(),&quot;zhangsan&quot;);//认领    taskService.complete(task.getId());//执行&#125;





通过变量来指定
  .xdtmahateyms{width:70%}


对应的 XML 如下：
&lt;process id=&quot;UserTaskDemo&quot; name=&quot;UserTaskDemo&quot; isExecutable=&quot;true&quot;&gt;  &lt;documentation&gt;UserTaskDemo&lt;/documentation&gt;  &lt;startEvent id=&quot;startEvent1&quot; flowable:initiator=&quot;INITATOR&quot; flowable:formFieldValidation=&quot;true&quot;&gt;&lt;/startEvent&gt;  &lt;userTask id=&quot;sid-E37FEEFF-D8D5-4450-9D2D-67F9B2EBEE2A&quot; name=&quot;用户审批&quot; flowable:candidateGroups=&quot;$&#123;g&#125;&quot; flowable:formFieldValidation=&quot;true&quot;&gt;&lt;/userTask&gt;  &lt;sequenceFlow id=&quot;sid-3CC50988-362A-4917-8E96-7DC71CA18A76&quot; sourceRef=&quot;startEvent1&quot; targetRef=&quot;sid-E37FEEFF-D8D5-4450-9D2D-67F9B2EBEE2A&quot;&gt;&lt;/sequenceFlow&gt;  &lt;endEvent id=&quot;sid-4691C57C-BABD-4D39-BB14-FA2D78C951AE&quot;&gt;&lt;/endEvent&gt;  &lt;sequenceFlow id=&quot;sid-098AAEF6-D1F2-4CAB-B365-0C7A85353222&quot; sourceRef=&quot;sid-E37FEEFF-D8D5-4450-9D2D-67F9B2EBEE2A&quot; targetRef=&quot;sid-4691C57C-BABD-4D39-BB14-FA2D78C951AE&quot;&gt;&lt;/sequenceFlow&gt;&lt;/process&gt;



设置用户组的位置 flowable:candidateGroups=&quot;$&#123;g&#125;&quot;。
启动流程的时候，为用户组设置变量值：
@Testvoid test20() &#123;    Map&lt;String, Object&gt; vars = new HashMap&lt;&gt;();    vars.put(&quot;g&quot;, &quot;manager&quot;);    ProcessInstance pi = runtimeService.startProcessInstanceByKey(&quot;UserTaskDemo&quot;,vars);    logger.info(&quot;id:&#123;&#125;,name:&#123;&#125;&quot;, pi.getId(), pi.getName());&#125;

ServiceTask服务任务：由系统自动完成的任务，流程走到这一步的时候，会自动执行下一步，而不会停下来。
监听类首先定义一个监听器类：
/** * 这是我们自定义的监听器类，这个类也就是 ServiceTask 执行到这里的时候，会自动执行该类中的 execute 方法 */public class MyServiceTask01 implements JavaDelegate &#123;    @Override    public void execute(DelegateExecution execution) &#123;        System.out.println(&quot;=============MyServiceTask01=============&quot;);    &#125;&#125;

在绘制流程图的时候，为 ServiceTask 配置监听器类：

  .dbosuhonosgq{width:70%}


 流程对应的XML文件：
&lt;process id=&quot;ServiceTaskDemo01&quot; name=&quot;ServiceTaskDemo01&quot; isExecutable=&quot;true&quot;&gt;  &lt;documentation&gt;ServiceTaskDemo01&lt;/documentation&gt;  &lt;startEvent id=&quot;startEvent1&quot; flowable:formFieldValidation=&quot;true&quot;&gt;&lt;/startEvent&gt;  &lt;sequenceFlow id=&quot;sid-C6258E73-95C1-44EB-8AE9-8ECEE426833B&quot; sourceRef=&quot;startEvent1&quot; targetRef=&quot;sid-768328FE-5C7F-4DF5-B145-18F5B206EC9C&quot;&gt;&lt;/sequenceFlow&gt;  &lt;serviceTask id=&quot;sid-768328FE-5C7F-4DF5-B145-18F5B206EC9C&quot; flowable:class=&quot;com.lcdzzz.flowableprocess.servicetask.MyServiceTask01&quot;&gt;&lt;/serviceTask&gt;  &lt;endEvent id=&quot;sid-0EF3775F-8202-49EB-86CB-8705A50B9E31&quot;&gt;&lt;/endEvent&gt;  &lt;sequenceFlow id=&quot;sid-98FB240A-C264-4947-9063-9B686A366FF5&quot; sourceRef=&quot;sid-768328FE-5C7F-4DF5-B145-18F5B206EC9C&quot; targetRef=&quot;sid-0EF3775F-8202-49EB-86CB-8705A50B9E31&quot;&gt;&lt;/sequenceFlow&gt;&lt;/process&gt;

关键指令： flowable:class=&quot;com.lcdzzz.flowableprocess.servicetask.MyServiceTask01&quot;。
流程测试：
@SpringBootTestpublic class ServiceTaskTest &#123;    @Autowired    RuntimeService runtimeService;    @Test    void test01() &#123;        runtimeService.startProcessInstanceByKey(&quot;ServiceTaskDemo01&quot;);    &#125;&#125;

上面这个流程测试只有一个 ServiceTask 这个节点，所以流程启动成功之后，就会自动执行完毕！

注意，ServiceTask 在执行的过程中，任务的记录是不会保存到 ACT_RU_TASK表中的，这一点与 UserTask 不同。



为类设置字段
  .qafwsspzfirs{width:70%}


双击“未选择字段”

  .cxsqrplapttf{width:70%}


流程图对应的 XML 文件内容如下：
&lt;process id=&quot;ServiceTaskDemo01&quot; name=&quot;ServiceTaskDemo01&quot; isExecutable=&quot;true&quot;&gt;   &lt;documentation&gt;ServiceTaskDemo01&lt;/documentation&gt;   &lt;startEvent id=&quot;startEvent1&quot; flowable:formFieldValidation=&quot;true&quot;&gt;&lt;/startEvent&gt;   &lt;sequenceFlow id=&quot;sid-C6258E73-95C1-44EB-8AE9-8ECEE426833B&quot; sourceRef=&quot;startEvent1&quot; targetRef=&quot;sid-768328FE-5C7F-4DF5-B145-18F5B206EC9C&quot;&gt;&lt;/sequenceFlow&gt;   &lt;serviceTask id=&quot;sid-768328FE-5C7F-4DF5-B145-18F5B206EC9C&quot; flowable:class=&quot;com.lcdzzz.flowableprocess.servicetask.MyServiceTask01&quot;&gt;     &lt;extensionElements&gt;       &lt;flowable:field name=&quot;username&quot;&gt;         &lt;flowable:string&gt;&lt;![CDATA[javaboy]]&gt;&lt;/flowable:string&gt;       &lt;/flowable:field&gt;     &lt;/extensionElements&gt;   &lt;/serviceTask&gt;   &lt;endEvent id=&quot;sid-0EF3775F-8202-49EB-86CB-8705A50B9E31&quot;&gt;&lt;/endEvent&gt;   &lt;sequenceFlow id=&quot;sid-98FB240A-C264-4947-9063-9B686A366FF5&quot; sourceRef=&quot;sid-768328FE-5C7F-4DF5-B145-18F5B206EC9C&quot; targetRef=&quot;sid-0EF3775F-8202-49EB-86CB-8705A50B9E31&quot;&gt;&lt;/sequenceFlow&gt; &lt;/process&gt;

接下来，在这个监听器类中，就可以获取到 username 的值了：
/** * 这是我们自定义的监听器类，这个类也就是 ServiceTask 执行到这里的时候，会自动执行该类中的 execute 方法 */public class MyServiceTask01 implements JavaDelegate &#123;    Expression username;        @Override    public void execute(DelegateExecution execution) &#123;        //获取 username 的值        System.out.println(&quot;username.getExpressionText() = &quot; + username.getExpressionText());        System.out.println(&quot;username.getValue(execution) = &quot; + username.getValue(execution));        System.out.println(&quot;=============MyServiceTask01=============&quot;);    &#125;&#125;



委托表达式委托表达式类似于监听器类，但是，这种表达式，可以将类注册到 Spring 容器中，然后在给流程图配置的时候，直接配置 Spring 容器中 Bean 的名称即可。
监听器类如下：
@Componentpublic class MyServiceTask02 implements JavaDelegate &#123;    @Override    public void execute(DelegateExecution execution) &#123;        System.out.println(&quot;=============MyServiceTask02==============&quot;);    &#125;&#125;

与上一小节相比，这里通过@Component注解将 MyServiceTask02 注册到 Spring 容器中了。这样，在流程图中，可以直接配置 Bean 的名称即可：

  .pdjphhopekeu{width:70%}


流程图对应的XML内容：
&lt;process id=&quot;ServiceTaskDemo01&quot; name=&quot;ServiceTaskDemo01&quot; isExecutable=&quot;true&quot;&gt;   &lt;documentation&gt;ServiceTaskDemo01&lt;/documentation&gt;   &lt;startEvent id=&quot;startEvent1&quot; flowable:formFieldValidation=&quot;true&quot;&gt;&lt;/startEvent&gt;   &lt;sequenceFlow id=&quot;sid-C6258E73-95C1-44EB-8AE9-8ECEE426833B&quot; sourceRef=&quot;startEvent1&quot; targetRef=&quot;sid-768328FE-5C7F-4DF5-B145-18F5B206EC9C&quot;&gt;&lt;/sequenceFlow&gt;   &lt;serviceTask id=&quot;sid-768328FE-5C7F-4DF5-B145-18F5B206EC9C&quot; flowable:delegateExpression=&quot;$&#123;myServiceTask02&#125;&quot;&gt;&lt;/serviceTask&gt;   &lt;endEvent id=&quot;sid-0EF3775F-8202-49EB-86CB-8705A50B9E31&quot;&gt;&lt;/endEvent&gt;   &lt;sequenceFlow id=&quot;sid-98FB240A-C264-4947-9063-9B686A366FF5&quot; sourceRef=&quot;sid-768328FE-5C7F-4DF5-B145-18F5B206EC9C&quot; targetRef=&quot;sid-0EF3775F-8202-49EB-86CB-8705A50B9E31&quot;&gt;&lt;/sequenceFlow&gt; &lt;/process&gt;

flowable:delegateExpression=&quot;$&#123;myServiceTask02&#125;&quot;则描述了执行对应的 ServiceTask 的 Bean。
表达式前面两种，无论是直接配置类的全路径，还是配置 Bean 的名称，都离不开 JavaDelegate
@Componentpublic class MyServiceTask03 &#123;        public void hello() &#123;        System.out.println(&quot;=============MyServiceTask03=============&quot;);    &#125;&#125;




  .ebutmbtrmsqn{width:70%}



  .zmeusnwxcllb{width:70%}


&lt;process id=&quot;ServiceTaskDemo01&quot; name=&quot;ServiceTaskDemo01&quot; isExecutable=&quot;true&quot;&gt;    &lt;documentation&gt;ServiceTaskDemo01&lt;/documentation&gt;    &lt;startEvent id=&quot;startEvent1&quot; flowable:formFieldValidation=&quot;true&quot;&gt;&lt;/startEvent&gt;    &lt;sequenceFlow id=&quot;sid-BF8668E7-6CA2-4F17-BD6B-0D0E17FB1C48&quot; sourceRef=&quot;startEvent1&quot; targetRef=&quot;sid-F580AD28-4492-453D-B359-88F001EE4FB7&quot;&gt;&lt;/sequenceFlow&gt;    &lt;serviceTask id=&quot;sid-F580AD28-4492-453D-B359-88F001EE4FB7&quot; flowable:expression=&quot;$&#123;myServiceTask03.hello()&#125;&quot;&gt;&lt;/serviceTask&gt;    &lt;endEvent id=&quot;sid-E1732394-8FED-4FF8-9372-B62BAD7DA1C7&quot;&gt;&lt;/endEvent&gt;    &lt;sequenceFlow id=&quot;sid-0EDD436D-7E0D-4D4C-BC67-0CD2BE26AA4B&quot; sourceRef=&quot;sid-F580AD28-4492-453D-B359-88F001EE4FB7&quot; targetRef=&quot;sid-E1732394-8FED-4FF8-9372-B62BAD7DA1C7&quot;&gt;&lt;/sequenceFlow&gt;  &lt;/process&gt;


 注意，我们在 6.2.1 小节中介绍的给监听器类设置字段的功能，并不适用于表达式这种情况。

ScriptTask脚本任务和 ServiceTask 类似，也是自动执行的。不同的是，脚本任务的逻辑，是通过一些非 Java 的脚本语言来实现的。
JavaScript
  .qocejvgorzxg{width:70%}



  .kstrwxxwrgvo{width:70%}



第一行执行一个加法运算。
第二行往流程中保存一个名为 sum 的流程变量。

对应的 XML：
  &lt;process id=&quot;ScriptTaskDemo01&quot; name=&quot;ScriptTaskDemo01&quot; isExecutable=&quot;true&quot;&gt;    &lt;documentation&gt;ScriptTaskDemo01&lt;/documentation&gt;    &lt;startEvent id=&quot;startEvent1&quot; flowable:formFieldValidation=&quot;true&quot;&gt;&lt;/startEvent&gt;    &lt;sequenceFlow id=&quot;sid-3B965318-F1BE-4155-A599-69B76A93878A&quot; sourceRef=&quot;startEvent1&quot; targetRef=&quot;sid-2690302E-6E4C-4C46-A1E3-7B12F446F667&quot;&gt;&lt;/sequenceFlow&gt;    &lt;endEvent id=&quot;sid-B85B82DB-E801-41EC-ABE2-391947D45055&quot;&gt;&lt;/endEvent&gt;    &lt;sequenceFlow id=&quot;sid-F9A7C6C2-5734-4E69-9D15-45B55D3A4D18&quot; sourceRef=&quot;sid-2690302E-6E4C-4C46-A1E3-7B12F446F667&quot; targetRef=&quot;sid-B85B82DB-E801-41EC-ABE2-391947D45055&quot;&gt;&lt;/sequenceFlow&gt;    &lt;scriptTask id=&quot;sid-2690302E-6E4C-4C46-A1E3-7B12F446F667&quot; scriptFormat=&quot;JavaScript&quot; flowable:autoStoreVariables=&quot;false&quot;&gt;      &lt;script&gt;&lt;![CDATA[var sum=a+b;execution.setVariable(&quot;sum&quot;,sum);]]&gt;&lt;/script&gt;    &lt;/scriptTask&gt;  &lt;/process&gt;


 注意，这个脚本在使用的使用，还不能够使用 let 关键字，可以使用 var 关键字

GroovyGroovy 是基于 JVM 的编程语言。
使用 Groovy 需要首先添加依赖：

  .opdydjzcoqsj{width:70%}



  .atkirjimwtvn{width:70%}


对应的XML文件：
&lt;process id=&quot;ScriptTaskDemo01&quot; name=&quot;ScriptTaskDemo01&quot; isExecutable=&quot;true&quot;&gt;    &lt;documentation&gt;ScriptTaskDemo01&lt;/documentation&gt;    &lt;startEvent id=&quot;startEvent1&quot; flowable:formFieldValidation=&quot;true&quot;&gt;&lt;/startEvent&gt;    &lt;sequenceFlow id=&quot;sid-22A421AF-289E-42C2-A68D-0B91A4A7E7C4&quot; sourceRef=&quot;startEvent1&quot; targetRef=&quot;sid-419BE2B8-7C87-4BF5-98BC-5E535F1D00D0&quot;&gt;&lt;/sequenceFlow&gt;    &lt;scriptTask id=&quot;sid-419BE2B8-7C87-4BF5-98BC-5E535F1D00D0&quot; scriptFormat=&quot;Groovy&quot; flowable:autoStoreVariables=&quot;false&quot;&gt;      &lt;script&gt;&lt;![CDATA[System.out.println(&quot;hello groovy&quot;);]]&gt;&lt;/script&gt;    &lt;/scriptTask&gt;    &lt;endEvent id=&quot;sid-E5DF61BE-B05E-4B4B-A775-F5C3812B132C&quot;&gt;&lt;/endEvent&gt;    &lt;sequenceFlow id=&quot;sid-B2EB7E48-C6A2-41FB-A660-DAFABF0B8526&quot; sourceRef=&quot;sid-419BE2B8-7C87-4BF5-98BC-5E535F1D00D0&quot; targetRef=&quot;sid-E5DF61BE-B05E-4B4B-A775-F5C3812B132C&quot;&gt;&lt;/sequenceFlow&gt;  &lt;/process&gt;

JuelJuel 全称 Java Unified Expression Language。
之前我们写的表达式 ${xxx} 这就是一个 Juel。
比如我想调用下图MyServiceTask03的hello()方法

  .rtylghmbidjy{width:70%}


脚本下
这个脚本就表示执行 Spring 容器中的一个名为 myServiceTask03 的 Bean 的 hello 方法。

  .kdyjmpuseutd{width:70%}



  .qohtsxdryvpe{width:70%}


对应的 XML 文件：
&lt;process id=&quot;ScriptTaskDemo01&quot; name=&quot;ScriptTaskDemo01&quot; isExecutable=&quot;true&quot;&gt;    &lt;documentation&gt;ScriptTaskDemo01&lt;/documentation&gt;    &lt;startEvent id=&quot;startEvent1&quot; flowable:formFieldValidation=&quot;true&quot;&gt;&lt;/startEvent&gt;    &lt;sequenceFlow id=&quot;sid-22A421AF-289E-42C2-A68D-0B91A4A7E7C4&quot; sourceRef=&quot;startEvent1&quot; targetRef=&quot;sid-419BE2B8-7C87-4BF5-98BC-5E535F1D00D0&quot;&gt;&lt;/sequenceFlow&gt;    &lt;scriptTask id=&quot;sid-419BE2B8-7C87-4BF5-98BC-5E535F1D00D0&quot; scriptFormat=&quot;juel&quot; flowable:autoStoreVariables=&quot;false&quot;&gt;      &lt;script&gt;&lt;![CDATA[$&#123;myServiceTask03.hello()&#125;]]&gt;&lt;/script&gt;    &lt;/scriptTask&gt;    &lt;endEvent id=&quot;sid-E5DF61BE-B05E-4B4B-A775-F5C3812B132C&quot;&gt;&lt;/endEvent&gt;    &lt;sequenceFlow id=&quot;sid-B2EB7E48-C6A2-41FB-A660-DAFABF0B8526&quot; sourceRef=&quot;sid-419BE2B8-7C87-4BF5-98BC-5E535F1D00D0&quot; targetRef=&quot;sid-E5DF61BE-B05E-4B4B-A775-F5C3812B132C&quot;&gt;&lt;/sequenceFlow&gt;  &lt;/process&gt;





网关排他网关排他网关也叫互斥网关，互斥网关可以有 N 多个入口，但是只有一个有效出口。
假设我们有一个请假流程，这个请假流程执行的过程中，分三种情况：

请假小于等于 1 天，组长审批。
大于 1 天，小于等于 3 天，经理审批。
大于 3 天，总监审批。


  .lsvduqhmqfri{width:70%}


可以看到，互斥网关可以有 N 多个入口，上图中虽然画出来了三个出口，但是在实际执行中，三个出口只有一个是有效出口。
通过连接线上的流条件，来设置流程的执行：

  .spiysekkkbuk{width:70%}



  .rcahonigikic{width:70%}



  .sjetnwabikbk{width:70%}


对应的 XML 文件如下：
&lt;process id=&quot;ExclusiveGatewayDemo01&quot; name=&quot;ExclusiveGatewayDemo01&quot; isExecutable=&quot;true&quot;&gt;   &lt;documentation&gt;ExclusiveGatewayDemo01&lt;/documentation&gt;   &lt;startEvent id=&quot;startEvent1&quot; flowable:formFieldValidation=&quot;true&quot;&gt;&lt;/startEvent&gt;   &lt;exclusiveGateway id=&quot;sid-A53B391A-3E1C-4622-A546-144B55BC4360&quot;&gt;&lt;/exclusiveGateway&gt;   &lt;sequenceFlow id=&quot;sid-DF8E49A5-20F5-4BF8-A89F-91B77E83D23A&quot; sourceRef=&quot;startEvent1&quot; targetRef=&quot;sid-A53B391A-3E1C-4622-A546-144B55BC4360&quot;&gt;&lt;/sequenceFlow&gt;   &lt;userTask id=&quot;sid-5C7D775C-4893-475D-9C91-F4FE8BF7BAB4&quot; name=&quot;组长审批&quot; flowable:formFieldValidation=&quot;true&quot;&gt;&lt;/userTask&gt;   &lt;userTask id=&quot;sid-93654C2E-8373-4DDD-8B37-6268C9E46B00&quot; name=&quot;经理审批&quot; flowable:formFieldValidation=&quot;true&quot;&gt;&lt;/userTask&gt;   &lt;userTask id=&quot;sid-13C8B753-6D18-4742-846B-8EE2CA905CE4&quot; name=&quot;总监审批&quot; flowable:formFieldValidation=&quot;true&quot;&gt;&lt;/userTask&gt;   &lt;endEvent id=&quot;sid-B71EC429-6213-411B-A761-492224D5ED14&quot;&gt;&lt;/endEvent&gt;   &lt;sequenceFlow id=&quot;sid-43D5DFA2-3670-4D5F-AEAF-4F02DF05BCF1&quot; sourceRef=&quot;sid-5C7D775C-4893-475D-9C91-F4FE8BF7BAB4&quot; targetRef=&quot;sid-B71EC429-6213-411B-A761-492224D5ED14&quot;&gt;&lt;/sequenceFlow&gt;   &lt;sequenceFlow id=&quot;sid-5ED92318-E5FD-4988-BACC-DE195B759CE8&quot; sourceRef=&quot;sid-93654C2E-8373-4DDD-8B37-6268C9E46B00&quot; targetRef=&quot;sid-B71EC429-6213-411B-A761-492224D5ED14&quot;&gt;&lt;/sequenceFlow&gt;   &lt;sequenceFlow id=&quot;sid-B17E4938-5ABA-4092-9C26-27AD71FE3BD9&quot; sourceRef=&quot;sid-13C8B753-6D18-4742-846B-8EE2CA905CE4&quot; targetRef=&quot;sid-B71EC429-6213-411B-A761-492224D5ED14&quot;&gt;&lt;/sequenceFlow&gt;   &lt;sequenceFlow id=&quot;sid-114747E0-9717-4E59-8254-F2FC8CA8ABF1&quot; name=&quot;大于1小于等于3&quot; sourceRef=&quot;sid-A53B391A-3E1C-4622-A546-144B55BC4360&quot; targetRef=&quot;sid-93654C2E-8373-4DDD-8B37-6268C9E46B00&quot;&gt;     &lt;conditionExpression xsi:type=&quot;tFormalExpression&quot;&gt;&lt;![CDATA[$&#123;days&gt;1 &amp;&amp; days&lt;=3&#125;]]&gt;&lt;/conditionExpression&gt;   &lt;/sequenceFlow&gt;   &lt;sequenceFlow id=&quot;sid-A6412882-BAA1-484F-AD31-912A9FD2CCA3&quot; name=&quot;大于3&quot; sourceRef=&quot;sid-A53B391A-3E1C-4622-A546-144B55BC4360&quot; targetRef=&quot;sid-13C8B753-6D18-4742-846B-8EE2CA905CE4&quot;&gt;     &lt;conditionExpression xsi:type=&quot;tFormalExpression&quot;&gt;&lt;![CDATA[$&#123;days&gt;3&#125;]]&gt;&lt;/conditionExpression&gt;   &lt;/sequenceFlow&gt;   &lt;sequenceFlow id=&quot;sid-4CCE2748-C505-4457-BE12-96915A5A1EBD&quot; name=&quot;小于等于1&quot; sourceRef=&quot;sid-A53B391A-3E1C-4622-A546-144B55BC4360&quot; targetRef=&quot;sid-5C7D775C-4893-475D-9C91-F4FE8BF7BAB4&quot;&gt;     &lt;conditionExpression xsi:type=&quot;tFormalExpression&quot;&gt;&lt;![CDATA[$&#123;days&lt;=1&#125;]]&gt;&lt;/conditionExpression&gt;   &lt;/sequenceFlow&gt; &lt;/process&gt;

在 sequenceFlow标签中，有一个 conditionExpression标签，这个标签专门用来设置流程执行的条件。
流程启动的时候，传入 days 变量即可：
@Testvoid test01() &#123;    HashMap&lt;String, Object&gt; vars = new HashMap&lt;&gt;();    vars.put(&quot;days&quot;,10);    runtimeService.startProcessInstanceByKey(&quot;ExclusiveGatewayDemo01&quot;,vars);&#125;



并行网关多个任务同时执行，并且多个任务全部都执行完毕的时候，才会进入到下一个任务。
另外还需要注意一点就是，并行网关一般来说是成对出现的。

  .rocfcjbjhfdx{width:70%}


这里大家需要注意的是，并行网关是成对出现的（节点连线上不需要设置条件）。流程对应的 XML 文件如下：
&lt;process id=&quot;ParallelGatewayDemo01&quot; name=&quot;ParallelGatewayDemo01&quot; isExecutable=&quot;true&quot;&gt;    &lt;documentation&gt;ParallelGatewayDemo01&lt;/documentation&gt;    &lt;startEvent id=&quot;startEvent1&quot; flowable:formFieldValidation=&quot;true&quot;&gt;&lt;/startEvent&gt;    &lt;sequenceFlow id=&quot;sid-A8805B16-FABA-4E1A-A376-B0482F0832B8&quot; sourceRef=&quot;startEvent1&quot; targetRef=&quot;sid-1E9B605C-4F94-407F-AE6F-36768E04B116&quot;&gt;&lt;/sequenceFlow&gt;    &lt;parallelGateway id=&quot;sid-1E9B605C-4F94-407F-AE6F-36768E04B116&quot;&gt;&lt;/parallelGateway&gt;    &lt;userTask id=&quot;sid-4B2B7E70-55A9-4C68-B622-0E041AA81CBF&quot; name=&quot;生产屏幕&quot; flowable:assignee=&quot;zhangsan&quot; flowable:formFieldValidation=&quot;true&quot;&gt;      &lt;extensionElements&gt;        &lt;modeler:initiator-can-complete xmlns:modeler=&quot;http://flowable.org/modeler&quot;&gt;&lt;![CDATA[false]]&gt;&lt;/modeler:initiator-can-complete&gt;      &lt;/extensionElements&gt;    &lt;/userTask&gt;    &lt;sequenceFlow id=&quot;sid-C3E727EC-B5A6-4D01-8CEE-2A67BAB8C2C0&quot; sourceRef=&quot;sid-1E9B605C-4F94-407F-AE6F-36768E04B116&quot; targetRef=&quot;sid-4B2B7E70-55A9-4C68-B622-0E041AA81CBF&quot;&gt;&lt;/sequenceFlow&gt;    &lt;userTask id=&quot;sid-F43618C6-213E-4EC0-A6AB-1F31D9B2FD79&quot; name=&quot;生产键盘&quot; flowable:assignee=&quot;lisi&quot; flowable:formFieldValidation=&quot;true&quot;&gt;      &lt;extensionElements&gt;        &lt;modeler:initiator-can-complete xmlns:modeler=&quot;http://flowable.org/modeler&quot;&gt;&lt;![CDATA[false]]&gt;&lt;/modeler:initiator-can-complete&gt;      &lt;/extensionElements&gt;    &lt;/userTask&gt;    &lt;sequenceFlow id=&quot;sid-417FC68C-4759-4186-8978-AABAFC0D3E7B&quot; sourceRef=&quot;sid-1E9B605C-4F94-407F-AE6F-36768E04B116&quot; targetRef=&quot;sid-F43618C6-213E-4EC0-A6AB-1F31D9B2FD79&quot;&gt;&lt;/sequenceFlow&gt;    &lt;sequenceFlow id=&quot;sid-A69B4FC7-6E1D-4087-ADF4-F6FFC0319388&quot; sourceRef=&quot;sid-4B2B7E70-55A9-4C68-B622-0E041AA81CBF&quot; targetRef=&quot;sid-FAE8927E-1F6B-4F80-BB4C-39D5ADF63BED&quot;&gt;&lt;/sequenceFlow&gt;    &lt;parallelGateway id=&quot;sid-FAE8927E-1F6B-4F80-BB4C-39D5ADF63BED&quot;&gt;&lt;/parallelGateway&gt;    &lt;sequenceFlow id=&quot;sid-F54298A2-9484-4708-8026-BBAA386686F3&quot; sourceRef=&quot;sid-F43618C6-213E-4EC0-A6AB-1F31D9B2FD79&quot; targetRef=&quot;sid-FAE8927E-1F6B-4F80-BB4C-39D5ADF63BED&quot;&gt;&lt;/sequenceFlow&gt;    &lt;userTask id=&quot;sid-EA0ED8A8-FAF3-470B-8E1C-A7594A69F2B5&quot; name=&quot;组装&quot; flowable:assignee=&quot;wangwu&quot; flowable:formFieldValidation=&quot;true&quot;&gt;      &lt;extensionElements&gt;        &lt;modeler:initiator-can-complete xmlns:modeler=&quot;http://flowable.org/modeler&quot;&gt;&lt;![CDATA[false]]&gt;&lt;/modeler:initiator-can-complete&gt;      &lt;/extensionElements&gt;    &lt;/userTask&gt;    &lt;sequenceFlow id=&quot;sid-9CE61BAA-1038-4806-97DC-1DDB26F5F318&quot; sourceRef=&quot;sid-FAE8927E-1F6B-4F80-BB4C-39D5ADF63BED&quot; targetRef=&quot;sid-EA0ED8A8-FAF3-470B-8E1C-A7594A69F2B5&quot;&gt;&lt;/sequenceFlow&gt;    &lt;endEvent id=&quot;sid-19015D6D-1A47-4DD5-AEAA-DCC93FD5CAB0&quot;&gt;&lt;/endEvent&gt;    &lt;sequenceFlow id=&quot;sid-100E5221-CE66-4C2D-802B-DE8717AFE777&quot; sourceRef=&quot;sid-EA0ED8A8-FAF3-470B-8E1C-A7594A69F2B5&quot; targetRef=&quot;sid-19015D6D-1A47-4DD5-AEAA-DCC93FD5CAB0&quot;&gt;&lt;/sequenceFlow&gt;  &lt;/process&gt;

测试：
不需要参数，所以直接运行
@Test    void test03() &#123;        runtimeService.startProcessInstanceByKey(&quot;ParallelGatewayDemo01&quot;);    &#125;

只有zhangsan和lisi都执行完，才会进入到wangwu部分
包容网关包容官网，有时候也叫兼容网关、相容网关。
包容网关可以根据具体的条件，自动转为排他网关或者是并行网关。
举例：
报销，小于等于 500 元，zhangsan 审批，大于 500 元，zhangsan 和 lisi 同时审批。
流程图如下：

  .hkuqjrgwimjg{width:70%}


设置的流程条件如下：

  .cjjklqtdxdck{width:70%}



  .mhaausyueroo{width:70%}



报销 400 元的时候，只满足 &gt; 0，所以是 zhangsan 审批，此时是拍他网关。
报销 600 元的时候，既满足 &gt;0，又满足 &gt;500，此时就是 zhangsan 和 lisi 同时审批。

&lt;process id=&quot;InclusiveGatewayDemo01&quot; name=&quot;InclusiveGatewayDemo01&quot; isExecutable=&quot;true&quot;&gt;   &lt;documentation&gt;InclusiveGatewayDemo01&lt;/documentation&gt;   &lt;startEvent id=&quot;startEvent1&quot; flowable:formFieldValidation=&quot;true&quot;&gt;&lt;/startEvent&gt;   &lt;sequenceFlow id=&quot;sid-8CD8CA6A-3897-4245-9501-42439302DABA&quot; sourceRef=&quot;startEvent1&quot; targetRef=&quot;sid-C394FFAE-9804-499B-965B-2E75A49180C2&quot;&gt;&lt;/sequenceFlow&gt;   &lt;inclusiveGateway id=&quot;sid-C394FFAE-9804-499B-965B-2E75A49180C2&quot;&gt;&lt;/inclusiveGateway&gt;   &lt;userTask id=&quot;sid-E867D477-AEF1-4281-B078-CB507D22951E&quot; name=&quot;张三审批&quot; flowable:assignee=&quot;zhangsan&quot; flowable:formFieldValidation=&quot;true&quot;&gt;     &lt;extensionElements&gt;       &lt;modeler:initiator-can-complete xmlns:modeler=&quot;http://flowable.org/modeler&quot;&gt;&lt;![CDATA[false]]&gt;&lt;/modeler:initiator-can-complete&gt;     &lt;/extensionElements&gt;   &lt;/userTask&gt;   &lt;userTask id=&quot;sid-667FC03A-321D-4DFA-9B07-30434B42058C&quot; name=&quot;李四审批&quot; flowable:assignee=&quot;lisi&quot; flowable:formFieldValidation=&quot;true&quot;&gt;     &lt;extensionElements&gt;       &lt;modeler:initiator-can-complete xmlns:modeler=&quot;http://flowable.org/modeler&quot;&gt;&lt;![CDATA[false]]&gt;&lt;/modeler:initiator-can-complete&gt;     &lt;/extensionElements&gt;   &lt;/userTask&gt;   &lt;sequenceFlow id=&quot;sid-5BC666E9-F5D6-458F-8601-BEBEA786298D&quot; sourceRef=&quot;sid-E867D477-AEF1-4281-B078-CB507D22951E&quot; targetRef=&quot;sid-A7944F49-D14D-4CCE-AC25-C194A8E89678&quot;&gt;&lt;/sequenceFlow&gt;   &lt;inclusiveGateway id=&quot;sid-A7944F49-D14D-4CCE-AC25-C194A8E89678&quot;&gt;&lt;/inclusiveGateway&gt;   &lt;sequenceFlow id=&quot;sid-D78198C3-4023-4724-A3AE-4797304C17A0&quot; sourceRef=&quot;sid-667FC03A-321D-4DFA-9B07-30434B42058C&quot; targetRef=&quot;sid-A7944F49-D14D-4CCE-AC25-C194A8E89678&quot;&gt;&lt;/sequenceFlow&gt;   &lt;userTask id=&quot;sid-6FBB65EA-6A83-4CC9-AC6F-CD443D38F7D5&quot; name=&quot;王五审批&quot; flowable:formFieldValidation=&quot;true&quot;&gt;&lt;/userTask&gt;   &lt;sequenceFlow id=&quot;sid-795CBE0B-19DA-4B72-A12E-5FB3A4B92A3D&quot; sourceRef=&quot;sid-A7944F49-D14D-4CCE-AC25-C194A8E89678&quot; targetRef=&quot;sid-6FBB65EA-6A83-4CC9-AC6F-CD443D38F7D5&quot;&gt;&lt;/sequenceFlow&gt;   &lt;endEvent id=&quot;sid-010A170E-8468-45F9-94D9-962B44F25381&quot;&gt;&lt;/endEvent&gt;   &lt;sequenceFlow id=&quot;sid-564DEEB3-0778-460E-AEEA-22787300E17E&quot; sourceRef=&quot;sid-6FBB65EA-6A83-4CC9-AC6F-CD443D38F7D5&quot; targetRef=&quot;sid-010A170E-8468-45F9-94D9-962B44F25381&quot;&gt;&lt;/sequenceFlow&gt;   &lt;sequenceFlow id=&quot;sid-481CB3EF-5254-4514-AA29-DE268FD6EE32&quot; sourceRef=&quot;sid-C394FFAE-9804-499B-965B-2E75A49180C2&quot; targetRef=&quot;sid-E867D477-AEF1-4281-B078-CB507D22951E&quot;&gt;     &lt;conditionExpression xsi:type=&quot;tFormalExpression&quot;&gt;&lt;![CDATA[$&#123;money&gt;0&#125;]]&gt;&lt;/conditionExpression&gt;   &lt;/sequenceFlow&gt;   &lt;sequenceFlow id=&quot;sid-9C2BBBF9-C313-489D-87C4-61AB56415A0C&quot; sourceRef=&quot;sid-C394FFAE-9804-499B-965B-2E75A49180C2&quot; targetRef=&quot;sid-667FC03A-321D-4DFA-9B07-30434B42058C&quot;&gt;     &lt;conditionExpression xsi:type=&quot;tFormalExpression&quot;&gt;&lt;![CDATA[$&#123;money&gt;500&#125;]]&gt;&lt;/conditionExpression&gt;   &lt;/sequenceFlow&gt; &lt;/process&gt;

测试：
开始流程。money是1000，大于500并且大于0，所以应该需要zhangsan和lisi都审批（并行），最后王五审批
@Test   void test06() &#123;       HashMap&lt;String, Object&gt; vars = new HashMap&lt;&gt;();       vars.put(&quot;money&quot;,1000);       runtimeService.startProcessInstanceByKey(&quot;InclusiveGatewayDemo01&quot;,vars);   &#125;

执行。只有zhangsan和lisi都执行了，才轮到wangwu，最后wangwu执行，流程结束
 @Test    void test04() &#123;        List&lt;Task&gt; list = taskService.createTaskQuery().taskAssignee(&quot;zhangsan&quot;).list();//        List&lt;Task&gt; list = taskService.createTaskQuery().taskAssignee(&quot;lisi&quot;).list();//        List&lt;Task&gt; list = taskService.createTaskQuery().taskAssignee(&quot;wangwu&quot;).list();        for (Task task : list) &#123;            //查询到 zhangsan 的任务，并自己处理            taskService.complete(task.getId());        &#125;    &#125;





流程变量流程变量的分类：

全局流程变量
本地流程变量
临时流程变量

在之前的案例中，凡是涉及到流程变量的地方，基本上都是全局流程变量。
全局流程变量注意，以下四种方式，都是设置全局流程变量。无论是通过哪种方式设置，本质上都是全局流程变量，这个不会变。全局流程变量，顾名思义，就是和流程实例&#x2F;执行实例绑定的流程变量，和某个具体的 UserTask 是没有关系的。
启动时候设置流程启动的时候，设置全局流程变量：
/** * 在流程启动的时候，就可以设置流程变量 * * 流程变量将被存入到两个地方： * * 1. ACT_HI_VARINST：存入到历史信息表中，将来可以从历史表中查询到流程变量 * * insert into ACT_HI_VARINST (ID_, PROC_INST_ID_, EXECUTION_ID_, TASK_ID_, NAME_, REV_, VAR_TYPE_, SCOPE_ID_, SUB_SCOPE_ID_, SCOPE_TYPE_, BYTEARRAY_ID_, DOUBLE_, LONG_ , TEXT_, TEXT2_, CREATE_TIME_, LAST_UPDATED_TIME_) values ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? ) , ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? ) , ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? ) , ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? ) * * 2. ACT_RU_VARIABLE：流程运行的信息表，流程运行的变量将存入到这个表中 * * INSERT INTO ACT_RU_VARIABLE (ID_, REV_, TYPE_, NAME_, PROC_INST_ID_, EXECUTION_ID_, TASK_ID_, SCOPE_ID_, SUB_SCOPE_ID_, SCOPE_TYPE_, BYTEARRAY_ID_, DOUBLE_, LONG_ , TEXT_, TEXT2_) VALUES ( ?, 1, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? ) , ( ?, 1, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? ) , ( ?, 1, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? ) , ( ?, 1, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? ) */@Testvoid test01() &#123;    Map&lt;String, Object&gt; vars = new HashMap&lt;&gt;();    vars.put(&quot;days&quot;, 10);    vars.put(&quot;reason&quot;, &quot;玩一下&quot;);    vars.put(&quot;startTime&quot;, &quot;2022-10-30&quot;);    vars.put(&quot;endTime&quot;, &quot;2022-11-09&quot;);    //这个就是在启动的时候设置流程变量，这里设置的流程变量是一个全局的流程变量    runtimeService.startProcessInstanceByKey(&quot;VariableDemo&quot;,vars);&#125;

流程变量会被存入到两个地方，RU 和 HI 表中，然后，我们可以通过流程执行实例 ID【就是ACT_RU_EXECUTION表的ID_字段】 来查询流程变量信息：中的
/** * 通过执行实例 ID  可以查询流程变量 * * 具体的查询 SQL： * * select * from ACT_RU_VARIABLE WHERE EXECUTION_ID_ = ? AND TASK_ID_ is null AND NAME_ = ? */@Testvoid test02() &#123;    List&lt;Execution&gt; list = runtimeService.createExecutionQuery().list();    for (Execution execution : list) &#123;        Object reason = runtimeService.getVariable(execution.getId(), &quot;reason&quot;);        logger.info(&quot;execution name：&#123;&#125;,reason:&#123;&#125;&quot;, execution.getName(), reason);    &#125;&#125;

查询流程执行实例 ID 对应的所有变量：
/** * 根据流程执行实例 ID 查询所有对应的流程变量： * * select * from ACT_RU_VARIABLE WHERE EXECUTION_ID_ = ? AND TASK_ID_ is null * */@Testvoid test03() &#123;    List&lt;Execution&gt; list = runtimeService.createExecutionQuery().list();    for (Execution execution : list) &#123;        Map&lt;String, Object&gt; variables = runtimeService.getVariables(execution.getId());        logger.info(&quot;variables:&#123;&#125;&quot;, variables);    &#125;&#125;

通过 Task 设置给 Task 设置流程变量分两种：

逐个设置
通过 Map 批量设置

无论是哪种方式，本质上都还是往 ACT_RU_VARABLE和 ACT_HI_VARINST表中插入数据。
/** * 我们也可以根据 task 去查询流程变量 * */@Testvoid test05() &#123;    Task task = taskService.createTaskQuery().taskAssignee(&quot;javaboy&quot;).singleResult();    //这里即会根据 taskId 去查询，也会根据 taskId 对应的执行实例 id 去查询    Object a = taskService.getVariable(task.getId(), &quot;a&quot;);    //这里也是先根据 taskId 先找到执行实例 id，然后根据执行实例的 id 去进行查询    //select * from ACT_RU_VARIABLE WHERE EXECUTION_ID_ = ? AND TASK_ID_ is null    Map&lt;String, Object&gt; variables = taskService.getVariables(task.getId());    logger.info(&quot;a:&#123;&#125;,variables:&#123;&#125;&quot;, a, variables);&#125;/** * 通过 Task 来设置流程变量 * &lt;p&gt; * 通过 Task 设置，也是插入到两个地方： * &lt;p&gt; * 1. ACT_HI_VARINST * 2. ACT_RU_VARIABLE * &lt;p&gt; * 在设置的时候，虽然需要传递 TaskId，但是并不是说这个变量跟当前 Task 绑定，通过这个 taskId 可以查询出来这个 Task 对应的 流程实例 id 和执行实例 id，将来插入的时候会用到 */@Testvoid test04() &#123;    Task task = taskService.createTaskQuery().taskAssignee(&quot;javaboy&quot;).singleResult();    logger.info(&quot;taskId:&#123;&#125;&quot;, task.getId());    //第一个参数是 taskId，后面则是流程变量的 key-value    taskService.setVariable(task.getId(), &quot;result&quot;, &quot;同意&quot;);    Map&lt;String, Object&gt; vars = new HashMap&lt;&gt;();    vars.put(&quot;a&quot;, &quot;b&quot;);    vars.put(&quot;c&quot;, &quot;d&quot;);    //批量设置流程变量    taskService.setVariables(task.getId(), vars);&#125;

完成任务时设置/** * 完成任务时设置流程变量 * * 由于流程要执行结束了，因此 ACT_RU_VARIABLE 表要被清空了，所以这里就只向 ACT_HI_VARINST 表中保存数据。 */@Testvoid test06() &#123;    Task task = taskService.createTaskQuery().taskAssignee(&quot;javaboy&quot;).singleResult();    Map&lt;String, Object&gt; vars = new HashMap&lt;&gt;();    vars.put(&quot;state&quot;, &quot;完成&quot;);    taskService.complete(task.getId(),vars);&#125;



通过流程来设置可以从流程实例的角度来设置全局的流程变量。
/** * 由于流程变量是和当前流程实例相关的，所以流程变量也可以直接通过流程实例来设置 */@Testvoid test07() &#123;    List&lt;Execution&gt; list = runtimeService.createExecutionQuery().list();    for (Execution execution : list) &#123;        runtimeService.setVariable(execution.getId(), &quot;a&quot;, &quot;b&quot;);    &#125;&#125;

]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>tienchin</tag>
        <tag>工作流</tag>
        <tag>flowable</tag>
      </tags>
  </entry>
</search>
