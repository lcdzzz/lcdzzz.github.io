<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>java自学笔记 | 布鲁成周勒的博客</title><meta name="author" content="lcdzzz"><meta name="copyright" content="lcdzzz"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="IDEA使用新建 新建一个Empty Project 新建一个空的工程，选择创建工程窗口下面的Empty Project  给空的工程起一个名字：javase  会自动弹出一个：project structure，这个窗口先取消掉  给空的工程下新建Module（模块） idea的组织方式pr..."><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "java自学笔记",
  "url": "http://lcdzzz.github.io/2021/07/04/java%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/",
  "image": "https://images.wallpaperscraft.com/image/single/lawn_forest_mountains_144578_300x168.jpg",
  "datePublished": "2021-07-04T11:51:28.000Z",
  "dateModified": "2025-07-29T13:05:57.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "lcdzzz",
      "url": "http://lcdzzz.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://lcdzzz.github.io/2021/07/04/java%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java自学笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://images.wallpaperscraft.com/image/single/lawn_forest_mountains_144578_300x168.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">布鲁成周勒的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">java自学笔记</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">java自学笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-04T11:51:28.000Z" title="发表于 2021-07-04 19:51:28">2021-07-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-29T13:05:57.000Z" title="更新于 2025-07-29 21:05:57">2025-07-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="IDEA使用"><a href="#IDEA使用" class="headerlink" title="IDEA使用"></a>IDEA使用</h2><h3 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h3><ol>
<li><p>新建一个Empty Project</p>
<p>新建一个空的工程，选择创建工程窗口下面的Empty Project</p>
</li>
<li><p>给空的工程起一个名字：javase</p>
</li>
<li><p>会自动弹出一个：project structure，这个窗口先取消掉</p>
</li>
<li><p>给空的工程下新建Module（模块）</p>
<p>idea的组织方式projecrt–&gt;module</p>
</li>
<li><p>在New Module窗口上点击左下角的java，然后next</p>
</li>
<li><p>给module起一个名字</p>
</li>
<li><p>编写代码，在src目录下新建类，写代码，并运行。</p>
</li>
</ol>
<p><br><br></p>
<h3 id="关于IDEA工具的快捷键以及一些简单的设置"><a href="#关于IDEA工具的快捷键以及一些简单的设置" class="headerlink" title="关于IDEA工具的快捷键以及一些简单的设置"></a>关于IDEA工具的快捷键以及一些简单的设置</h3><h4 id="字体设置"><a href="#字体设置" class="headerlink" title="字体设置"></a>字体设置</h4><p>file–&gt;setting–&gt;输入font–&gt;设置字体样式以及字号大小</p>
<p><br><br></p>
<h4 id="快捷方式"><a href="#快捷方式" class="headerlink" title="快捷方式"></a>快捷方式</h4><ul>
<li><p>psvm（main方法）        sout（system.out.println)</p>
</li>
<li><p>删除一行：ctrl+y</p>
</li>
<li><p>左侧窗口的列表怎么展开？怎么关闭？</p>
<p>左箭头关闭，右箭头展开，上下箭头移动</p>
</li>
<li><p>idea中退出任何窗口，都可以使用esc键</p>
</li>
<li><p>任何新增、新建、添加的快捷键：</p>
<p>​    alt+insert</p>
</li>
<li><p>窗口变大变小</p>
<p>​    ctrl+shift+F12</p>
</li>
<li><p>快速运行</p>
<p>ctrl+shift+F10</p>
</li>
<li><p>切换java程序：</p>
<p>alt+左&#x2F;右箭头</p>
</li>
<li><p>切换窗口：</p>
<p>alt+标号（打开&#x2F;关闭）</p>
<p>alt+1(打开、关闭)</p>
</li>
<li><p>提示方法的参数：ctrl+p</p>
</li>
<li><p>注释：</p>
<p>单行注释：ctrl+&#x2F;</p>
<p>多行注释：ctrl+shift+&#x2F;</p>
</li>
<li><p>怎么定位方法&#x2F;属性&#x2F;变量?</p>
<p>光标停到单词下面，这个单词可能是方法名、变量名，停到单词下面之后，按住ctrl键，出现下划线，点击跳转。</p>
</li>
<li><p>idea当中复制一行是ctrl+d</p>
</li>
<li><p>idea工具中纠正错误的快捷键：alt+回车</p>
</li>
<li><p>快速查看源代码：ctrl按住。点击单词</p>
</li>
<li><p>查看一个类的属性和方法：ctrl + F12  </p>
<br>

<br>

<br>

<br></li>
</ul>
<h2 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h2><ol>
<li><p>super是一个关键字，全部小写</p>
</li>
<li><p>super和this对比着学习</p>
<p>this：</p>
<ul>
<li><p>能出现在实例方法和构造方法中</p>
</li>
<li><p>语法是”this.” 、 “this()”</p>
</li>
<li><p><strong>this不能出现在静态方法中</strong></p>
</li>
<li><p>大部分条件下是可以省略的</p>
</li>
<li><p>this.什么时候不能省略呢？</p>
<p><strong>在区分局部变量和实例变量的时候不能省略。</strong></p>
<p><code>public void setName(string name)&#123;</code></p>
<p>​    <code>this.name=name;</code></p>
<p><code>&#125;</code></p>
<p><strong>this()只能出现在构造方法第一行</strong>，通过当前的构造方法去调用“本类”中其他的构造方法，目的是：代码复用。</p>
</li>
</ul>
<p>super：</p>
<ul>
<li><p>能出现在实例方法和构造方法中</p>
</li>
<li><p>语法是”super.” 、 “super()”</p>
</li>
<li><p><strong>super不能出现在静态方法中</strong></p>
</li>
<li><p>大部分条件下是可以省略的</p>
</li>
<li><p>super.什么时候不能省略呢？</p>
<p><strong>父类和子类中有同名属性或者说有同样的方法，</strong></p>
<p><strong>想在子类中访问父类的，super. 不能省略。</strong></p>
<p><strong>super（)只能出现在构造方法第一行</strong>，通过当前的构造方法去调用“父类”中其他的构造方法，目的是：创建子类对象的时候，先初始化父类型特征</p>
</li>
</ul>
</li>
<li><p>super()</p>
<p>表示通过子类的构造方法调用父类的构造方法。</p>
<p>模拟现实世界中：要想要儿子，必须先有父亲。</p>
<p>&#x2F;&#x2F;一个类如果没有手动提供任何构造方法，系统会默认提供一个无参数构造方法。</p>
<p>&#x2F;&#x2F;一个类如果手动提供了一个构造方法，那么无参数构造方法系统将不会再提供。</p>
</li>
<li><p>重要结论：</p>
<p><strong>当一个构造方法第一行：</strong></p>
<p><strong>既没有this（）又没有super（）的话，默认会有一个super（）；</strong></p>
<p><strong>表示通过当前子类的构造方法调用父类的无参数构造方法。</strong></p>
<p><strong>所以必须保证父类的无参数构造方法是存在的。</strong></p>
</li>
<li><p>注意：</p>
<p>this()和super()不能共存，他们都是只能出现在构造方法的第一行。</p>
</li>
<li><p><strong>无论怎么折腾，父类的构造方法是一定会执行的（100%）。</strong></p>
<p>&#x2F;&#x2F;在java语言中不管是new什么对象。最后老祖宗的object类的无参数构造方法一定会执行（object类的无参数构造方法是处于“栈顶部”）</p>
<p>栈顶的特点：</p>
<p>最后调用，但最先执行结束。</p>
<p>后进先出原则</p>
<p>以后写代码的时候，一个类的无参数构造方法还是建议手动写出来。</p>
<p>如果无参数构造方法丢失的话，可能会影响到子类对象的构建</p>
</li>
<li><p>注意：在构造方法执行过程中一连串调用了父类的构造方法，父类的构造方法有继续向下调用它的父类构造方法，但实际上对象只创建了一个。</p>
<p>super（实参）的作用：初始化当前对象的父类型特征，并不是创建新对象，对象只创建了一个。</p>
<p>&#x2F;&#x2F;java中允许在子类中出现一个和父类同名的变量、同名属性。</p>
</li>
<li><p>super不是引用，也不保存内存地址，也不指向任何对象，super只代表当前对象内部的那一块父类型的特征。</p>
</li>
<li><p>在父和子中有同名的属性或者相同的方法，如果此时想在子类中访问父类的数据，必须使用”super.”加一区分。</p>
</li>
<li><p>在子类中访问父类私有的数据，使用super.没有权限的</p>
<p>但父类私有的构造方法，可以用super（实参）去构造。</p>
</li>
</ol>
<p><em>super的使用</em><br><em>supe</em>r.属性名    【访问父类的属性】*</p>
<p><em>super.方法名(实参)   【访问父类的方法】</em></p>
<p>super.(实参)   【调用父类的构造方法】*</p>
<br>

<br>

<br>

<br>

<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><ol>
<li><p>final修饰的变量？</p>
<p><strong>final修饰的局部标量，一但被赋值，就不能重新赋值【final修饰的变量只能赋一次值】</strong></p>
</li>
<li><p>fianl修饰的方法？</p>
<p><strong>final修饰的方法无法被覆盖，被重写</strong></p>
</li>
<li><p>fianl修饰的类？</p>
<p><strong>final修饰的类无法被继承</strong></p>
</li>
<li><p>final控制不了能不能调用的问题，final管的是：最后的，不能变的，不能改的。</p>
</li>
<li><p>final修饰的变量，如果这个变量是一个人”引用“</p>
<p>引用也是一个变量，所以也是不能变的</p>
<p><code>*final person p=new person(30);*</code><br><code>*p=new Person(30)//错误！无法为最终变量p分配值*</code></p>
<p><strong>final修饰的引用：</strong></p>
</li>
</ol>
<p>  该引用只能指向1个对象，并且它只能永远指向该对象，无法指向其他对象。<br>  并且在该方法执行过程中，该引用指向对象后，该对象不会被垃圾回收器回收。<br>	<br>  直到当前方法结束，才会释放空间。</p>
<p>  虽然final的引用指向对象A后，不能再重新指向对象B。<br>  但是对象内部的数据可以被修改。</p>
<ol start="6">
<li><p><strong>final修饰的实例变量，系统不负责赋默认值，要求程序员必须手动赋值。</strong></p>
<p>这个手动赋值，在变量后面赋值可以，在构造方法赋值也可以。</p>
<p>final修饰的实例变量一般添加static修饰</p>
<p><em>解释：</em><br><em>i永远都是10，创建100个对象，i也是10</em><br><em>i是10是永远都不会改变的，既然这样，没必要声明为实例变量，最好是静态，节省内存空间</em></p>
<p><strong>static final联合修饰的变量成为“常量”。</strong></p>
</li>
</ol>
<p>​	例：<code>public static final double PI=3.1415926;</code></p>
<p>   常量名建议大写，每个单词之间采用下划线来衔接。</p>
<p>   <em>常量：实际上常量和静态变量一样，区别在于：</em></p>
<p>   <em>常量的值不能变。</em></p>
<p>   <em>常量和静态变量，都是存储在方法去，并且都是类加载时初始化</em>。</p>
<br>

<br>

<br>

<br>

<h2 id="抽象类（abstract）"><a href="#抽象类（abstract）" class="headerlink" title="抽象类（abstract）"></a>抽象类（abstract）</h2><ol>
<li><p>抽象类怎么定义？</p>
<p>在class钱添加abstract关键字。</p>
</li>
<li><p><strong>抽象类是无法实例化的，无法创建对象的，所以抽象类是用来被子类继承的</strong>。</p>
</li>
<li><p>final和abstract不能联合使用，这两个关键字是对立的。</p>
</li>
<li><p>抽象类的子类可以是抽象类，也可以不是。</p>
</li>
<li><p>抽象类虽然无法实例化，但是抽象类有构造方法，这个构造方法是供子类使用的。</p>
</li>
<li><p><strong>抽象类中不一定有抽象方法，但是抽象方法必须出现在抽象类中。</strong></p>
</li>
<li><p>抽象方法怎么定义？</p>
<p><code>public abstract void dosome();</code></p>
</li>
<li><p><strong>一个非抽象的类，继承抽象类，必须将抽象类中的抽象方法进行覆盖&#x2F;重写&#x2F;实现。</strong></p>
</li>
<li><p>面试题（判断）：java语言中凡是没有方法体的方法都是抽象方法。（×）</p>
<p><em>object类中就有很多方法没有方法体，都是以“;”结尾的，但他们不是抽象方法，例如：</em></p>
<p><em><code>public native int hashCode();</code></em></p>
<p><em>这个方法底层调用了C++写的动态链接库。</em></p>
<p><em>前面修饰符列表中没有：abstract。有一个native表示调用JVM本地程序。</em></p>
<br>

<br>

<br>

<br></li>
</ol>
<h2 id="接口（接口也是一种类）"><a href="#接口（接口也是一种类）" class="headerlink" title="接口（接口也是一种类）"></a>接口（接口也是一种类）</h2><h3 id="接口的基础语法"><a href="#接口的基础语法" class="headerlink" title="接口的基础语法"></a>接口的基础语法</h3><ol>
<li><p>接口也是一种“引用数据类型”。编译之后也是一个class字节码文件。</p>
</li>
<li><p>接口完全抽象。（抽象类是半抽象。）或者也可以说接口是特殊的抽象类。</p>
</li>
<li><p>接口怎么定义的，语法是什么？</p>
<p>[修饰符列表] interface 接口名{}</p>
</li>
<li><p>接口支持多继承。</p>
<p><code>interface C extend A，B&#123;</code></p>
<p><code>&#125;</code></p>
</li>
<li><p>接口只包含两个内容：常量+抽象方法。</p>
</li>
<li><p>接口中所有元素都会public修饰的。</p>
</li>
<li><p>接口中的抽象方法定义是：pubiic abstract 修饰符可以省略。</p>
</li>
<li><p>接口中的常量的public static final可以省略。</p>
</li>
<li><p>接口中的方法是抽象方法，所以接口中的方法不能有方法体（不能加大括号{}）。</p>
</li>
<li><p>一个非抽象的类，实现接口的时候，必须将接口中所有方法加以实现。</p>
</li>
<li><p>一个类可以实现多个接口</p>
</li>
<li><p>extends和implements可以共存，extends在前，implements在后。</p>
<p><code>class Cat extends Animal implements Flyable&#123;</code></p>
<p>​    <code>&#125;</code></p>
</li>
<li><p>使用使用接口，在写代码时，可以使用多态（父类型引用指向子类型对象）。</p>
<p>向下转型要养成习惯：转型之前先if+instanceof进行判断</p>
<p><code>if(m instanceof K)&#123;</code></p>
<p><code>K k = (K) m；</code></p>
<p><code>&#125;</code></p>
<p><br><br></p>
</li>
</ol>
<h3 id="接口在开发中的作用"><a href="#接口在开发中的作用" class="headerlink" title="接口在开发中的作用"></a>接口在开发中的作用</h3><p>注意：接口在开发中的作用，类似于多态在开发中的作用。</p>
<p>多态：面向抽象编程，不要面向具体编程。降低程序耦合度。提高程序的扩展力。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Master</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Dog d)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Cat c)</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//假设又要养其他宠物，那么这个时候需要再加1个方法。（需要修改代码）</span></span><br><span class="line">    <span class="comment">//这样扩展力太差，违背了ocp原则（对扩展开放，对修改关闭）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Master</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Animal a)</span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        面向Animal 父类编程，父类是比子类更抽象的。所以我们叫做面向抽象编程，不要面向具体编程。这样程序的扩展力就强。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接口在开发总共的作用？</p>
<p>抽象是完全抽象的，而我们以后正好要求，面向抽象编程。</p>
<p>面向抽象编程这句话以后可以修改为：面向接口编程。</p>
<p>有了剪口就有了可插拔，可插拔表示扩展力很强，不是焊接死的。</p>
<p>主板和内存条之间有插槽，这个插槽就是接口，内存条坏了，可以重新买一个换下来，这叫做高扩展性（低耦合度）。</p>
<p><br><br></p>
<p><strong>总结一句话：三个字<u>解耦合</u></strong></p>
<p>面向接口编程，可以降低程序耦合度，提高程序扩展力。符合ocp开发原则 。接口的使用离不开多态机制。（接口+多态才可以打到降低耦合度。）</p>
<p> 接口可以解耦合，解开的是谁和谁的耦合？？？</p>
<p>任何一个接口都有调用者和实现着。</p>
<p>接口可以讲调用者和实现者解耦合。</p>
<p>调用者面向接口调用。</p>
<p>实现者面向接口编写实现。</p>
<br>

<p>以后进行大项目的开发，一般都是讲项目分离成一个模块一个模块的，模块和模块之间采用接口衔接，降低耦合度 </p>
<br>

<br>

<br>

<br>

<h2 id="类型和类型之间的关系："><a href="#类型和类型之间的关系：" class="headerlink" title="类型和类型之间的关系："></a>类型和类型之间的关系：</h2><p>is a（继承）、has a（关联）、 like a（实现）</p>
<ul>
<li><p>is a:</p>
<p>Ca is a Animal(猫是一个动物)</p>
<p>凡是能够满足is a的表示“继承关系”</p>
<p><code>A extends B;</code></p>
</li>
<li><p>has a:</p>
<p>I has a Pen(我有一支笔)</p>
<p>凡是能够满足has a 关系的表示“关联关系”</p>
<p>关联关系通常以“属性”的形式存在。</p>
<p><code>A&#123;</code></p>
<p><code>   B b;</code></p>
<p><code>&#125;</code></p>
</li>
<li><p>like a：</p>
<p>Cooker like a FoodMenu(厨师想一个菜单一样)、</p>
<p>凡是能够满足like a 关系的表示“实现关系”</p>
<p>实现关系通常是：类实现接口。</p>
<p><code>A implements B;</code></p>
</li>
</ul>
<br>

<br>

<br>

<br>

<h3 id="抽象类和接口有什么区别"><a href="#抽象类和接口有什么区别" class="headerlink" title="抽象类和接口有什么区别"></a>抽象类和接口有什么区别</h3><p><em>这里直说下抽象类和接口在语法上的区别。至于以后抽象类和接口应该怎么进行选择，通过后面的项目去体会。</em></p>
<br>

<p>抽象类是半抽象的</p>
<p>接口是完全抽象的</p>
<br>

<p>抽象类中有构造方法。</p>
<p>接口中没有构造方法。</p>
<br>

<p>类与类之间只能单继承。</p>
<p>接口与接口直接支持多继承。</p>
<br>

<p>一个抽象类只能继承一个类（单继承）。</p>
<p>一个类可以同时实现多个接口。</p>
<br>

<p>接口中只允许出现常量和抽象方法。</p>
<br>

<p>以后接口使用的比抽象类多。一般抽象类使用的还是少。</p>
<p>接口一般都是对“行为”的抽象。</p>
<p>抽象类既可以抽象行为又可以抽象数据。</p>
<br>

<br>

<br>

<br>

<h2 id="package和import机制"><a href="#package和import机制" class="headerlink" title="package和import机制"></a>package和import机制</h2><h3 id="package"><a href="#package" class="headerlink" title="package"></a>package</h3><ol>
<li><p>package出现在java源文件第一行。</p>
</li>
<li><p>带有包名怎么编译？</p>
<p>javac -d . xxx.java</p>
</li>
<li><p>怎么运行？</p>
<p>java 完整类名</p>
<p>例：<code>java com.bjpowernode.javase.chapter17.HelloWorld</code></p>
<br>

<br></li>
</ol>
<h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>import什么时候不需要？</p>
<ul>
<li>java.lang不需要</li>
<li>同包下不需要</li>
<li>其他一律都需要</li>
</ul>
<p>怎么用？</p>
<ul>
<li>import 完整类名</li>
<li>import 包名.*;</li>
</ul>
<p><br><br><br><br></p>
<h2 id="访问控制权限"><a href="#访问控制权限" class="headerlink" title="访问控制权限"></a>访问控制权限</h2><h3 id="有哪些访问控制权限？"><a href="#有哪些访问控制权限？" class="headerlink" title="有哪些访问控制权限？"></a>有哪些访问控制权限？</h3><ul>
<li>private 私有</li>
<li>protect 受保护</li>
<li>public 公开</li>
<li>____    默认</li>
</ul>
<p><br><br></p>
<h3 id="以上四种访问控制权限，控制的范围是什么？"><a href="#以上四种访问控制权限，控制的范围是什么？" class="headerlink" title="以上四种访问控制权限，控制的范围是什么？"></a>以上四种访问控制权限，控制的范围是什么？</h3><table>
<thead>
<tr>
<th>访问控制修饰符</th>
<th>本类</th>
<th>同包</th>
<th>子类</th>
<th>任意位置</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>protected</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>默认</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>private</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
</tbody></table>
<p>public&gt;protected&gt;默认&gt;private</p>
<p><br><br></p>
<h3 id="访问控制权限修饰符可以修饰什么"><a href="#访问控制权限修饰符可以修饰什么" class="headerlink" title="访问控制权限修饰符可以修饰什么"></a>访问控制权限修饰符可以修饰什么</h3><ul>
<li>属性（4个都行）</li>
<li>方法（4个都能用）</li>
<li>类（public 和默认可以，其他不行）</li>
<li>接口（public 和默认可以，其他不行）</li>
</ul>
<p><br><br><br><br></p>
<h2 id="JDK类库的根类：Object"><a href="#JDK类库的根类：Object" class="headerlink" title="JDK类库的根类：Object"></a>JDK类库的根类：Object</h2><p>这个老祖宗中的方法都是所有子类通用的，任何一个类默认继承Object，就算没有继承，也会间接继承</p>
<h3 id="Object类当中有哪些常用的方法？"><a href="#Object类当中有哪些常用的方法？" class="headerlink" title="Object类当中有哪些常用的方法？"></a>Object类当中有哪些常用的方法？</h3><p>怎么找？</p>
<ol>
<li>去源代码当中。（但这种方式比较麻烦，源代码也比较难）</li>
<li>去查阅java的类库的帮助文档。</li>
</ol>
<p>什么事API?</p>
<p>​      应用程序的编程接口。整个JDK的类库就是一个javase的API（application program interface）。每一个API都会配置一套API帮助文档。SUN公司提前写好的这套类库就是API。（一般每一份API都对应一份API帮助文档。）、</p>
<p>目前为止我们只需要知道这几个方法即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span>； <span class="comment">//负责对象克隆的</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hashOde</span><span class="params">()</span>; <span class="comment">//换区对象哈希值的一个方法</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>; <span class="comment">//判断两个对象是否相等</span></span><br><span class="line">String <span class="title function_">toString</span><span class="params">()</span>; <span class="comment">//讲哦对象转换成字符串形式</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span>; <span class="comment">//垃圾回收器负责调用的方法 </span></span><br></pre></td></tr></table></figure>



<p><br><br></p>
<h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h3><p>以后所有类的toString()方法是需要重写的，重写规则，越简单越明了就好。</p>
<p>System.out.println(引用)；这里会自动调用“引用”的toString()方法。</p>
<p>String类是SUN写的，toString方法已经重写了。</p>
<p><br><br></p>
<h3 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals()方法"></a>equals()方法</h3><p>以后所有类的equals方法也需要重写，因为object中的equals方法比较的是两个对象的内存地址，我们应该比较内容，所以需要重写。</p>
<p>重写规则：自己定，主要看是什么和什么相等时表示里欧昂个对象相等。</p>
<p>基本数据类型比较实用：&#x3D;&#x3D;</p>
<p>对象和对象比较：调用equals方法</p>
<p>String类是SUN编写的，所以Strng类的equals方法重写了。</p>
<p>以后判断两个字符串是否相等，最好不要实用&#x3D;&#x3D;。要调用字符串对象的equals方法。</p>
<p><br><br></p>
<h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h3><ol>
<li><p>在Object类中的源代码：</p>
<p><code>protected void finaliz() throw Throwable&#123; &#125;</code></p>
<p>GC：负责带一把过finalize()方法</p>
</li>
<li><p>finalize()方法只有一个方法体，里面没有代码，而且这个方法是protected修饰的。</p>
</li>
<li><p>这个方法不需要程序员手动调用，JVM的垃圾回收器会负责调调用这个方法。</p>
<p>不像equals toString ,equals和toString（）方法是需要你写代码调用的。</p>
<p>finalize（）只需要重写，重写玩将来会自动会有程序来调用。</p>
</li>
<li><p>finalize()方法的执行时机</p>
<p>当一个java对象即将被垃圾回收器回收的时候，垃圾回收器负责调用fianlize()方法。</p>
</li>
<li><p>finalize()方法实际上是SUN公司为java程序员准备的一个实际，垃圾销毁时机。</p>
<p>如果希望在对象销毁时机执行一段代码的话，这段代码要写在finalize()方法中。</p>
</li>
<li><p>静态代码块的作用是什么？</p>
<p>static{</p>
<p>   …</p>
<p>}</p>
<p>静态代码块在类加载的时候执行，并且只执行一次，这是一个SUN准备的类加载时机。</p>
<p>finalize()方法同样是sun为程序员准备的一个时机。</p>
<p>这个时机是垃圾回收时机。</p>
</li>
<li><p>有段代码可以建议垃圾回收期启动</p>
<p><code>System.gc();   // 建议启动垃圾回收器</code></p>
</li>
</ol>
<p><br><br></p>
<h3 id="hashCode方法："><a href="#hashCode方法：" class="headerlink" title="hashCode方法："></a>hashCode方法：</h3><ol>
<li><p>在object中的hashCode方法是怎么样的?</p>
<p>public native int hashCode();</p>
<p>这个方法不是抽象方法，带有native关键字，底层调用c++程序。</p>
</li>
<li><p>hashCode()方法返回的是哈希值：</p>
<p>实际上就是java对象的内存地址，经过哈希算法，得出一个值。</p>
<p>所以hashCode()方法的执行结果可以等同看做一个java对象的内存地址</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(string[] args)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">hashCodeValue</span> <span class="operator">=</span> o.hashcode();</span><br><span class="line">        <span class="comment">//对象内存地址经过哈希算法转换的一个数字。可以等同看做内存地址。</span></span><br><span class="line">        System.out.println(hashCodeValue);<span class="comment">//89641564</span></span><br><span class="line">      	</span><br><span class="line">        MyClass mc=<span class="keyword">new</span> <span class="title class_">MyClass</span>;</span><br><span class="line">        System.out.println(mc.hashCode());<span class="comment">//5641864654</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br><br><br><br></p>
<h2 id="匿名内部类："><a href="#匿名内部类：" class="headerlink" title="匿名内部类："></a>匿名内部类：</h2><ol>
<li><p>内部类：在类的内部又定义了一个新的类。被称为内部类。</p>
</li>
<li><p>内部类的分类：</p>
<p>静态内部类：类似于静态变量</p>
<p>实例内部类：类似于实例变量</p>
<p>局部内部类：类似于局部变量</p>
</li>
<li><p>使用内部类编写的代码，可读性差，尽量别用</p>
</li>
<li><p>匿名内部类是局部内部类的一种。因为这个类没有名字而得名，叫做匿名内部类。可以直接实现接口</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mm.mySum(<span class="keyword">new</span> <span class="title class_">Compute</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,<span class="number">200</span>,<span class="number">300</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">mm是对象，使用了mySum这个方法</span></span><br><span class="line"><span class="comment">compute是一个接口，不能直接new对象，这里使用了匿名内部类。如果不用匿名内部类，那么需要再创建一个class，去implements接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是不使用匿名内部类的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComputeImpl</span> <span class="keyword">implements</span> <span class="title class_">Compute</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span> <span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br><br><br><br></p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol>
<li><p>数组的优缺点，并且要理解为什么</p>
<ol>
<li><p>空间存储上，内存地址是连续的</p>
</li>
<li><p>每个元素占用的空间大小相同</p>
</li>
<li><p>知道首元素的内存地址</p>
</li>
<li><p>通过下班可以计算出偏移量</p>
<p>通过一个数学表达式，就可以快速计算出摸个下标为止上元素的内存1地址，直接通过内存地址定位，效率非常高。</p>
</li>
<li><p>优点：检索效率高。</p>
<p>缺点随记增删改效率较低，数组无法存储大数据量</p>
<p>注意：数组最后一个元素增删效率不受影响</p>
<br></li>
</ol>
</li>
<li><p>以为数组的静态初始化和动态初始化</p>
<ul>
<li><p>静态初始化：</p>
<p><code>int[] arr = &#123;1,2,3,4&#125;;</code></p>
<p><code>object[] objs = &#123;new Object(),new Object(),new Object() &#125;;</code></p>
</li>
<li><p>动态初始化</p>
<p><code>int []arr=new int[4];</code></p>
<p><code>Object[] objs=new Object[4]; //元素默认值为null</code></p>
<br></li>
</ul>
</li>
<li><p>一维数组的遍历</p>
<br>
</li>
<li><p>二维数组的静态初始化和动态初始化</p>
<ul>
<li><p>静态初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> [] [] arr=&#123;</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>,<span class="number">8</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Object[][] arr=&#123;</span><br><span class="line">    &#123;<span class="keyword">new</span> <span class="title class_">Object</span>(),<span class="keyword">new</span> <span class="title class_">Object</span>()&#125;,</span><br><span class="line">    &#123;<span class="keyword">new</span> <span class="title class_">Object</span>(),<span class="keyword">new</span> <span class="title class_">Object</span>(),<span class="keyword">new</span> <span class="title class_">Object</span>(),<span class="keyword">new</span> <span class="title class_">Object</span>()&#125;,</span><br><span class="line">    &#123;<span class="keyword">new</span> <span class="title class_">Object</span>(),<span class="keyword">new</span> <span class="title class_">Object</span>(),<span class="keyword">new</span> <span class="title class_">Object</span>(),<span class="keyword">new</span> <span class="title class_">Object</span>(),<span class="keyword">new</span> <span class="title class_">Object</span>()&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>动态初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> [] []arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">4</span>];<span class="comment">//三行四列</span></span><br><span class="line">Object [] [] arr=<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">Animal [][] arr=<span class="keyword">new</span> <span class="title class_">Animal</span>[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="comment">//Animal累的数组，里面可以存储Animal对象以及它的子类</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>二维数组的遍历</p>
</li>
<li><p>main方法上”String[] args”参数的使用</p>
</li>
<li><p>数组的拷贝：System.arraycopy()方法的使用</p>
<p>数组长度一旦确定，不可变。</p>
<p>所以数组长度不够的时候需要扩容，扩容的机制是：新建一个大数组，讲小数组的数据拷贝到大数组，小数组被垃圾回收器回收</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Selftest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] targetArr=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br><span class="line">        System.arraycopy(arr,<span class="number">1</span>,targetArr,<span class="number">0</span>,targetArr.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;targetArr.length ; i++) &#123;</span><br><span class="line">            System.out.println(targetArr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>对数组中存储应用数据类型的情况，要会画它的内存结构图</p>
</li>
</ol>
<p><br><br><br><br></p>
<h2 id="Java-JDK中内置的一个类：java-lang-String"><a href="#Java-JDK中内置的一个类：java-lang-String" class="headerlink" title="Java JDK中内置的一个类：java.lang.String"></a>Java JDK中内置的一个类：java.lang.String</h2><ol>
<li><p>String 表示字符串类型，属于引用数据类型，不属于基本数据类型。</p>
</li>
<li><p>在java中随便使用双引号括起来的对象。例如：”abc”,”hello world”，这是三个String对象</p>
</li>
<li><p>java中规定，双引号括起来的字符串是不可变的·，也就是说”abc”从出生到死亡，都不可变。</p>
</li>
<li><p>在JDK当中双引号括起来的字符串。例如：<strong>“abc” “def”都是直接存储在”方法区’’的”字符串常量池”当中的。</strong></p>
<p>为什么SUN公司把自付出存储在一个“字符串常量池”当中呢，因为字符串在实际开发中使用太频繁，为了执行效率，所以把字符串放到了方法区的字符串常量池当中。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span><span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span><span class="string">&quot;abcdef&quot;</span>+<span class="string">&quot;xy&quot;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">↑这两行代码在表示底层创建了3个字符串对象，都在字符串常量池当中</span></span><br><span class="line"><span class="comment">↓这是使用new方法创建的字符串对象。这个代码中的“xy”是从哪里来的？</span></span><br><span class="line"><span class="comment">凡是双引号括起来的都在字符串常量池当中有一份</span></span><br><span class="line"><span class="comment">new对象的时候一定是在堆内存当中开辟空间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;xy&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//i变量中保持的是100这个值</span></span><br><span class="line"><span class="type">int</span> i=<span class="number">100</span>;</span><br><span class="line"><span class="comment">//s变量中保存的是字符串对象的内存地址</span></span><br><span class="line"><span class="comment">//s引用中保存的不是&quot;abd&quot;，是0x1111</span></span><br><span class="line"><span class="comment">//而0x1111是“abd”字符串对象在“字符串常量池”当中的内存地址。		</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span><span class="string">&quot;abc&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><br><br></p>
<h3 id="关于String类中的构造方法"><a href="#关于String类中的构造方法" class="headerlink" title="关于String类中的构造方法"></a>关于String类中的构造方法</h3><ol>
<li>String s &#x3D; new String(“”);</li>
<li>String s &#x3D; “”;&#x2F;&#x2F;最常用</li>
<li>String s &#x3D; new String (char数组);</li>
<li>String s &#x3D; new String (char数组，起始下标，长度);</li>
<li>String s &#x3D; new String (byte数组)；</li>
<li>String s &#x3D; new String (byte数组，起始下标，长度)；</li>
</ol>
<p><br><br><br><br></p>
<h1 id="String-类当中常用方法"><a href="#String-类当中常用方法" class="headerlink" title="String 类当中常用方法"></a>String 类当中常用方法</h1><ol>
<li><p>（掌握） <strong>char charAt(int index)</strong></p>
<p><code>char c = &quot;中国人&quot;.charAt(1);</code></p>
<p><code>System.out.printlb(c);//国</code></p>
<br>
</li>
<li><p>（了解） <strong>int compareTo(String anotherString)</strong></p>
<p>int result &#x3D; “abc”.compareTo(“abc”);</p>
<p>System.out.println(result);&#x2F;&#x2F;0</p>
<p>&#x2F;&#x2F;输出0（等于0）–&gt;前后一致</p>
<p>&#x2F;&#x2F;输出1（大于0）–&gt;前大后小</p>
<p>&#x2F;&#x2F;输出-1（小于0）–&gt;前小后大</p>
<p><em>按字典顺序</em></p>
<p>拿着字符串第一个字母和后面字符串的第一个字母比较。能分胜负就不再比较了。</p>
<p>System.out.println(“xyz”.compareTo(“yxz”));&#x2F;&#x2F;-1</p>
<br>
</li>
<li><p>（掌握） <strong>boolean contains(CharSequence s)</strong></p>
<p><u>判断前面的字符串中是否包含后面的字符串。</u></p>
<p>System.out.println(“hello.java”.contains(“.java”));&#x2F;&#x2F;ture。如果没有，则输出false</p>
<br>
</li>
<li><p>（掌握） <strong>boolean endsWith(String suffix)</strong></p>
<p><u>判断当前字符串是否以某个字符串结尾</u></p>
<p>System.out.println(“test.txt”.endsWith(“java”));&#x2F;&#x2F;false</p>
<br>
</li>
<li><p>（掌握） <strong>boolean equals(Object anObject)</strong></p>
<p><u>比较两个字符串鼻血使用equals方法，不能使用“&#x3D;&#x3D;”</u></p>
<p>System.out.println(“abc”.equals(“abc”));&#x2F;&#x2F;true;</p>
<br>
</li>
<li><p>（掌握） <strong>boolean equalsIgnoreCase(String anotherString)</strong></p>
<p><u>判断两个字符串是否相等，并且同时忽略大小写。</u></p>
<br>
</li>
<li><p>（掌握） <strong>byte[] getBytes()</strong></p>
<p><u>将字符串转换成字节数组</u></p>
<p>byte[] bytes &#x3D; “abcd”.getBytes();</p>
<p>&#x2F;&#x2F;遍历以后输出的是 97 98 99 100</p>
<br>
</li>
<li><p>（掌握） int indexOf(String str)**</p>
<p><u>判断某个字符串在当前字符串中<strong>第一次</strong>出现处的索引（下标）</u></p>
<p>System,out.println(“12345java2222”.indexOf(“java”));&#x2F;&#x2F;6</p>
<br>
</li>
<li><p>（掌握） lastInt indexOf(String str)**</p>
<p><u>判断某个字符串在当前字符串中<strong>最后一次</strong>出现处的索引（下标）</u></p>
<p>System,out.println(“12345java2222”.lastIndexOf(“2”));&#x2F;&#x2F;12</p>
<br>
</li>
<li><p>（掌握） <strong>boolean isEmpty()</strong></p>
<p><u>判断某个字符串是否为”空字符串”</u></p>
<p>String s &#x3D; “”；&#x2F;&#x2F;不能是null，不然会空指针异常,同时必须为空，就算是空格，返回的也是false；</p>
<p>System.out.println(s.isEmpty());</p>
<br>
</li>
<li><p>（掌握） <strong>int length()</strong></p>
<p><u>面试题：判断数组长度和判断字符串长度不一样</u></p>
<p><u>判断数组长度是length属性，判断字符串长度是length()方法</u></p>
<p>System.out.println(“abc”.length());&#x2F;&#x2F;3</p>
<br>
</li>
<li><p>（掌握） <strong>String replace(CharSequence target, CharSequence replacement)</strong></p>
<p><u>String的父接口就是：CharSequence</u></p>
<p>String s &#x3D;”abc”;<br>String s1&#x3D;s.replace(“a”,”b”);<br>System.out.println(s1);</p>
<br>
</li>
<li><p>（掌握） <strong>String [] split(String regex)</strong></p>
<p><u>拆分字符串</u></p>
<p>String[] ymd &#x3D; “2002-6-1”.split(“-“);<br>for (int i &#x3D; 0; i &lt; ymd.length ; i++) {<br>System.out.println(ymd[i]);</p>
<p>&#x2F;&#x2F;可以继续向下拆分，比如通过”0”拆分</p>
<p>}&#x2F;&#x2F;输出2002  6  1</p>
<br>
</li>
<li><p>（掌握） <strong>boolean startWith(String prefix)</strong></p>
<p><u>判断某个字符串是否以某个子字符串开始</u></p>
<p>System.out.println(“111222333”.startWith(“111”));&#x2F;&#x2F;true</p>
<p>System.out.println(“111222333”.startWith(“123”));&#x2F;&#x2F;false</p>
<br>
</li>
<li><p>（掌握） <strong>String substring(int beginIndex)</strong></p>
<p><u>截取字符串</u></p>
<p>System.out.println(“111222333”.substring(6));333</p>
<br>
</li>
<li><p>（掌握） <strong>String substring(int beginIndex,int endIndex)</strong></p>
<p><u>beginIndex包括，endIndex不包括</u></p>
<p>System.out.println(“111222333444”.substring(7,10));334【左闭右开】</p>
<br>
</li>
<li><p>（掌握） <strong>char[] toCharArray();</strong></p>
<p><u>将字符串转换成char数组</u></p>
<p>char[] chars &#x3D; “我是中国人”.toCharArray();</p>
<p>&#x2F;&#x2F;遍历得出结果：我 是 中 国 人</p>
<br>
</li>
<li><p>（掌握） <strong>String toLowerCase()</strong></p>
<p><u>转换成小写</u></p>
<p>System.out.println(“ABCDef”.toLowerCase());</p>
<br>
</li>
<li><p>（掌握） <strong>String toUpperCase()</strong></p>
<p><u>转换成大写</u></p>
<p>System.out.println(“ABCDef”.toLowerCase());</p>
<br>
</li>
<li><p>（掌握） <strong>String trim();</strong></p>
<p><u>去除字符串前后空白</u></p>
<p>System.out.println(“   sda sdas  “.trim());&#x2F;&#x2F;sda sdas</p>
<br>
</li>
<li><p>(掌握) .String中有一个方法是静态的不需要new对象</p>
<p>这个方法叫做valueOf，作用是“非字符串“转换成”字符串”</p>
<p>String s1 &#x3D; String.valueOf(true);</p>
<p>String s1 &#x3D; String.valueOf(123);</p>
<p>System.out.println(s1);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个静态的valueOf()方法，参数是一个对象的时候，会自动调用这个对象的toString()方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> String.valueOf(<span class="keyword">new</span> <span class="title class_">Customer</span>());</span><br><span class="line">System.out.println(s1);<span class="comment">//没有重写toString()方法之前是对象内存地址 </span></span><br><span class="line">System.out.println(s1);<span class="comment">//我是一个vip客户！</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span>&#123;</span><br><span class="line">    <span class="comment">//重写toString()方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我是一个vip客户！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>本质上System.out.println()这个方法在输出任何数据的时候都是先转换成字符串，再输出 </p>
<p><br><br><br><br></p>
</li>
</ol>
<h2 id="StringBuffer和StringBulider"><a href="#StringBuffer和StringBulider" class="headerlink" title="StringBuffer和StringBulider"></a>StringBuffer和StringBulider</h2><h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><ul>
<li><p>如果以后需要进行大量的字符串拼接操作，建议使用JDK自带的：<br>java.lang.StringBuffer;<br>java.lang.StringBuilder;</p>
</li>
<li><p>如何优化StringBuffer的性能？</p>
<p>在创建StringBuffer的时候尽可能给定一个初始化容量。</p>
<p>最好减少底层的扩容次数。预估计一下，给一个大一些的初始化容量。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个初始化容量为16个byte[]数组（字符串缓冲区对象）</span></span><br><span class="line">    StringBuffer stringBuffer= <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拼接字符串，以后拼接字符串同意调用append()方法</span></span><br><span class="line">    <span class="comment">//append是追加的意思</span></span><br><span class="line">    stringBuffer.append(<span class="string">&quot;abd&quot;</span>);</span><br><span class="line">    stringBuffer.append(<span class="number">3.14</span>);</span><br><span class="line">    stringBuffer.append(<span class="literal">true</span>);</span><br><span class="line">    stringBuffer.append(<span class="number">100l</span>);</span><br><span class="line">    <span class="comment">//append方法底层在进行追加的时候，如果byte数组慢了，会自动扩容</span></span><br><span class="line">    stringBuffer.append(<span class="number">100l</span>);</span><br><span class="line">    System.out.println(stringBuffer);<span class="comment">//abd3.14true100100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定初始化容量的StringBuffer对象（字符串缓冲区对象）</span></span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br><br></p>
<h3 id="StringBuilder和StringBuffer的异同"><a href="#StringBuilder和StringBuffer的异同" class="headerlink" title="StringBuilder和StringBuffer的异同"></a>StringBuilder和StringBuffer的异同</h3><ul>
<li>StringBuffer中的方法都有synchronized关键字修饰。表示StringBuffer在多线程环境下运行时安全的。StringBuilder则不安全</li>
<li>其余基本一样</li>
</ul>
<p><br><br><br><br></p>
<h2 id="8种基本数据类型对应的包装类型及方法"><a href="#8种基本数据类型对应的包装类型及方法" class="headerlink" title="8种基本数据类型对应的包装类型及方法"></a>8种基本数据类型对应的包装类型及方法</h2><h3 id="基本数据类型名对应的包装类型名"><a href="#基本数据类型名对应的包装类型名" class="headerlink" title="基本数据类型名对应的包装类型名"></a>基本数据类型名对应的包装类型名</h3><table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类型</th>
<th>父类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>java.lang.Byte</td>
<td>Number</td>
</tr>
<tr>
<td>short</td>
<td>java.lang.Short</td>
<td>Number</td>
</tr>
<tr>
<td>int</td>
<td>java.lang.Integer</td>
<td>Number</td>
</tr>
<tr>
<td>long</td>
<td>java.lang.Long</td>
<td>Number</td>
</tr>
<tr>
<td>float</td>
<td>java.lang.Float</td>
<td>Number</td>
</tr>
<tr>
<td>double</td>
<td>java.lang.Double</td>
<td>Number</td>
</tr>
<tr>
<td>boolean</td>
<td>java.lang.Boolean</td>
<td>Object</td>
</tr>
<tr>
<td>char</td>
<td>java.lang.Character</td>
<td>Object</td>
</tr>
</tbody></table>
<ul>
<li>以上八种包装类中，重点以java.lang.Integer为代表进行学习，其他的类型照葫芦画瓢就行</li>
</ul>
<h3 id="拆装箱及方法"><a href="#拆装箱及方法" class="headerlink" title="拆装箱及方法"></a>拆装箱及方法</h3><ul>
<li><p>八种包装类其中6个都是数字对应的包装类，他们的父类都是Nunber可先研究下Number中公共的方法：</p>
<p>Number是一个抽象类，无法实例化对象</p>
<p>Number类中有这样的方法：</p>
<table>
<thead>
<tr>
<th><strong>Modifier and Type</strong></th>
<th align="center"><strong>Method and Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td align="center"><code>byteValue()</code>返回指定号码作为值 <code>byte</code> ，这可能涉及舍入或截断。</td>
</tr>
<tr>
<td>abstract double</td>
<td align="center"><code>doubleValue()</code>返回指定数字的值为 <code>double</code> ，可能涉及四舍五入。</td>
</tr>
<tr>
<td>abstract float</td>
<td align="center"><code>floatValue()</code>返回指定数字的值为 <code>float</code> ，可能涉及四舍五入。</td>
</tr>
<tr>
<td>abstract int</td>
<td align="center"><code>intValue()</code>返回指定号码作为值 <code>int</code> ，这可能涉及舍入或截断。</td>
</tr>
<tr>
<td>abstract long</td>
<td align="center"><code>longValue()</code>返回指定数字的值为 <code>long</code> ，可能涉及四舍五入或截断。</td>
</tr>
<tr>
<td>short</td>
<td align="center"><code>shortValue()</code>返回指定号码作为值 <code>short</code> ，这可能涉及舍入或截断。</td>
</tr>
</tbody></table>
</li>
</ul>
<br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//123这个基本数据类型，进行构造方法的包装打到了：基本数据类型向引用数据类型的转型；</span></span><br><span class="line">    <span class="comment">//基本数据类型（转换为）引用数据类型：装箱</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//引用数据类型（转换为）基本数据类型：拆箱</span></span><br><span class="line">    <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> i.floatValue();</span><br><span class="line">    System.out.println(f);<span class="comment">//123.0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">revalue</span> <span class="operator">=</span> i.intValue();</span><br><span class="line">    System.out.println(revalue);<span class="comment">//123</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>关于Integer类的构造方法，有两个：</p>
<p>Integer(int)</p>
<p>Integer(String)</p>
</li>
<li><p>通过访问包装类的常量，来获取最大值和最小值：</p>
<p>System.out.println(Inter.MAX_VALUE);</p>
<p>System.out.println(Inter.MIN_VALUE);</p>
<p><br><br></p>
</li>
</ul>
<h3 id="JDK1-5以后，支持自动拆装箱："><a href="#JDK1-5以后，支持自动拆装箱：" class="headerlink" title="JDK1.5以后，支持自动拆装箱："></a>JDK1.5以后，支持自动拆装箱：</h3><ul>
<li><p>自动装箱：int–&gt;Integer</p>
<p>Integer x &#x3D; 100;</p>
</li>
<li><p>自动拆箱：Integer–&gt;int</p>
<p>int y &#x3D; x;</p>
<p><br><br><br><br></p>
</li>
</ul>
<h2 id="关于方法权益中的“整数型常量池”"><a href="#关于方法权益中的“整数型常量池”" class="headerlink" title="关于方法权益中的“整数型常量池”"></a>关于方法权益中的“整数型常量池”</h2><p>java中为了提高程序的执行小效率，讲[-128,127]之间的所有数据提前创建好，放到一个方法去的”整数型常量池“当中了，目的是只要这个区间的数据不需要再new了，可以直接从整数型常量池中取出来。 </p>
<h2 id="Integer常用方法"><a href="#Integer常用方法" class="headerlink" title="Integer常用方法"></a>Integer常用方法</h2><ol>
<li><p><strong>static int parseInt(String s)</strong></p>
<p><u>静态方法，传参String，返回int</u></p>
<p>parse方法，把字符串转化成基本数据类型</p>
<p>int retValue &#x3D; Integer.parseInt(“123”);&#x2F;&#x2F;123,String–&gt;int</p>
<p>照葫芦画瓢：</p>
<p>double retValue2 &#x3D; Double.parseDouble(“3.14”);</p>
<p>System.out.println(retValue2+1); &#x2F;&#x2F;4.140000000000001(精度问题)</p>
</li>
<li><p><strong>valueOf</strong>方法作为了解</p>
<p>static Integer valueOf(int i)</p>
<p><u>静态的：int –&gt;Integer</u></p>
<p><code>Integer i1 = Integer.valueOf(100);</code></p>
<br>

<p>static Integer valueOf(String s)</p>
<p><u>静态的：String–&gt;Integer</u></p>
<p><code>Integer i2 = Integer.valueOf(&quot;100&quot;);</code></p>
<p><br><br><br><br></p>
</li>
</ol>
<h2 id="String-int-Integer三种类型的互相转换："><a href="#String-int-Integer三种类型的互相转换：" class="headerlink" title="String int Integer三种类型的互相转换："></a>String int Integer三种类型的互相转换：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="comment">//String --&gt;int</span></span><br><span class="line">    String s1=<span class="string">&quot;100&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> Integer.parseInt(s1);</span><br><span class="line">    System.out.println(i1+<span class="number">1</span>);<span class="comment">//101</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//int --&gt;String</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> i1+<span class="string">&quot;&quot;</span>;</span><br><span class="line">    System.out.println(s2+<span class="number">1</span>);<span class="comment">//1001</span></span><br><span class="line">        <span class="type">long</span> i=System.currentTimeMillis();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">ig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">100</span>);</span><br><span class="line">        String s= String.valueOf(i);<span class="comment">//long--&gt;String</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> String.valueOf(ig);<span class="comment">//Integer--&gt;String</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//int --&gt;Integer</span></span><br><span class="line">  <span class="comment">//自动装箱</span></span><br><span class="line">  Integer x=<span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Integer --&gt;int</span></span><br><span class="line">  <span class="comment">//自动拆箱</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x;</span><br><span class="line">  <span class="comment">//String --&gt;Integer</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">k</span> <span class="operator">=</span> Integer.valueOf(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Integer --&gt;String</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(k);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   <br><br><br><br></p>
<h2 id="java对日期的处理："><a href="#java对日期的处理：" class="headerlink" title="java对日期的处理："></a>java对日期的处理：</h2><ol>
<li><p>怎么获取系统当前时间</p>
</li>
<li><p>String –&gt;Date</p>
</li>
<li><p>Date –&gt;String</p>
<p>注意：字符串的日期格式和SimpleDateFormat对象指定的日期格式要一直，不然会出现异常</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">     <span class="comment">//获取系统当前时间</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">nowTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(nowTime);<span class="comment">//Thu Feb 04 23:20:25 CST 2021</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 日期可以格式化吗？</span></span><br><span class="line"><span class="comment">         * 将日期类型Date,按照指定格式进行转换：Date (转换成具有一定格式的日期字符串) --&gt;String</span></span><br><span class="line"><span class="comment">         * SimpleDateFormat是java。text包下的。专门负责日期格式化</span></span><br><span class="line"><span class="comment">         * yyyy年</span></span><br><span class="line"><span class="comment">         * MM月</span></span><br><span class="line"><span class="comment">         * dd日</span></span><br><span class="line"><span class="comment">         * HH小时</span></span><br><span class="line"><span class="comment">         * mm分</span></span><br><span class="line"><span class="comment">         * ss秒</span></span><br><span class="line"><span class="comment">         * SSS毫秒</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyy-M-d H:m:s:S&quot;</span>);<span class="comment">//格式随意组织，特殊字母不能动,这里的字母是java定好的，不能动</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">nowTimeStr</span> <span class="operator">=</span> sdf.format(nowTime);</span><br><span class="line">        System.out.println(nowTimeStr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//String--&gt;Date</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> <span class="string">&quot;2008-08-08 08:08:08 888&quot;</span>;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-M-d H:m:s S&quot;</span>);</span><br><span class="line">        <span class="comment">//上面两个格式必须相同</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">dateTime</span> <span class="operator">=</span> sdf2.parse(time);</span><br><span class="line">        System.out.println(dateTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br><br><br><br></p>
<h2 id="System类的相关属性和方法："><a href="#System类的相关属性和方法：" class="headerlink" title="System类的相关属性和方法："></a>System类的相关属性和方法：</h2><ul>
<li>System.out【out是System类的静态变量】</li>
<li>System.outt.println() 【println()方法不是System类的，是PrintStream类的方法】</li>
<li>System.gc() 建议启动垃圾回收器</li>
<li>System.currentTimeMillis() 获取1970年1月1日到系统当前时间的总毫秒数</li>
<li>System.exit(0) 退出JVM</li>
</ul>
<p> <br><br><br><br></p>
<h2 id="关于数字的格式化"><a href="#关于数字的格式化" class="headerlink" title="关于数字的格式化"></a>关于数字的格式化</h2><p>由于用的是在太少，想了解的点击<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Rx411876f?p=623&spm_id_from=pageDriver%E7%9A%84623%E9%9B%86%EF%BC%8C%E7%AC%94%E8%AE%B0%E5%B0%B1%E4%B8%8D%E5%81%9A%E4%BA%86%E3%80%82">https://www.bilibili.com/video/BV1Rx411876f?p=623&amp;spm_id_from=pageDriver的623集，笔记就不做了。</a></p>
<p> <br><br><br><br></p>
<h2 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h2><ol>
<li><p>BigDecimal 属于大数据，精度极高。不属于基本数据类型，属于java对象（引用数据类型）。</p>
<p>这是SUN提供的一个类。专门用在财务软件当中</p>
</li>
<li><p>问：你处理过财务数据吗？用的哪一种类型？</p>
<p>答：java.math.BigDecimal</p>
</li>
</ol>
<p> <br><br><br><br></p>
<h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><ul>
<li><p>第一种方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Random random=<span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="type">int</span> num=random.nextInt();<span class="comment">//任何数</span></span><br><span class="line"><span class="type">int</span> num2=random.nextInt(<span class="number">6</span>);<span class="comment">//0到5任何整数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>第二种方法</p>
<p>第二种方法返回的数值是[0.0,1.0）的double型数值，由于double类数的精度很高，可以在一定程度下看做随机数，借助（int）来进行类型转换就可以得到整数随机数了，代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">    <span class="type">int</span> max=<span class="number">100</span>,min=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ran2</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random()*(max-min)+min);</span><br><span class="line">    System.out.println(ran2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p> <br><br><br><br></p>
<h2 id="枚举："><a href="#枚举：" class="headerlink" title="枚举："></a>枚举：</h2><ol>
<li>一枚一枚可以列举出来的，才建议使用枚举类型</li>
<li>枚举编译后产生的也是class文件</li>
<li>枚举也是一种引用数据类型</li>
<li>枚举中的每一个值可以看做是常量</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Result</span> <span class="variable">r</span> <span class="operator">=</span> divide(<span class="number">10</span>,<span class="number">3</span>);</span><br><span class="line">        System.out.println(r);</span><br><span class="line">            System.out.println(r==Result.SUCCESS ? <span class="string">&quot;计算成功&quot;</span>:<span class="string">&quot;计算失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">divide</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a/b;</span><br><span class="line">            <span class="keyword">return</span> Result.SUCCESS;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.FAIL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&#123;</span><br><span class="line">        SUCCESS,FAIL</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <br><br><br><br></p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ol>
<li><p>什么事异常，java提供异常处理机制有什么用？</p>
<p>以下程序执行过成功发生了不正常的情况，这种不正常的情况叫做：异常</p>
<p>java是很完善的语言，提供了异常的处理方式，以下程序执行过程中出现了不正常的情况</p>
<p>java把改异常信息打印输出到控制糖，供程序员参考。程序员看到异常信息后，可以对程序进行修改，让程序更加健壮。</p>
<p> <br><br></p>
</li>
<li><p>java语言中异常是以什么形式存在的呢？</p>
<ol>
<li><p>异常在java中以类的形式存在，每一个异常类都可以创建对象。</p>
</li>
<li><p>异常对应的现实生活中是怎么样的</p>
<p>火灾（异常类）：</p>
<p>2008年8月8日，小明家着火了（异常对象。</p>
<p>2008年8月9日，小刚家着火了（异常对象。</p>
<p>2008年9月8日，小红家着火了（异常对象。</p>
<br>

<p>类是：模板</p>
<p>对象是：实际存在的个体</p>
<br>

<p>钱包丢了（异常类）</p>
<p>2008年1月8日，小明的钱包丢了（异常对象）</p>
<p> <br><br></p>
</li>
</ol>
</li>
<li><p>java的异常处理机制：</p>
<ol>
<li><p>异常在java中以类和对象的形式存在。那么异常的继承结构是怎么样的？</p>
<p>我们可以使用UML图来描述一下继承结构。画UML图有很多工具，例如:Rational Rose 、starUML等</p>
<p>object</p>
<p>object下有Throwable（可抛出的）</p>
<p>Throwable下面有两个分支：Error(不可处理，直接退出JVM)和Exception(可处理的)    </p>
<p>Excepion下面有两个分支</p>
<ol>
<li><strong>Exception的直接子类：编译时异常</strong>（要求程序员在编写程序阶段必须预先对这些异常进行处理，如果不处理编译器就会报错，因此得名编译时异常）</li>
<li><strong>RuntimeException：运行时异常。</strong>（在编写程序阶段程序员可以预先处理也可以不管，都行）</li>
</ol>
<br>
</li>
<li><p>编译时异常和运行时异常，都是发生在运行阶段，编译阶段异常是不会发生的。</p>
<p>所有异常都是在运行阶段发生的，因此只有程序运行阶段才可以new对象。</p>
<p>因此异常的发生就是inew异常对象。</p>
<br>
</li>
<li><p>编译时异常和运行时异常的区别？</p>
<ol>
<li><strong>编译时异常一般发生的概率比较高&#x2F;&#x2F;  又叫受检异常或受控异常</strong></li>
</ol>
<ul>
<li><p>例：你看到外面下雨了，倾盆大雨的。</p>
<p>你出门之前预料到：如果不打伞，我可能会生病（生病是一种异常）</p>
<p>而且这个异常发生的概率比较高，所以我们出门之前要拿一把伞。</p>
<p>“拿一把伞”就是对“生病异常”发生之前的一种处理方式</p>
</li>
<li><p>对于一些发生概率较高的异常，需要在运行之前对其进行预处理。</p>
<br></li>
</ul>
<ol start="2">
<li><strong>运行时异常一般发生的概率比较低&#x2F;&#x2F;  又叫未受检异常或非受控异常</strong></li>
</ol>
<ul>
<li><p>例：小明走在大街上，可能会被天上的飞机轮子砸到。</p>
<p>被飞机轮子砸到也算一种异常。</p>
<p>但是这种异常发生概率较低。</p>
<p>在出门之前你没必要提前对这种发生概率较低的异常进行预处理。</p>
<p>如果你预处理这种异常，你讲获得很累。</p>
<br></li>
</ul>
<ol start="3">
<li>假设java中没有对异常进行划分，没有分为：编译时异常和运行时异常，所有异常需要再编写程序阶段对其进行预处理，是怎么样的效果呢？</li>
</ol>
<ul>
<li><p>首先，如果这样的话，程序肯定绝对安全的</p>
<ul>
<li>但是程序员编写程序太累的，代码到处都是处理异常的代码。</li>
</ul>
<p><br><br><br><br></p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="java语言中对异常的处理包括两种方式："><a href="#java语言中对异常的处理包括两种方式：" class="headerlink" title="java语言中对异常的处理包括两种方式："></a>java语言中对异常的处理包括两种方式：</h3><ol>
<li>在方法声明的位置上使用throws关键字，抛给上一级</li>
</ol>
<p>   谁调用我，我就抛给谁。抛给上一级。</p>
<p>注意：<strong>子类不能抛出比父类更宽泛&#x2F;更多的异常，比如继承了一个父类，但是这个父类没有thorws过异常，所以这个子类只能try..catch</strong></p>
<ol start="2">
<li>使用try…catch语句进行异常的捕捉</li>
</ol>
<p>   这件事发生了，谁也不知道，因为我给抓住了</p>
<p>   举个例子：</p>
<ul>
<li>我是某集团的一个销售员，因为我的失误，导致公司损失了1000元</li>
<li>“损失”1000元，可以看做一个异常发生了。我有两种处理方式</li>
<li>第一种方式：我把这件事告诉领导【异常上抛】</li>
<li>第二种方式：我自己掏腰包把这钱补上【异常捕捉】</li>
</ul>
<p>   <strong>java中异常发生后如果一直上抛，最后抛给了main方法，main方法继续上抛，抛给了调       用者JVM，JVM知道这个异常发生，只有一个结果。终止java程序的执行。</strong></p>
<p>   注意：只要异常没有捕捉，采用上报的方式，此方法的后续代码不会执行。</p>
<p>   另外需要注意，try语句块的某一行出现异常，该行后面的代码不会执行。</p>
<p>   try..catch捕捉后，后续代码可以执行。</p>
<p>   <br><br></p>
<h3 id="深入try-catch"><a href="#深入try-catch" class="headerlink" title="深入try..catch"></a>深入try..catch</h3><ol>
<li>catch后面的小括号中的类型可以是具体的异常类型，也可以是该异常类型的父类型。</li>
<li>catch可以写多个。建议catch的时候，精确的一个一个处理，这样有利于程序的调试。</li>
<li>catch写多个的时候，从上到下，必须遵守从小到大</li>
</ol>
<p>   <br><br></p>
<h3 id="上报和捕捉的选择："><a href="#上报和捕捉的选择：" class="headerlink" title="上报和捕捉的选择："></a>上报和捕捉的选择：</h3><p>   如果希望调用者来处理，选择throws上报</p>
<p>   <br><br></p>
<p>   异常对象有两个非常重要的方法：、</p>
<ol>
<li><p>获取异常简单的描述信息：</p>
<p>String msg &#x3D; exception.getMessage();</p>
</li>
<li><p>打印异常追踪的栈堆信息：</p>
<p>exception.printStackTrace();【exception是对象】</p>
<p> <br><br></p>
</li>
</ol>
<h3 id="关于try-catch中的fianlly子句"><a href="#关于try-catch中的fianlly子句" class="headerlink" title="关于try..catch中的fianlly子句"></a>关于try..catch中的fianlly子句</h3><ol>
<li><p>在finally子句中的代码是最后执行的，并且是一定会执行，即使try语句块中的代码出现了异常。</p>
<p>finally子句必须和try一起出现，不能单独编写。</p>
</li>
<li><p>finally语句通常使用在哪些情况下呢？</p>
</li>
</ol>
<p> <br><br></p>
<h3 id="java中任何自定义异常"><a href="#java中任何自定义异常" class="headerlink" title="java中任何自定义异常"></a>java中任何自定义异常</h3><p>两步：</p>
<ol>
<li>编写一个类继承Exception或者RuntimeException</li>
<li>提供两个构造方法，一个无参数的，一个带有String</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">MyException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;用户民不能为空！&quot;</span>);</span><br><span class="line">    e.printStackTrace();<span class="comment">//打印异常堆栈信息</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取异常简单描述信息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> e.getMessage();</span><br><span class="line">    System.out.print(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br><br><br><br></p>
<h2 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h2><ol>
<li><p>什么事集合？有啥用？</p>
<p>数组其实就是一个集合。集合实际上就是一个容器，可以用来容纳其他类型的数据。</p>
<p>集合为什么说在开发中使用较多？</p>
<ul>
<li><p>集合是一个容器，一个载体，可以一次容纳多个对象，在实际开发中，假设连接数据库，数据库当中有10条记录，那么假设把这10条记录查询出来，在java程序中会将10条数据封装成10个java对象，然后将10个java对象放到某一个集合当中，将集合传动前端，然后遍历集合，将一个数据一个数据展现出来。</p>
<br></li>
</ul>
</li>
<li><p>集合不能直接存储数据类型，另外集合也不能直接存储java对象，集合当中存储的都是ijava对象的内存地址。（或者说集合中存储的是引用</p>
<ul>
<li>list.add(100);&#x2F;&#x2F;自动装箱Integer</li>
<li>注意：集合在java中本事是一个容器，也是一个对象。集合在任何时候存储的都是引用。</li>
</ul>
<br>
</li>
<li><p>在java中年每一个不同的集合，底层会对应不同的数据结构。往不同的集合中存储元素，等于将数组放到了不同的数据结构当中。什么是数据结构？数据存储的结构就是数据结构。不同的数据结构，数据存储的方式不同。例如：</p>
</li>
</ol>
<ul>
<li><p>数组、二叉树、链表、哈希表…图</p>
</li>
<li><p>以上这些都是常见的数据结构</p>
</li>
<li><p>使用不同的集合等同于使用了不同的数据结构。</p>
</li>
<li><p>往集合c1中放数据，可能放到数组上了，往集合c2中放数据，可能放到二叉树上了….</p>
</li>
<li><p>在这一章节，需要掌握的不是精通数据结构。java中已经将数据结构实现了，已经写好了这些常用的集合类，你只需要掌握掌握怎么用。在什么情况下选择哪一种合适的集合去使用即可。</p>
</li>
<li><p>new ArrayList();创建一个集合对象，底层是数组</p>
</li>
<li><p>new LinkedList();创建一个集合对象，底层是链表</p>
</li>
<li><p>new TreeSet();创建一个集合对象，底层是二叉树 </p>
<br></li>
</ul>
<ol start="4">
<li><p>集合在java JDK中哪个包下？</p>
<p>java.util.*;  所有的集合类和集合接口都在java.uti包下。 </p>
</li>
<li><p>最后能将集合的继承结构图背会。</p>
<p>集合整个这个体系是怎么样的一个结构，你需要有印象。</p>
</li>
<li><p>在java中结合分为两大类</p>
<ul>
<li><p>一类是单个方式存储元素：</p>
<p>单个方式存储元素，这一类集合中超级父接口：java.util.Collection;</p>
</li>
<li><p>一类是以键值对儿的方式存储元素，这一类集合中的超级父接口：java.util.Map;</p>
</li>
</ul>
</li>
</ol>
<p>​       <br><br> <br><br></p>
<h2 id="关于java-util-Collection接口中常用的方法"><a href="#关于java-util-Collection接口中常用的方法" class="headerlink" title="关于java.util.Collection接口中常用的方法"></a>关于java.util.Collection接口中常用的方法</h2><ol>
<li><p>Collection中能存放什么元素？</p>
<p>没有使用泛型之前，Collection中可以存储Object的所有子类型。</p>
<p>使用了“泛型”后，Collection中只能存储某个具体的类型。</p>
<p>集合后期我们会学习“泛型”的语法，目前先不用管。Collction中什么都能存，只要是Object的子类型就行。（集合中不能直接存储基本数据类型，也不能存java对象，只是存储java对象的内存地址。）</p>
</li>
<li><p>Collection中的常用方法</p>
<p><code>boolean add(Object e)</code> 向集合中添加元素</p>
<p><code>int size()</code> 获取集合中元素的个数</p>
<p><code>void clear()</code>清空集合</p>
<p><code>boolean contain(Object o)</code> 判断当前集合中是否包含元素o，包含返回true，不包含返回false</p>
<p><code>boolean remove(Object 0)</code> 删除集合中的某个元素</p>
<p><code>boolean isEmpty()</code> 判断集合中元素的个数是否为0</p>
<p><code>Object[] toArray()</code> 调用这个方法可以把集合转换成数组。</p>
</li>
<li><p>迭代集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">   Collection c  <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">   c.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">   c.add(<span class="string">&quot;def&quot;</span>);</span><br><span class="line">   c.add(<span class="number">100</span>);</span><br><span class="line">   c.add(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">   <span class="comment">//进行迭代</span></span><br><span class="line">   <span class="comment">//第一步，获取集合对象的迭代器对象Iterator</span></span><br><span class="line">   <span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> c.iterator();</span><br><span class="line">   <span class="comment">//第二步，通过以上获取的的迭代器对象开始迭代集合</span></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   一以下两个方法是迭代器对象Iterator中的方法</span></span><br><span class="line"><span class="comment">   boolean hasNext()如果仍有元素可以迭代，则返回true。</span></span><br><span class="line"><span class="comment">   Objext next()返回迭代的下一个集合。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">       <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> it.next();</span><br><span class="line">       System.out.println(obj);</span><br><span class="line">       </span><br><span class="line">   <span class="comment">/*存进去是什么类型，取出来就是什么类型，</span></span><br><span class="line"><span class="comment">   只不过输出的时候回转换成字符串。因为println会调用toString()方法。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结重点：</p>
</li>
<li><p>把集合继承结构图背会。</p>
<ol start="2">
<li>把Collection接口中常用方法测试几遍</li>
</ol>
</li>
<li><p>把迭代器弄明白</p>
<ol start="4">
<li>Collection接口中的remove方法和contain方法底层都会调用（重写）equals。</li>
</ol>
<p> <br><br></p>
</li>
</ol>
<h3 id="关于集合元素的remove"><a href="#关于集合元素的remove" class="headerlink" title="关于集合元素的remove"></a>关于集合元素的remove</h3><ul>
<li><p>重点：当集合的结构发生改变是，迭代器萹蓄重新获取，如果还是用以前老的迭代器，会出现异常：java.util.ConcurrentModificationException</p>
</li>
<li><p>重点：在迭代集合元素的过程中，不能调用集合对象的remove方法，删除元素：</p>
<p>c.remove(0); 迭代过程中不能这样</p>
<p>否则会出现 java.util.ConcurrentModificationException</p>
</li>
<li><p>重点：在迭代元素的过程中，一定要使用迭代器的Itertator的remove方法，删除元素，不要使用集合自带的remove方法。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(it2.hasNext())&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> it2.next();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    chu出异常的根本原因：集合中元素删除了，但没有更新迭代器（迭代器不知道集合变化了）</span></span><br><span class="line"><span class="comment">    c2.remove(o)； 直接通过集合去删除元素，没有通知迭代器。（导致迭代器的快照和原集合状态不同</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//使用迭代器去删除时，会自动更新迭代器，并且更新集合（删除集合中的元素）</span></span><br><span class="line">   it2.remove();<span class="comment">//删除的一定是迭代器指向的当前元素</span></span><br><span class="line">    System.out.println(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p> <br><br> <br><br></p>
<h2 id="关于java-util-list接口中常用的方法"><a href="#关于java-util-list接口中常用的方法" class="headerlink" title="关于java.util.list接口中常用的方法"></a>关于java.util.list接口中常用的方法</h2><ol>
<li><p>​      List集合存储元素的特点：有序可重复</p>
<p>有序：List集合中的元素有下标。</p>
<p>从0开始，以1递增</p>
<p>可重复：存储一个1，还可以在存储1</p>
</li>
<li><p>List接口既然是Collection接口的子接口，那么肯定List接口有自己的”特色”的方法(以下只列出list特有的，常用的方法)</p>
<ul>
<li><code>void add(int index，E element)</code> 在列表的指定位置插入指定元素（第一个参数是下标）（后面的元素依次顺移一位）</li>
<li><code>Object get(int index)</code> 按下标获取元素</li>
<li><code>int indexOf(Object o)</code> 返回指定对象第一次出现处的索引</li>
<li><code>int lastIndexOf(Object o) </code>返回指定对象最后一次出现处的索引</li>
<li><code>Object remove(int index)</code> 删除指定下标位置的元素</li>
<li><code>Object set(int index, E element)</code> 修改指定位置的元素</li>
</ul>
</li>
</ol>
<p> <br><br> <br><br></p>
<h2 id="ArrayList集合："><a href="#ArrayList集合：" class="headerlink" title="ArrayList集合："></a>ArrayList集合：</h2><ol>
<li><p>默认初始化容量为10（底层先创建了一个长度为0的数组，当前添加第一个元素的时候初始化容量10）</p>
</li>
<li><p>集合底层是一个Object[]数组</p>
</li>
<li><p>构造方法：</p>
<p><code>new ArrayList();</code></p>
<p><code>new ArrayList(20);</code></p>
</li>
<li><p>ArrayList集合的扩容：</p>
<p>增长到原容量的1.5倍。</p>
<p>ArrayList集合底层是数组，怎么优化：尽可能少的扩容。因为数组扩容效率比较低，建议在使用ArrayList集合的时候预估元素的个数，给定一个初始化容量。</p>
</li>
<li><p>这么多集合中，用哪个集合最多？</p>
<p>ArrayList集合</p>
<p>因为往数组末尾添加元素，效率不受影响。</p>
<p>另外，我们检索、查找某个元素的操作比较多</p>
</li>
<li><p>另一个构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();<span class="comment">//创建HashSet集合</span></span><br><span class="line">c.add(<span class="number">100</span>);</span><br><span class="line">c.add(<span class="number">200</span>);</span><br><span class="line">c.add(<span class="number">900</span>);</span><br><span class="line"><span class="comment">//通过这个构造方法可以将HashSet结合转换成List集合</span></span><br><span class="line"><span class="type">List</span> <span class="variable">myList3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(c);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; myList3.size() ; i++)&#123;</span><br><span class="line">    System.out.println(myList.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p> <br><br> <br><br></p>
<h2 id="链表："><a href="#链表：" class="headerlink" title="链表："></a>链表：</h2><ul>
<li><p>优点：</p>
<p>由于链表上的元素在空间存储上的内存地址不连续。</p>
<p>所有随记增删元素的时候不会有大量的元素位移，因此随记增删效率较高。</p>
<p>在以后的开发中，如果遇到随机增删集合中元素的业务比较多时，建议使用LinkedList。</p>
</li>
<li><p>缺点：</p>
<p>不能通过数学表达式计算被查找元素的内存地址，每一次查找都是从头节点开始遍历，直到找到为止。所以LinkedList集合检索、查找的效率较低。</p>
<br>
</li>
<li><p>ArrayList 数组的特点，把检索发挥到机制（但ArrayList是非线程安全的。不是线程安全的集合。）</p>
</li>
<li><p>LinkedList 链表特点（双向链表），把随机增删发挥到机制</p>
<p>LinkedList有初始容量吗？没有</p>
<p>最初这个链表中没有任何元素。first和last引用都是null</p>
<p>不管是LinkedList还是ArrayList，以后写代码不需要关心具体是哪个集合。</p>
<p>因为我们要面向接口编程，调用的方法都是接口中的方法</p>
</li>
</ul>
<p> <br><br> <br><br></p>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><ol>
<li><p>底层也是一个数组</p>
</li>
<li><p>初始化容量：10</p>
</li>
<li><p>怎么扩容的？</p>
<p>扩容之后是原容量的2倍</p>
</li>
<li><p>ArrayList集合扩容特点：</p>
<p>ArrayList集合扩容是原容量的1.5倍</p>
</li>
<li><p>Vector所有方法都是线程同步的，都带有synchronized关键字，是线程安全的。效率比较低，使用较少了。</p>
</li>
<li><p>怎么讲一个线程不安全的ArrayList集合转换成线程安全的呢？</p>
<p>使用集合工具类：</p>
<p>java.util.Collections;</p>
<p>java.util.Collection是集合接口；java.util.Collections是集合工具类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();<span class="comment">//非线程安全的</span></span><br><span class="line"><span class="comment">//变成线程安全的</span></span><br><span class="line">Collections.synchronizedList(myList);</span><br><span class="line"></span><br><span class="line"><span class="comment">//myList集合线程就是安全的了</span></span><br><span class="line">myList.add(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">myList.add(<span class="string">&quot;222&quot;</span>);</span><br><span class="line">myList.add(<span class="string">&quot;333&quot;</span>);</span><br></pre></td></tr></table></figure>

<p> <br><br> <br><br></p>
</li>
</ol>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ol>
<li><p>JDK5.0之后推出的新特性：泛型</p>
</li>
<li><p>泛型这种语法机制，只在程序编译阶段起作用，只是给编译器参考的。（运行阶段泛型没用！）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Animal Cat Bird类的代码省略</span></span><br><span class="line">List&lt;Animal&gt; myList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Animal&gt;();</span><br><span class="line"><span class="type">cat</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"><span class="type">Bird</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">myList.add(c);</span><br><span class="line">myList.add(b);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">JDK8之后，ArrayList&lt;这里的类型会自动推断&gt;(),前提是JDK8之后才允许</span></span><br><span class="line"><span class="comment">自动类型推断，钻石表达式</span></span><br><span class="line"><span class="comment">List&lt;Animal&gt; myList = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Iterator&lt;Animal&gt; it = myList.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> it.next();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用了泛型的好处是什么？</p>
<ul>
<li>集合中存储的元素类型同意了。</li>
<li>从集合中取出的元素类型是泛型指定的类型，不需要进行大量的“向下转型”</li>
</ul>
</li>
<li><p>泛型的缺点是什么？</p>
<ul>
<li>导致集合中存储的元素缺乏多样性！</li>
<li>大多数业务中，集合中元素的类型还是统一的。所以这种·泛型特性被大家所认可</li>
</ul>
</li>
<li><p>自定义泛型可以吗？可以</p>
<ul>
<li><p>自定义泛型的时候，&lt;&gt;尖括号中的是一个标识符，随便下。</p>
</li>
<li><p>java源代码中经常出现的是：<code>&lt;E&gt;</code>和<code>&lt;T&gt;</code></p>
<p>E:Element元素</p>
<p>T:Type类型</p>
</li>
</ul>
</li>
</ol>
<p> <br><br> <br><br></p>
<h2 id="增强for循环：foreach"><a href="#增强for循环：foreach" class="headerlink" title="增强for循环：foreach"></a>增强for循环：foreach</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">for(元素类型 变量名 : 数组或集合)&#123;</span></span><br><span class="line"><span class="comment"> System.out.println(变量名);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> [] arr =&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> data : arr)&#123;</span><br><span class="line">    <span class="comment">//data就是数组中的元素</span></span><br><span class="line">    System.out.println(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <br><br> <br><br></p>
<h2 id="Set下的子类"><a href="#Set下的子类" class="headerlink" title="Set下的子类"></a>Set下的子类</h2><ul>
<li><p>HashSet集合：无序不可重复</p>
</li>
<li><p>TreeSet集合存储元素的特点：</p>
<ol>
<li><p>无序不可重复，但是存储的元素可以自动按照大小顺序排序！ </p>
<p>称为：可排序集合</p>
</li>
<li><p>无序：这里的无序指的是存进去的顺序和取出来的顺序不同。并且没有下标</p>
</li>
</ol>
<p> <br><br> <br><br></p>
</li>
</ul>
<h2 id="java-util-Map接口中常用的方法"><a href="#java-util-Map接口中常用的方法" class="headerlink" title="java.util.Map接口中常用的方法"></a>java.util.Map接口中常用的方法</h2><ol>
<li><p>Map和Collection没有继承关系</p>
</li>
<li><p>Map集合以 key 和 value 的方式存储数据：键值对</p>
<p>key和value都是引用数据类型，都是存储对象的内存地址</p>
<p>key起到主导地位，value是key的一个附属品</p>
</li>
<li><p>Map接口中常用方法</p>
<ul>
<li><p><code>V put(K key，V vaLue)</code> 向Map集合中添加键值对</p>
</li>
<li><p><code>V get(Object key)</code>  通过key获取vaLue</p>
</li>
<li><p><code>void clear()</code> 清空Map集合</p>
</li>
<li><p><code>boolean containsKey(Object key)</code> 判断Map中是否包含某个key</p>
</li>
<li><p><code>boolean containsVaLue(Object vaLue)</code> 判断Map中是否包含某个value</p>
</li>
<li><p><code>boolean isEmpty()</code> 判断Map集合中元素个数是否为0</p>
</li>
<li><p><code>Set&lt;K&gt; keySet()</code> 获取Map集合所有的key（所有的键是个set集合）</p>
</li>
<li><p><code>V remove(Object key)</code>通过key删除键值对</p>
</li>
<li><p><code>int size()</code>获取Map集合中键值对的个数</p>
</li>
<li><p><code>ColLection&lt;V&gt; vaLues()</code> 获取Map集合中所有的value，返回一个Collection</p>
<br>
</li>
<li><p><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entry Set()</code> 将Map集合转换成set集合</p>
<p>例：<code>Set&lt;Map.Entry&lt;Integer,String&gt;&gt; set = map.entry Set()</code> </p>
<p>假设现在有有一个Map集合 “map1”</p>
<p>Set set &#x3D; map1.entrySet();</p>
<p>【注意：Map集合通过entrySet()方法转换成的这个Set集合，Set集合中元素的类型是Map.Entry&lt;K,V&gt;】</p>
<p>【Map.Entry和String一样，都是一种类的名字，只不过：Map.Entry是静态内部类，是Map中的静态内部类】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SelfTest;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Myclass</span>&#123;</span><br><span class="line">    <span class="comment">//声明一个静态内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span>&#123;</span><br><span class="line">        <span class="comment">//静态方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;静态内部类的m1方法实行&quot;</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//实例方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;静态内部类中的实例方法执行！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//类名叫做：MyClass.InnerClass</span></span><br><span class="line">        Myclass.InnerClass.m1();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建静态内部类对象</span></span><br><span class="line">        Myclass.<span class="type">InnerClass</span> <span class="variable">mi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Myclass</span>.InnerClass();</span><br><span class="line">        mi.m2();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给一个Set集合</span></span><br><span class="line">        <span class="comment">//该Set集合中存储的对象是Myclass.InnerClass类型</span></span><br><span class="line">        Set&lt;Myclass.InnerClass&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这个Set集合中存储的是字符串对象</span></span><br><span class="line">        Set&lt;String&gt; set2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Set&lt;MyMap.MyEntry&lt;Integer,String&gt;&gt; set3= <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyMap</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyEntry</span>&lt;K,V&gt;&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>遍历Map集合（重点！！！）遍历集合</p>
<ul>
<li><p>第一种方式：</p>
<p>获取所有·的key，通过遍历key，来遍历value</p>
<p>获取所有key，所有key是一个Set集合</p>
<p><code>Set&lt;Integer&gt; keys = map.keySet();</code></p>
<p>通过key获取value</p>
</li>
<li><p>第二种方式：</p>
<p><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code></p>
<p>以上方法就是把Map集合直接全部转换成Set集合</p>
<p>Set集合中的元素的类型是：Map.Entry</p>
<br></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SelfTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;Integer,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">1</span>,<span class="string">&quot;zs&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>,<span class="string">&quot;ls&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>,<span class="string">&quot;ww&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>,<span class="string">&quot;zl&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一种方法 获取所有key，所有key是一个Set集合</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Set&lt;Integer&gt; keys = map.keySet();</span><br><span class="line">        <span class="comment">//foreach</span></span><br><span class="line">        <span class="keyword">for</span> (Integer key: keys) &#123;</span><br><span class="line">            System.out.println(key + <span class="string">&quot;=&quot;</span> + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//迭代器</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> keys.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> it.next();</span><br><span class="line">            System.out.println(o + <span class="string">&quot;=&quot;</span> + map.get(o));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第二种方法 把Map集合直接全部转换成Set集合</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Set&lt;Map.Entry&lt;Integer,String&gt;&gt; set = map.entrySet();<span class="comment">//将Map集合变成Set集合</span></span><br><span class="line">        <span class="comment">//迭代器</span></span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; it2 = set.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it2.hasNext())&#123;</span><br><span class="line">            Map.Entry&lt;Integer,String&gt; node = it2.next();</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">key</span> <span class="operator">=</span> node.getKey();</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> node.getValue();</span><br><span class="line">            System.out.println(key+<span class="string">&quot;=&quot;</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//foreach</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer,String&gt; node : set) &#123;</span><br><span class="line">            System.out.println(node.getKey()+<span class="string">&quot;=&quot;</span>+node.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p> <br><br> <br><br></p>
<h2 id="HshMap集合"><a href="#HshMap集合" class="headerlink" title="HshMap集合"></a>HshMap集合</h2><ol>
<li><p>HashMap集合底层是哈希表&#x2F;散链表数据结构</p>
</li>
<li><p>哈希表是一个怎样的数据结构？</p>
<p>哈希表是一个数组和单向链表的结合体</p>
</li>
<li><p>HashMap集合的key部分特点：</p>
<p>无序，不可重复</p>
<p>为什么无序？因为不一定挂到哪个单向链表上。</p>
<p>不可重复是怎么保证的？equals方法来保证HashMap集合的key不可重复。</p>
<p>如果key重复了，value会覆盖</p>
<br>

<p>放在HashMap集合key部分的元素其实就是放到HashSet集合中了。</p>
<p>所以HashSet集合中的元素也需要同时重写hashCode()+equals()方法</p>
</li>
<li><p>哈希表HashMap使用不当时无法发挥性能！</p>
<p>要求散列分布均匀，需要你重写hashCode()方法时有一定的技巧。</p>
</li>
<li><p>重点：放在HashMap集合key部分的元素，以及放在HashSet集合中的元素，同时重写equals方法和hashCode方法</p>
</li>
<li><p>HashMap集合的默认初始化容量为16，默认加载因子是0.75</p>
<p>这个默认加载因子是当HashMap集合底层数组的容量达到75%的时候，数组开始扩容，扩容之后是原容量的2倍</p>
<p>重点：HashMap初始化容量必须是2的倍数，这是为了散列分布均匀，提高HashMap集合的存储效率，所必须的。</p>
</li>
</ol>
<p> <br><br></p>
<h3 id="HashMap的equals方法和hashCode方法重写"><a href="#HashMap的equals方法和hashCode方法重写" class="headerlink" title="HashMap的equals方法和hashCode方法重写"></a>HashMap的equals方法和hashCode方法重写</h3><ol>
<li><p>向Map集合中存以及取，都是先调用key的hashCode方法，然后再调用equals方法！</p>
<p>equals方法有可能调用，也有可能不调用</p>
<p>比如put(k,v):k.hashCode()方法返回哈希值，哈希值经过哈希算法转换成下标，数组下标位置如果是null，equals不需要执行，get(k)方法同理</p>
</li>
<li><p>注意：如果一个类的equals方法重写了，那么hashCode()方法必须重写。</p>
<p>并且equals方法返回如果是true，HashCode()方法返回的值必须一样。</p>
<ul>
<li>equals方法返回true表示两个对象相同，在同一个单向链表上比较，那么对于同一个单向链表的节点来说，他们的哈希值是相同的，所以hashCode()方法返回值也应该相同</li>
</ul>
</li>
<li><p>hashCode()方法和equals()方法不用研究了，直接使用IDEA工具生成，不过这两个方法需要同时生成</p>
</li>
<li><p>对于哈希表数据结构来说：</p>
<p>如果o1和o2的值先沟通，一定是放在同一个单向链表上。</p>
<p>当然如果o1和o2的hash值不同，但由于哈希算法，执行结束之后转换的数组下标可能相同，此时会发生“哈希碰撞”</p>
</li>
<li><p>终极结论：放在HashMap集合key部分，以及方法HashSet集合中的元素，需要同时重写hashCode方法和equals方法。</p>
</li>
</ol>
<p> <br><br> <br><br></p>
<h2 id="Properties类"><a href="#Properties类" class="headerlink" title="Properties类"></a>Properties类</h2><ul>
<li><p>目前只需要掌握Properties属性类对象的相关方法即可。</p>
</li>
<li><p>Properties是一个Map集合，继承Hashtable，Properties的key和value都是String类型</p>
</li>
<li><p>Properties被称为属性类对象</p>
</li>
<li><p>Properties是线程安全的</p>
</li>
<li><p>需要掌握Properties的两个方法，一个存一个取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SelfTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个Properties对象</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">//存</span></span><br><span class="line">        pro.setProperty(<span class="string">&quot;zd&quot;</span>,<span class="string">&quot;nb&quot;</span>);</span><br><span class="line">        pro.setProperty(<span class="string">&quot;xjb&quot;</span>,<span class="string">&quot;sb&quot;</span>);</span><br><span class="line">        <span class="comment">//通过key获取value</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">zd</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;zd&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">xjb</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;xjb&quot;</span>);</span><br><span class="line">        System.out.println(zd);</span><br><span class="line">        System.out.println(xjb);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p> <br><br> <br><br></p>
<h2 id="TreeSet和TreeMap"><a href="#TreeSet和TreeMap" class="headerlink" title="TreeSet和TreeMap"></a>TreeSet和TreeMap</h2><ol>
<li><p>TreeSet集合底层实际上是一个TreeMap</p>
</li>
<li><p>TreeMap集合底层是一个二叉树</p>
</li>
<li><p>放在TreeSet集合中的元素，等同于放到TreeMap集合key部分了</p>
</li>
<li><p>TreeSet集合中的元素：无序不可重复，但是可以按照元素的大小顺序自动排序（升序）。</p>
<p>称为：可排序集合</p>
</li>
<li><p>TreeSet无法对自定义类型排序</p>
<ul>
<li><p>放在TreeSet集合中的元素需要实现java.lang.Comparable接口</p>
</li>
<li><p>并且实现compareTo方法，equals可以不写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Customer&gt;&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Customer c)</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>怎么写比较规则</p>
<p>compareTo方法的返回值很重要：</p>
<p>返回0表示相同，value会覆盖</p>
<p>返回&gt;0，会继续在右子树上找，</p>
<p>返回&lt;0，会继续在左子树上找。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(vip v)</span>&#123;</span><br><span class="line">    <span class="type">int</span> (<span class="built_in">this</span>.age==v.age&#123;</span><br><span class="line">     <span class="comment">//年龄相同时按照名字排序</span></span><br><span class="line">     <span class="comment">//姓名是String类型，可以直接比。调用compareTo来完成比较</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name.compareTo(v.name);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age - v.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现比较器接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SelfTest;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Tree集合中元素课排序的第二种方式：使用比较器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建Tree集合的时候，需要使用这个比较器</span></span><br><span class="line">        <span class="comment">//通过构造方法传递一个比较器进去</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//给构造方法传递一个比较器</span></span><br><span class="line">        TreeSet&lt;WuGui&gt; wuGuis = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">WuGuiComparator</span>());</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        wuGuis.add(<span class="keyword">new</span> <span class="title class_">WuGui</span>(<span class="number">1000</span>));</span><br><span class="line">        wuGuis.add(<span class="keyword">new</span> <span class="title class_">WuGui</span>(<span class="number">800</span>));</span><br><span class="line">        wuGuis.add(<span class="keyword">new</span> <span class="title class_">WuGui</span>(<span class="number">810</span>));</span><br><span class="line">        <span class="keyword">for</span>(WuGui wuGui:wuGuis)&#123;</span><br><span class="line">            System.out.println(wuGui);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WuGui</span>&#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WuGui</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WuGui</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;WuGui&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//单独在这里编写一个比较器</span></span><br><span class="line"><span class="comment">//比较器实现java.util.Comparator接口。（Comparable是java.lang包下的  。Comparator是java1。util包下的。Comparable是第一种方式）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WuGuiComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;WuGui&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span> <span class="params">(WuGui o1,WuGui o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.age-o2.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><pre><code class="language-java">/*

使用匿名内部类的方式，作用和上面一样

*/
package SelfTest;

import java.util.Comparator;
import java.util.TreeSet;

//Tree集合中元素课排序的第二种方式：使用比较器
public class TreeMapTest &#123;
    public static void main(String[] args) &#123;
        //创建Tree集合的时候，需要使用这个比较器
        //通过构造方法传递一个比较器进去

        //给构造方法传递一个比较器,匿名内部类
        TreeSet&lt;WuGui&gt; wuGuis = new TreeSet&lt;&gt;(new Comparator&lt;WuGui&gt;() &#123;
            @Override
            public int compare(WuGui o1, WuGui o2) &#123;
                return o1.age-o2.age;
            &#125;
        &#125;);


        wuGuis.add(new WuGui(1000));
        wuGuis.add(new WuGui(800));
        wuGuis.add(new WuGui(810));
        for(WuGui wuGui:wuGuis)&#123;
            System.out.println(wuGui);
        &#125;
    &#125;
&#125;
class WuGui&#123;
    int age;

    public WuGui() &#123;
    &#125;

    public WuGui(int age)&#123;
        this.age=age;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;WuGui&#123;&quot; +
                &quot;age=&quot; + age +
                &#39;&#125;&#39;;
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">6. 最终结论：放TreeSet或者TreeMap集合key部分的元素要想做到排序，包括以下两种方式：</span><br><span class="line"></span><br><span class="line">   1. 放在集合中的元素实现java.lang.Comparable接口</span><br><span class="line">   2. 在构造TreeSet或者TreeMap集合的时候给它传一个比较器对象</span><br><span class="line"></span><br><span class="line">7. Comparable和Comparator怎么选择呢？</span><br><span class="line"></span><br><span class="line">   - 当比较规则不会发生改表的时候。或者说比较规则只有一个的时候，建议实现Comparable接口</span><br><span class="line"></span><br><span class="line">   - 如果比较规则有多个，并且是需要多个比较规则之间频繁切换，建议使用Comparator接口</span><br><span class="line"></span><br><span class="line">     Comparator接口的设计符合OCP原则</span><br><span class="line"></span><br><span class="line"> &lt;br&gt;&lt;br&gt; &lt;br&gt;&lt;br&gt;</span><br><span class="line"></span><br><span class="line">## Collections工具类</span><br><span class="line"></span><br><span class="line">注意：java.util.Collection 集合接口；java.util.Collections集合工具类，方便集合的操作</span><br><span class="line"></span><br><span class="line"> &lt;br&gt;&lt;br&gt; &lt;br&gt;&lt;br&gt;</span><br><span class="line"></span><br><span class="line">## IO流，什么是IO?</span><br><span class="line"></span><br><span class="line">- I:input ; O:output</span><br><span class="line"></span><br><span class="line">- java IO流这块有四大家族：</span><br><span class="line"></span><br><span class="line">  四大家族首领：</span><br><span class="line"></span><br><span class="line">  java.io.InputStream 字节输入流</span><br><span class="line"></span><br><span class="line">  java.io.OutputStream 字节输出流</span><br><span class="line"></span><br><span class="line">  &lt;br&gt;</span><br><span class="line"></span><br><span class="line">  java.io.Reader 字符输入流</span><br><span class="line"></span><br><span class="line">  java.io.Writer 字符输出流</span><br><span class="line"></span><br><span class="line">  &lt;br&gt;</span><br><span class="line"></span><br><span class="line">  四大家族的首领都是抽象类。（abstract class）</span><br><span class="line"></span><br><span class="line">- **所有流**都实现了：java.io.Closeable接口，都是可关闭，都有close（）方法。</span><br><span class="line"></span><br><span class="line">  养成好习惯，用完流一定要关闭。</span><br><span class="line"></span><br><span class="line">- **所有的输出流**都实现了java.io.Flushable接口，都是可刷新的，都有flush()方法。养成好习惯，输出流在最终输出之后，一定要记得flush()刷新一下，表示将通道、管道当中剩余未输出的数据，强行输出玩（清空管道！）刷新的作用就是清空管道。</span><br><span class="line"></span><br><span class="line">  如果没有flush()可能会导致丢失数据</span><br><span class="line"></span><br><span class="line">- **注意：在java中只要“类名”以Stream结尾的都是字节流。以&quot;Reader/Writer&quot;结尾的都是字符流**	</span><br><span class="line"></span><br><span class="line">- java.io包下需要掌握的流有16个：</span><br><span class="line"></span><br><span class="line">  **文件专属**：</span><br><span class="line"></span><br><span class="line">  java.io.FileInputstream</span><br><span class="line"></span><br><span class="line">  java.io.FileOutputstream</span><br><span class="line"></span><br><span class="line">  java.io.FileReader</span><br><span class="line"></span><br><span class="line">  java.io.FileWriter</span><br><span class="line"></span><br><span class="line">  &lt;br&gt;</span><br><span class="line"></span><br><span class="line">  **转换流**：（将字节流转换成字符流）</span><br><span class="line"></span><br><span class="line">  java.io.InputStreamReader</span><br><span class="line"></span><br><span class="line">  java.io.OutputStreamWriter</span><br><span class="line"></span><br><span class="line">  &lt;br&gt;</span><br><span class="line"></span><br><span class="line">  **缓冲流专属**：</span><br><span class="line"></span><br><span class="line">  java.io.BufferedReader</span><br><span class="line"></span><br><span class="line">  java.io.BufferedWriter</span><br><span class="line"></span><br><span class="line">  java.io.BufferedInputStream</span><br><span class="line"></span><br><span class="line">  java.io.BufferedOutputStream</span><br><span class="line"></span><br><span class="line">  &lt;br&gt;</span><br><span class="line"></span><br><span class="line">  **数据流专属**：</span><br><span class="line"></span><br><span class="line">  java.io.DataInputStream</span><br><span class="line"></span><br><span class="line">  java.io.DataOutputStream</span><br><span class="line"></span><br><span class="line">  &lt;br&gt;</span><br><span class="line"></span><br><span class="line">  **标准输出流**：</span><br><span class="line"></span><br><span class="line">  java.io.PrintWriter</span><br><span class="line"></span><br><span class="line">  java.io.PrintStream</span><br><span class="line"></span><br><span class="line">  &lt;br&gt;</span><br><span class="line"></span><br><span class="line">  **对象专属流**：</span><br><span class="line"></span><br><span class="line">  java.io.ObjectInputStream 反序列化</span><br><span class="line"></span><br><span class="line">  java.io.ObjectOutputStream 序列化</span><br><span class="line"></span><br><span class="line"> &lt;br&gt;&lt;br&gt; &lt;br&gt;&lt;br&gt;  </span><br><span class="line"></span><br><span class="line">## 关于FileInputStream</span><br><span class="line"></span><br><span class="line">- 读取文件内容</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  package SelfTest;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  import java.io.FileInputStream;</span><br><span class="line">  import java.io.FileNotFoundException;</span><br><span class="line">  import java.io.IOException;</span><br><span class="line">  </span><br><span class="line">  public class FileInputStreamTest &#123;</span><br><span class="line">      public static void main(String[] args) &#123;</span><br><span class="line">          FileInputStream fis = null;</span><br><span class="line">          try&#123;</span><br><span class="line">              fis = new FileInputStream(&quot;F:\\idea\\IOstudy\\temp&quot;);</span><br><span class="line">              //准备一个byte数组</span><br><span class="line">              byte[] bytes = new byte[4];</span><br><span class="line">             /* while( true)&#123;</span><br><span class="line">                  int readCount = fis.read(bytes);</span><br><span class="line">                  if(readCount==-1) break;</span><br><span class="line">                  //把byte数组转换成字符串，读到多少个就转换成多少个</span><br><span class="line">                  System.out.print(new String(bytes,0,readCount));</span><br><span class="line">              &#125;*/</span><br><span class="line">              //对前一个方法的优化</span><br><span class="line">              int readCount = 0;</span><br><span class="line">              while( (readCount=fis.read(bytes))!=-1)&#123;</span><br><span class="line">                  System.out.println(new String(bytes,0,readCount));</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125; catch (IOException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125; finally &#123;</span><br><span class="line">              if (fis!=null);&#123;</span><br><span class="line">                  try&#123;</span><br><span class="line">                      fis.close();</span><br><span class="line">                  &#125;catch (IOException e)&#123;</span><br><span class="line">                      e.printStackTrace();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>IDEA的相对路径：相对路径一定是从当前的位置作为起点开始找！</p>
<p>IDEA默认的当前路径是哪里？ 工程Project的根就是IDEA的默认当前路径</p>
</li>
<li><p>FileInputStream类的其他常用方法：</p>
<p><code>int available()</code>  :返回流当中剩余的没有读到的字节数量</p>
<p><code>long skip(long n)</code> :跳过几个字节不读</p>
</li>
</ul>
<p> <br><br> <br><br></p>
<h2 id="关于FileOutputStream"><a href="#关于FileOutputStream" class="headerlink" title="关于FileOutputStream"></a>关于FileOutputStream</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SelfTest;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileOutputStreamTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//myfile文件不存在的时候会自动新建</span></span><br><span class="line">            <span class="comment">//这种方式谨慎使用，这个方式会将源文件清空，然后重新写入</span></span><br><span class="line">            fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;myfile&quot;</span>);</span><br><span class="line">            <span class="type">byte</span>[] bytes=&#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>&#125;;</span><br><span class="line">            <span class="comment">//将byte数组全部写出！</span></span><br><span class="line">            fos.write(bytes);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将byte数组的一部分写出！</span></span><br><span class="line">            fos.write(bytes,<span class="number">0</span>,<span class="number">2</span>);<span class="comment">//再写出ab</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//以追加的方式在文件末尾写入。不会清空源文件内容</span></span><br><span class="line">            fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;myfile&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">            fos.write(bytes,<span class="number">0</span>,<span class="number">2</span>);<span class="comment">//再写出ab</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;我是中国人！&quot;</span>;</span><br><span class="line">            <span class="type">byte</span> [] bt = str.getBytes();<span class="comment">//会将字符串转换成数组</span></span><br><span class="line">            fos.write(bt);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//写完之后，最后一定要刷新</span></span><br><span class="line">            fos.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(fos !=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>以追加的方式在文件末尾写入。不会清空源文件内容<br>       <code>fos = new FileOutputStream(&quot;myfile&quot;,true);</code></p>
</li>
<li><p>想要换行的话：</p>
<p><code>out.write(&quot;\n&quot;);</code></p>
</li>
</ul>
<p> <br><br> <br><br></p>
<h2 id="文件的复制"><a href="#文件的复制" class="headerlink" title="文件的复制"></a>文件的复制</h2><p>使用FileInputStream + FileOutputStream完成文件的拷贝。</p>
<p>拷贝的过程应该是一边读，一边写。</p>
<p>使用以上的字节流拷贝文件的时候，文件类型随意，万能的。什么样的文件都能拷贝。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SelfTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C:\\Users\\lcdzzz\\Videos\\Captures\\解决 java “错误：编码GBK 的不可映射字符” _ lcdzzz的博客 - Google Chrome 2021-01-21 15-50-05.mp4&quot;</span>);<span class="comment">//创建一个输入流对象</span></span><br><span class="line">            fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;E:\\解决 java “错误&quot;</span>);<span class="comment">//创建一个输出流对象</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//最核心的：一边读，一边写</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];<span class="comment">//1MB(一次最多拷贝1MB)</span></span><br><span class="line">            <span class="type">int</span> readCount=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((readCount= fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                fos.write(bytes,<span class="number">0</span>,readCount);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//刷新，输入流最后要刷新</span></span><br><span class="line">            fos.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//分开try,不要一起try</span></span><br><span class="line">            <span class="keyword">if</span>(fos!=<span class="literal">null</span>);&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fis!=<span class="literal">null</span>);&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p> <br><br> <br><br></p>
<h2 id="java-io-File类"><a href="#java-io-File类" class="headerlink" title="java.io.File类"></a>java.io.File类</h2><ol>
<li><p>File类和四大家族没有关系，所以File类不能完成文件的读和写</p>
</li>
<li><p>File对象代表什么？</p>
<p>文件和目录名的抽象表达形式。</p>
<p>C:\Drivers</p>
<p>C:\Drivers\Lan\Realtek\Readme.txt 也是File对象</p>
</li>
<li><p>需要掌握File类的常用方法</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SelfTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建一个File对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\zhoudianniubi.txt&quot;</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否出在！</span></span><br><span class="line">        System.out.println(f1.exists());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果文件不存在，则以文件的形式创建出来</span></span><br><span class="line">        <span class="keyword">if</span> (!f1.exists())&#123;</span><br><span class="line">            f1.createNewFile();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果文件不存在，则以目录的形式创建出来</span></span><br><span class="line">        <span class="keyword">if</span>(!f1.exists())&#123;</span><br><span class="line">            f1.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建多层目录</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:a/b/c/d&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!f2.exists())&#123;</span><br><span class="line">            <span class="comment">//以多重目录的形式新建、</span></span><br><span class="line">            f2.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SelfTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取文件、目录的父路径</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\javase\\homework\\HotelMgtSystem.png&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">parentpath</span> <span class="operator">=</span> f3.getParent();</span><br><span class="line">        System.out.println(parentpath);</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">parentFile</span> <span class="operator">=</span> f3.getParentFile();</span><br><span class="line">        System.out.println(<span class="string">&quot;获取绝对路径：&quot;</span> + parentFile.getAbsolutePath());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取文件名</span></span><br><span class="line">        System.out.println(<span class="string">&quot;文件名：&quot;</span>+ f3.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否是一目录</span></span><br><span class="line">        System.out.println(f3.isDirectory());<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否是一个文件</span></span><br><span class="line">        System.out.println(f3.isFile());<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取文件最后一次修改时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">haoMiao</span> <span class="operator">=</span> f3.lastModified();<span class="comment">//从1970年到现在的总毫秒数</span></span><br><span class="line">        <span class="comment">//将总毫秒数转换成日期？？？</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">time</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(haoMiao);</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm;ss SSS&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">strTime</span> <span class="operator">=</span> sdf.format(time);</span><br><span class="line">        System.out.println(strTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取文件大小</span></span><br><span class="line">        System.out.println(f3.length());<span class="comment">//单位是字节</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SelfTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">File中的listFile方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileTest03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//File [] listFiles()</span></span><br><span class="line">        <span class="comment">//获取当前目录下的所有子文件、子目录</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\javase\\homework&quot;</span>);</span><br><span class="line">        File [] files = f.listFiles();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//foreach</span></span><br><span class="line">        <span class="keyword">for</span> (File file:files</span><br><span class="line">             ) &#123;</span><br><span class="line">            System.out.println(file.getAbsoluteFile());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br><br><br><br></p>
<h3 id="关于序列化和反序列化"><a href="#关于序列化和反序列化" class="headerlink" title="关于序列化和反序列化"></a>关于序列化和反序列化</h3><ol>
<li><p>java.io.NotSerializablieException</p>
<p>Student对象不支持序列化</p>
</li>
<li><p>参与序列化和反序列化的对象，必须实现Serializable接口。</p>
</li>
<li><p>注意：通过源代码发现，Serializable接口只是一个标志接口</p>
<p>public interface Serializable{</p>
<p>}</p>
<p>这个接口当中什么代码都没有。</p>
<p>那么它起到什么作用呢？</p>
<p>  起到标识的作用，java虚拟机看到这个类实现了这个接口，可能会对这个类进行特殊待遇。</p>
<p>Serializable 这个标志接口是给java虚拟机参考的，java虚拟机看到这个接口后，会为该类自动生成一个序列化版本号。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">序列化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> SelfTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectOutputStreamTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建java对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1111</span>,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;students&quot;</span>));</span><br><span class="line">        <span class="comment">//序列化对象</span></span><br><span class="line">        oos.writeObject(s);</span><br><span class="line">        <span class="comment">//刷新</span></span><br><span class="line">        oos.flush();</span><br><span class="line">        <span class="comment">//关闭</span></span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> no, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNo</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">反序列化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> SelfTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectInputStreamTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;students&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始反序列化，读</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            obj = ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//反序列化回来是一个学生对象，所以可以调用学生对象的toString方法</span></span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ois.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br><br></p>
<h3 id="序列化多个对象（序列化集合）并反序列化"><a href="#序列化多个对象（序列化集合）并反序列化" class="headerlink" title="序列化多个对象（序列化集合）并反序列化"></a>序列化多个对象（序列化集合）并反序列化</h3><p>注意：存多个对象必须用List集合，直接存的话会报错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SelfTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> exception.homework.UserService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectOutputStream02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        List&lt;User&gt; userList= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        userList.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>,<span class="string">&quot;zs&quot;</span>));</span><br><span class="line">        userList.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2</span>,<span class="string">&quot;ls&quot;</span>));</span><br><span class="line">        userList.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">3</span>,<span class="string">&quot;ww&quot;</span>));</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;Users&quot;</span>));</span><br><span class="line">        oos.writeObject(userList);</span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> no, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;user&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SelfTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectInputStream02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;users&quot;</span>));</span><br><span class="line">        List&lt;User&gt; userList =(List&lt;User&gt;)ois.readObject();</span><br><span class="line">        <span class="keyword">for</span> (Object user:userList</span><br><span class="line">             ) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<h3 id="transient关键字表示有力的，不参与序列化"><a href="#transient关键字表示有力的，不参与序列化" class="headerlink" title="transient关键字表示有力的，不参与序列化"></a>transient关键字表示有力的，不参与序列化</h3><p><code>private transient String name</code>  &#x2F;&#x2F;name不参与序列化操作</p>
<p>反序列化以后，name&#x3D;null</p>
<br>
<br>
<br>
<br>

<h2 id="IO-Properties的联合应用"><a href="#IO-Properties的联合应用" class="headerlink" title="IO+Properties的联合应用"></a>IO+Properties的联合应用</h2><p>非常好的一个设计理念：</p>
<ul>
<li><p>以后经常改变的数据，可以单独写到一个文件中，使用程序动态获取。</p>
<p>将来只需要修改这个文件的内容，java代码不需要改动，不需要重新编译，服务器也不需要重启，就可以拿到动态的信息。</p>
</li>
<li><p>类似于以上机制的这种文件被称为配置文件。</p>
<p>并且当配置文件的内容格式是：</p>
<p>key1&#x3D;value</p>
<p>key2&#x3D;value<br>的时候，我们把这种配置文件叫做属性配置文件</p>
</li>
<li><p>java规范中要求，属性配置文件建议以.properties结尾，但这不是必须的。</p>
<p>这种以.properties结尾的文件在java中被称为：配置文件</p>
<p>其中Properties是专门存放属性配置文件内容的一个类</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SelfTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IoPropertiesTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        properties是一个Map集合，key和value都是String类型</span></span><br><span class="line"><span class="comment">        香江userinfo文件中的数据加载到Propertie对象当中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//新建一个输入流对象</span></span><br><span class="line">        FileReader reader= <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//新建一个Map集合</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">//调用Properties对象的lode方法将文件中的数据加载到Mpa集合中</span></span><br><span class="line">        pro.load(reader);</span><br><span class="line">        <span class="comment">//通过key来获取</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br><br><br><br></p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ol>
<li><p>进程是一个应用程序，软件</p>
<p>线程是一个进程中的执行场景、执行单元</p>
<p>一个进程可以启动多个线程</p>
</li>
<li><p>进程A和进程B的内容独立不共享</p>
</li>
<li><p>线程A和线程B，堆内存和方法区内存共享，但是栈内存独立，一个线程一个栈</p>
</li>
<li><p>java中有多线程机制，目的就是为了提高程序的处理效率</p>
</li>
<li><p>使用多线程之后，main方法结束，程序有可能不会结束，main方法结束之时主线程结束了，主栈空了，其他的栈（线程）可能还在压栈弹栈。</p>
</li>
<li><p>关于线程对象的声明周期：</p>
<p>新建，就绪。运行，阻塞，死亡状态</p>
</li>
</ol>
<h3 id="实现线程的两种方式"><a href="#实现线程的两种方式" class="headerlink" title="实现线程的两种方式"></a>实现线程的两种方式</h3><ul>
<li><p>第一种</p>
<p>用类继承Thread</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SelfTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//这里是main方法，这里的代码属于主线程，在主栈中运行</span></span><br><span class="line">        <span class="comment">//新建一个分支线程对象</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        myThread.start();<span class="comment">//start()方法的作用是：启动一个分支线程，在JVM中开辟一个新的栈空间，这段代码任务完成后，瞬间结束了</span></span><br><span class="line">        <span class="comment">//接下来的代码还是运行在主线程中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">1000</span> ; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">1000</span> ; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;支线程&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>第二种</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SelfTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        创建一个可运行的对象</span></span><br><span class="line"><span class="comment">        MyRunnable r = new MyRunnable();</span></span><br><span class="line"><span class="comment">        将可运行的对象封装成一个线程对象</span></span><br><span class="line"><span class="comment">        Thread t = new Thread(r);</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">1000</span> ; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">1000</span> ; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;支线程&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="获取线程对象的名字"><a href="#获取线程对象的名字" class="headerlink" title="获取线程对象的名字"></a>获取线程对象的名字</h3><ol>
<li><p>怎么获取<strong>当前线程</strong>对象</p>
<p><code>Thread t = Thread.currentThread();</code></p>
</li>
<li><p>获取线程对象的名字</p>
<p><code>String name=线程对象.getName();</code> </p>
<p>主线程名字就叫main</p>
</li>
<li><p>修改线程对象的名字</p>
<p>线程对象.setName(“线程名字”)</p>
</li>
<li><p>当前没有设置名字的话，默认Thread-0，Thread-1，Thread-2</p>
</li>
</ol>
<p><br><br><br><br></p>
<h2 id="关于线程的sleep方法："><a href="#关于线程的sleep方法：" class="headerlink" title="关于线程的sleep方法："></a>关于线程的sleep方法：</h2><p>ststic void sleep(long millis)</p>
<ol>
<li><p>静态方法：Thread.sllep(1000)</p>
</li>
<li><p>参数是毫秒</p>
</li>
<li><p>作用：让当前线程进入休眠，进入“阻塞状态”，放弃占有CPU时间片，让给其他线程使用（出现在哪，就让谁睡）。</p>
<p>注意！<strong>，sleep是静态方法，sleep方法，出现在哪个线程，就 休眠，和哪个线程对象调用它没有关系！</strong></p>
</li>
<li><p>用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SelfTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//让当前线程进入休眠，睡眠5秒</span></span><br><span class="line">        <span class="comment">//当前线程是主线程！！！</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5</span>*<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5秒之后执行以下代码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>间隔某段特定的时间去执行某段特定的代码，每隔多久执行一次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SelfTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--&gt;&quot;</span>+i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="终断睡眠"><a href="#终断睡眠" class="headerlink" title="终断睡眠"></a>终断睡眠</h3><p>t.interrupt;&#x2F;&#x2F;t是线程的名字</p>
<p>这种终端睡眠的方式依靠了java的异常的处理机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SelfTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest08</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable2</span>());<span class="comment">//将可运行对象封装成一个线程对象</span></span><br><span class="line">        t.start();</span><br><span class="line">        t.setName(<span class="string">&quot;t&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">5</span>*<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         这种终端睡眠的方式依靠了java的异常的处理机制</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        t.interrupt();<span class="comment">//干扰，一盆冷水过去！给爷醒！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyRunnable2</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&gt;begin&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>*<span class="number">365</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;线程被唤醒！终止睡眠！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="java中怎么合理终止一个线程的执行"><a href="#java中怎么合理终止一个线程的执行" class="headerlink" title="java中怎么合理终止一个线程的执行"></a>java中怎么合理终止一个线程的执行</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SelfTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest10</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyRunable4</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunable4</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">        t.setName(<span class="string">&quot;t&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="comment">//模拟五秒</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终止线程</span></span><br><span class="line">        r.run=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunable4</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//打一个布尔标记</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">run</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (run) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br><br><br><br></p>
<h2 id="怎么解决线程的安全问题呢？"><a href="#怎么解决线程的安全问题呢？" class="headerlink" title="怎么解决线程的安全问题呢？"></a>怎么解决线程的安全问题呢？</h2><p>当多线程并发的环境下，有共享数据，并且这个数据还会被修改，此时就存在线程安全问题，怎么解决这个问题？</p>
<ul>
<li><p>线程排队执行。（不能并发）</p>
<p>用排队执行解决线程安全问题。</p>
<p>这种机制被称为：线程同步机制</p>
</li>
<li><p>专业术语叫做：线程同步，实际上就是线程不能并发了，线程必须排队执行</p>
</li>
<li><p>怎么解决线程安全问题？</p>
<p>使用“线程同步机制”</p>
</li>
<li><p>线程同步就是线程排队</p>
</li>
</ul>
<p>说道线程同步，设计两个专业术语</p>
<ul>
<li>异步编程模型：并发</li>
<li>同步编程模型：排队</li>
</ul>
<p><br><br></p>
<h3 id="java中有三大变量"><a href="#java中有三大变量" class="headerlink" title="java中有三大变量"></a>java中有三大变量</h3><ul>
<li><p>实例变量：在堆中</p>
</li>
<li><p>静态变量：在方法去中</p>
</li>
<li><p>局部变量：在栈中</p>
</li>
<li><p>以上三大变量中：局部变量永远都不会存在线程安全问题。因为局部变量不共享</p>
</li>
<li><p>实例变量在堆中，堆只有一个</p>
<p>静态变量在方法区中，方法去只有一个。</p>
<p>堆和方法区都是多线程共享的，所以可能存在线程安全问题。</p>
</li>
</ul>
<p><br><br></p>
<h3 id="在开发中怎么解决线程安全问题？"><a href="#在开发中怎么解决线程安全问题？" class="headerlink" title="在开发中怎么解决线程安全问题？"></a>在开发中怎么解决线程安全问题？</h3><ul>
<li><p>是上来就选择线程同步吗？</p>
<p>不是，synchronized会让程序的执行效率降低</p>
</li>
<li><p>尽量使用局部变量代替“实例变量和静态变量”</p>
</li>
<li><p>如果必须是实例变量，那么可以考虑创建多个对象，这样实例变量的内存就不共享了。（一个线程对应一个对象）</p>
</li>
<li><p>如果不能使用局部变量，对象也不能创建多个，这个时候就之后能选择synchronized了。线程同步机制。</p>
</li>
</ul>
<p><br><br></p>
<h3 id="synchronized有三种用法："><a href="#synchronized有三种用法：" class="headerlink" title="synchronized有三种用法："></a>synchronized有三种用法：</h3><ol>
<li><p>同步代码块：灵活</p>
<p>synchronized(线程共享对象){</p>
<p>同步代码块</p>
<p>}</p>
</li>
<li><p>在实例方法上使用synchronized</p>
<p><code>public synchronized void withdraw(double money)</code></p>
<p>表示共享对象一定是this</p>
</li>
<li><p>在静态方法上使用synchronized</p>
<p><code>class MyClass&#123;</code></p>
<p><code>public synchronized static void doSome()&#123;</code></p>
<p><code>&#125;</code></p>
<p><code>&#125;</code></p>
<p>表示找类锁</p>
<p>类锁只有一把</p>
<p>就算创建了100个对象，那么类锁也只有一把</p>
</li>
</ol>
<p><br><br><br><br></p>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><ol>
<li><p>java语言中线程分为两大类：</p>
<p>一类是：用户线程</p>
<p>一类是：守护线程（后台线程）</p>
<p>其中具有代表性的就是：垃圾回收线程（守护线程）。</p>
<ul>
<li><p>守护线程的特点：</p>
<p>一般守护线程就是一个死循环，所有的用户线程只要结束，守护线程自动结束。</p>
<p>注意：主线程main就是一个用户线程</p>
</li>
<li><p>守护线程用在什么地方呢？</p>
<p>每天00：00的时候系统数据自动备份，这个需要使用定时器，并且我们可以将定时器设置为守护线程。一直在那里看着，没到00:00的时候就备份一次。所有的用户线程如果结束了，守护线程自动退出，没有必要进行数据备份了。</p>
</li>
<li><p>用法：在启动线程之前，将线程设置为守护线程</p>
<p><code>t。setDaemon(true)</code></p>
<p><code>t.start</code></p>
</li>
</ul>
<p><br><br><br><br></p>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>定时器的作用：</p>
<p>间隔特定的时间，执行特定的程序。</p>
<p>每周要进行银行的总账操作。</p>
<p>每天要进行数据的备份操作。</p>
<p>在实际的开发中，每隔多久执行一段特定的程序，这种需求很常见，那么在java中其实可以采用多种方式实现</p>
</li>
</ol>
<ul>
<li><p>可以使用sleep方法，睡眠设置睡眠时间，每到这个时间点醒来执行任务，这种方式是最原始的。定时器（比较low）</p>
<ul>
<li>在java的类库中已经写好了一个定时器：java.util.Timer,可以直接哪来用。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">package</span> SelfTest;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">import</span> java.text.ParseException;</span><br><span class="line">   <span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line">   <span class="keyword">import</span> java.util.Date;</span><br><span class="line">   <span class="keyword">import</span> java.util.Timer;</span><br><span class="line">   <span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   使用定时器定时任务</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeTest</span> &#123;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">           <span class="comment">//创建定时器对象</span></span><br><span class="line">           <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">           <span class="comment">//Timer timer = new Timer(true); //守护线程的方法</span></span><br><span class="line">   </span><br><span class="line">           <span class="comment">//指定定时任务</span></span><br><span class="line">           <span class="comment">//timeer.schedule(定时任务，第一次执行任务，间隔多久执行一次）</span></span><br><span class="line">           <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">           <span class="type">Date</span> <span class="variable">firstTime</span> <span class="operator">=</span> sdf.parse(<span class="string">&quot;2021-03-04 14:39:50&quot;</span>);</span><br><span class="line">           timer.schedule(<span class="keyword">new</span> <span class="title class_">LogTimerTask</span>(),firstTime,<span class="number">1000</span>*<span class="number">10</span>);</span><br><span class="line">   </span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//编写一个定时任务类</span></span><br><span class="line">   <span class="comment">//假设这是一个记录日志的定时任务</span></span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">LogTimerTask</span> <span class="keyword">extends</span> <span class="title class_">TimerTask</span>&#123;</span><br><span class="line">   </span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="comment">//编写你需要执行的任务就行了</span></span><br><span class="line">           <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">           <span class="type">String</span> <span class="variable">strTime</span> <span class="operator">=</span> sdf.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">           System.out.println(strTime+<span class="string">&quot;:成功完成了一次数据备份&quot;</span>);</span><br><span class="line">   </span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><br><br><br><br></p>
<h2 id="实现线程的第三种方法，实现Callable接口。（JDK8新特性。）"><a href="#实现线程的第三种方法，实现Callable接口。（JDK8新特性。）" class="headerlink" title="实现线程的第三种方法，实现Callable接口。（JDK8新特性。）"></a>实现线程的第三种方法，实现Callable接口。（JDK8新特性。）</h2><p>这种方式实现的线程可以获取线程的返回值。</p>
<p>之前讲解的那两种方式是无法获取线程返回值的，因为run方法返回void</p>
<p>思考：系统委派一个线程去执行一个任务，该线程执行完任务呢之后，可能会有一个执行结果，我们怎么能拿到这个执行结果呢？</p>
<p>​	使用第三种方法：实现Callable接口。</p>
<ul>
<li>优点：可以获取线程的执行结果</li>
<li>缺点：效率比较低，在获取t线程的执行结果的时候，当前线程受阻塞，效率较低</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SelfTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jdk.swing.interop.SwingInterOpUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">实现线程的第三种方式</span></span><br><span class="line"><span class="comment">实现Callable接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest15</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">//第一步：创建一个“未来任务对象“对象。</span></span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(<span class="keyword">new</span> <span class="title class_">Callable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;<span class="comment">//call()方法就相当于run方法，只不过这个方法有返回值</span></span><br><span class="line">                System.out.println(<span class="string">&quot;call method begin&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>*<span class="number">2</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;call method end!&quot;</span>);</span><br><span class="line">                <span class="type">int</span> a= <span class="number">100</span>;</span><br><span class="line">                <span class="type">int</span> b= <span class="number">200</span>;</span><br><span class="line">                <span class="keyword">return</span>  a+b;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        t.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这里是main方法，这里在主线当众。</span></span><br><span class="line">        <span class="comment">//在主线程中，怎么获取t线程的返回结果？</span></span><br><span class="line"><span class="comment">//        Object obj = new Object();</span></span><br><span class="line">         <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> task.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程执行结果：&quot;</span>+obj);</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br><br><br><br></p>
<h2 id="关于Object类中的wait和notify方法（生产者和消费者模式！）"><a href="#关于Object类中的wait和notify方法（生产者和消费者模式！）" class="headerlink" title="关于Object类中的wait和notify方法（生产者和消费者模式！）"></a>关于Object类中的wait和notify方法（生产者和消费者模式！）</h2><ol>
<li><p>wait和notifu方法不是线程对象的方法，是java中任何一个对象都有的方法，因为这两个方式是Object类中自带的</p>
</li>
<li><p>wait()方法作用？</p>
<p><code>Object  o = new Object();</code></p>
<p><code>o.wait();</code></p>
<p>表示：让正在o对象上活动的线程进入等待状态，无期限等待，</p>
<p>直到被唤醒位置。</p>
<p>o.wait()方法的调用，会让“当前线程（正在o对象上活动的线程）”进入等待状态</p>
</li>
<li><p>notify()方法作用？</p>
<p><code>Object 0 = new Object();</code></p>
<p><code>o.notify();</code></p>
<p>表示：欢迎正在o对象上等待的线程。</p>
<p>还有一个notifyAll()方法：这个方法是唤醒o对象上处于等待的所有线程。</p>
</li>
<li><p>生产者和消费者程序实现！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SelfTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest16</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个仓库对象，共享的</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">//创建两个线程对象</span></span><br><span class="line">        <span class="comment">//生产者线程</span></span><br><span class="line">        Thread t1= <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(list));</span><br><span class="line">        <span class="comment">//消费者线程</span></span><br><span class="line">        Thread t2= <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(list));</span><br><span class="line">        t1.setName(<span class="string">&quot;生产者线程&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;消费者线程&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生产线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(List list)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//一直生产(用死循环模拟生产）</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//给仓库对象list枷锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (list)&#123;</span><br><span class="line">                <span class="keyword">if</span>(list.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//当前线程进入等待状态，并且释放Producer先前占有list集合的锁</span></span><br><span class="line">                        list.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//程序能够执行到这里说明仓库是空的，可以生产</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">                list.add(obj);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&gt;&quot;</span>+obj);</span><br><span class="line">                <span class="comment">//唤醒消费者进行消费</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>*<span class="number">2</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                list.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(List list)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//一直消费</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//给仓库对象list枷锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (list)&#123;</span><br><span class="line">                <span class="keyword">if</span>(list.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//当前线程进入等待状态，并且释放list集合的锁</span></span><br><span class="line">                        list.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//程序能够执行到次数说明仓库中有数据，进行消费</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> list.remove(<span class="number">0</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&gt;&quot;</span>+obj);</span><br><span class="line">                <span class="comment">//唤醒生产者生产</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>*<span class="number">2</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                list.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><br><br><br><br></p>
<h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><ol>
<li><p>反射机制有什么用？</p>
<p>通过java语言中的反射机制可以操作字节码文件。</p>
<p>有点类似于黑客。（可以读和修改字节码文件。）</p>
<p>通过反射机制可以操作代码片段。（class文件。）</p>
</li>
<li><p>反射机制的相关类在哪个包下？</p>
<p><code>java.lang.reflect.*;</code></p>
</li>
<li><p>反射机制相关的重要的类有哪些？</p>
<p>java.lang.class代表整个字节码，代表一个类型，代表整个类</p>
<p>java.lang.reflect.Method代表字节码中的方法字节码，代表类中的方法</p>
<p>java.lang.class.Constructor代表字节码中的构造方法字节码，代表类中的构造方法</p>
<p>java.lang.class.Field代表字节码中的属性字节码， 代表类中的属性</p>
</li>
</ol>
<h3 id="要操作一个类的字节码，需要首先获取到这个类的字节码，怎么获取java-lang-Class实例？"><a href="#要操作一个类的字节码，需要首先获取到这个类的字节码，怎么获取java-lang-Class实例？" class="headerlink" title="要操作一个类的字节码，需要首先获取到这个类的字节码，怎么获取java.lang.Class实例？"></a>要操作一个类的字节码，需要首先获取到这个类的字节码，怎么获取java.lang.Class实例？</h3><ol>
<li><p>Class c &#x3D; Class.forName(“完整类名带包名”)；</p>
<p>Class.forName()</p>
<ol>
<li>静态方法</li>
<li>方法的参数是一个字符串</li>
<li>字符串需要的是一个完整的类名</li>
<li>完整类名必须带有包名。java.lang包也不能省略</li>
</ol>
</li>
<li><p>Class c &#x3D; 对象.getClass();</p>
<p>java中任何一个对象都有一个方法：getClass()</p>
</li>
<li><p>Class c &#x3D; 任何类型.class</p>
<p>java语言中任何一种类型，包括基本数据类型，它都有.class属性</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ReflectTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c1 =Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line">            c2 = Class.forName(<span class="string">&quot;java.util.Date&quot;</span>);</span><br><span class="line">            System.out.println(c1);<span class="comment">//class java.lang.String</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//java中任何一个类对象都有一个方法：getClass()</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">x</span> <span class="operator">=</span> s.getClass();</span><br><span class="line">        System.out.println(x);<span class="comment">//class java.lang.String</span></span><br><span class="line">        System.out.println(c1==x);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Date</span> <span class="variable">time</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">y</span> <span class="operator">=</span> time.getClass();</span><br><span class="line">        System.out.println(c2==y);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> String.class;</span><br><span class="line">        System.out.println(c);<span class="comment">//class java.lang.String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br><br></p>
<h3 id="获取到Class，能干什么？"><a href="#获取到Class，能干什么？" class="headerlink" title="获取到Class，能干什么？"></a>获取到Class，能干什么？</h3><p><strong>获取了Class之后，可以调用无参数构造方法来实例化对象</strong></p>
<p>一定要注意：</p>
<p>newInstance()底层调用的是该类型的无参数构造方法。</p>
<p>如果没有这个无参数构造方法会出现异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ReflectTest;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取到Class。能干什么？</span></span><br><span class="line"><span class="comment">    通过Class的newInstacne()方法来实例化对象。</span></span><br><span class="line"><span class="comment">    注意：newInstance()方法内部实际上调用了无参构造方法，必须保证无参构造方法存在才可以</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//c代表的就是日期Date类型</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span>Class.forName(<span class="string">&quot;ReflectTest.User&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//newInstance() 这个方法会调用User这个类的午餐构造方法，完成对象的创建</span></span><br><span class="line">			<span class="comment">//实例化一个Date日期类型的对象</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> c.newInstance();</span><br><span class="line">            </span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br><br></p>
<h3 id="验证反射机制的灵活性"><a href="#验证反射机制的灵活性" class="headerlink" title="验证反射机制的灵活性"></a>验证反射机制的灵活性</h3><p>java代码写一遍，在不该表java源代码的基础上，可以做到不同对象的实例化。非常灵活（符合OCP开发原则，对扩展开放，对修改关闭）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ReflectTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//通过IO流读取classinfo.properties文件</span></span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;selfstudy\\src\\classinfo.proerties&quot;</span>);</span><br><span class="line">        <span class="comment">//创建属性类对象Map</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();<span class="comment">//key 和value都是String</span></span><br><span class="line">        <span class="comment">//加载</span></span><br><span class="line">        pro.load(reader);</span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        reader.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过key获取value</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">classsName</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">        System.out.println(classsName);</span><br><span class="line">        <span class="comment">//通过反射机制实例化</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span>Class.forName(classsName);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> c.newInstance();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下文件是classinfo.properties</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">className=java.util.Date</span><br><span class="line">className1= ReflectTest.User</span><br></pre></td></tr></table></figure>

<p><br><br></p>
<h3 id="研究一下：Class-foeName-发生了什么？"><a href="#研究一下：Class-foeName-发生了什么？" class="headerlink" title="研究一下：Class.foeName()发生了什么？"></a>研究一下：Class.foeName()发生了什么？</h3><p>记住，重点：<strong>如果你只是希望一个类的静态代码块执行，其他代码一律不执行。</strong></p>
<p>你可以使用Class.forName(“完整类名”);</p>
<p>这个方法的执行会导致类加载，类加载时，静态代码块执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ReflectTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;ReflectTest.MyClass&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ReflectTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyClass类的静态代码执行了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br><br><br><br></p>
<h2 id="研究一下文件路径的问题"><a href="#研究一下文件路径的问题" class="headerlink" title="研究一下文件路径的问题"></a>研究一下文件路径的问题</h2><p><code>FileReader reader = new FileReader(&quot;xxx/xxx&quot;)</code></p>
<ul>
<li>这个方式的路径缺点是：移植性差，在IDEA中默认的当前路径是project的根</li>
<li>这个代码假设离开了IDEA，换到了其他位置，可能当前路径就不是project的根了，这是这个路径就无效了</li>
</ul>
<hr>
<ul>
<li><p>接下来说一种比较通用的路径</p>
</li>
<li><p>注意：使用以下通用方式的前提是：这个文件必须在类路径下，换句话说就是放在src下面</p>
</li>
<li><p>什么是类路径下？就是在src下的都是类路径下。</p>
</li>
<li><p>src是类的根路径</p>
<p><code>Thread.currentThread().getContextClassLoader().getResource(&quot;    &quot;).getPath();</code></p>
</li>
<li><p>解释：</p>
<p>Threader.currentThread() 当前线程对象</p>
<p>getContextClassLoader() 是线程对象的方法，可以获取当前线程的类加载器对象。</p>
<p>getResource() 【获取资源】这是类加载器对象的方法，当前线程的类加载器默认从类的根路径下加载资源</p>
<p><code>String path =Thread.currentThread().getContextClassLoader().getResource(&quot;classinfo.properties&quot;).getPath(); </code></p>
<p><code>System.out.println(path);</code></p>
</li>
<li><p>以下实操、</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SelfTest;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IoPropertiesTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader().getResource(<span class="string">&quot;classinfo.properties&quot;</span>).getPath();</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(path);</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        pro.load(reader);</span><br><span class="line">        reader.close();</span><br><span class="line">        <span class="comment">//通过key获取value</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">        System.out.println(className);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用流的方式直接返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SelfTest;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IoPropertiesTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="comment">/* String path = Thread.currentThread().getContextClassLoader().getResource(&quot;classinfo.properties&quot;).getPath();</span></span><br><span class="line"><span class="comment">        FileReader reader = new FileReader(path);*/</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">reader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader()</span><br><span class="line">                .getResourceAsStream(<span class="string">&quot;classinfo.properties&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        pro.load(reader);</span><br><span class="line">        reader.close();</span><br><span class="line">        <span class="comment">//通过key获取value</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">        System.out.println(className);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用资源绑定器（最终！！！！）</p>
<p>java.util包下提供了一个资源绑定器，便于获取属性配置文件中的内容</p>
<p>使用以下这种方式的时候，属性配置文件xxx.properties必须放在类路径下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SelfTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ResourceBundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourceBundleTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//资源绑定器，只能绑定xxx.properties文件。并且这个文件必须在类路径下。文件的扩展名必须是properties</span></span><br><span class="line">        <span class="comment">//并且写路径的时候，路径后面扩展名不能写</span></span><br><span class="line">        <span class="type">ResourceBundle</span> <span class="variable">bundle</span> <span class="operator">=</span> ResourceBundle.getBundle(<span class="string">&quot;classinfo&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> bundle.getString(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">        System.out.println(className);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><br><br><br><br></p>
<h2 id="获取field（了解一下）"><a href="#获取field（了解一下）" class="headerlink" title="获取field（了解一下）"></a>获取field（了解一下）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ReflectTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取整个类</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">studentClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;ReflectTest.Student&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> studentClass.getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;完整类名 &quot;</span>+className);</span><br><span class="line">        <span class="type">String</span> <span class="variable">simpleName</span> <span class="operator">=</span> studentClass.getSimpleName();</span><br><span class="line">        System.out.println(<span class="string">&quot;简类名 &quot;</span>+simpleName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取类中所有的Field</span></span><br><span class="line">        Field[] fields=studentClass.getFields();</span><br><span class="line">        System.out.println(fields.length);<span class="comment">//1</span></span><br><span class="line">        <span class="comment">//取出这个Field</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> fields[<span class="number">0</span>];</span><br><span class="line">        System.out.println(f);<span class="comment">//public int ReflectTest.Student.no</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fieldName</span> <span class="operator">=</span> f.getName();</span><br><span class="line">        System.out.println(fieldName);<span class="comment">//no</span></span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有的Field</span></span><br><span class="line">        Field[] fs = studentClass.getDeclaredFields();</span><br><span class="line">        System.out.println(fs.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; fs.length ; i++) &#123;</span><br><span class="line">            System.out.println(fs[i].getName()+<span class="string">&quot;的类型是：&quot;</span>+fs[i].getType());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;以下第二种遍历，使用SimpleName和getType获取类型&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Field field:fs</span><br><span class="line">             ) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> field.getModifiers();<span class="comment">//返回修饰符的代号</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">modifierString</span> <span class="operator">=</span> Modifier.toString(i);<span class="comment">//将代号转换成字符串</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">fieldType</span> <span class="operator">=</span> field.getType();<span class="comment">//获取完整类型</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">simpleType</span> <span class="operator">=</span> fieldType.getSimpleName();<span class="comment">//获取类型的简化</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fName</span> <span class="operator">=</span> field.getName();<span class="comment">//字节名</span></span><br><span class="line">            System.out.println(modifierString+<span class="string">&quot; &quot;</span>+simpleType+<span class="string">&quot;---&gt;&quot;</span>+fName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">另一种拿到修饰符字符串的方法：Modifier.toString(studentClass.getModifiers())</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>运行后会返回</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">完整类名 ReflectTest.Student</span><br><span class="line">简类名 Student</span><br><span class="line">1</span><br><span class="line">public int ReflectTest.Student.no</span><br><span class="line">no</span><br><span class="line">---------------------------------------</span><br><span class="line">4</span><br><span class="line">no的类型是：int</span><br><span class="line">name的类型是：class java.lang.String</span><br><span class="line">age的类型是：int</span><br><span class="line">sex的类型是：boolean</span><br><span class="line">以下第二种遍历，使用SimpleName和getType获取类型</span><br><span class="line">public int---&gt;no</span><br><span class="line">private String---&gt;name</span><br><span class="line">protected int---&gt;age</span><br><span class="line"> boolean---&gt;sex</span><br></pre></td></tr></table></figure>

<p><br><br><br><br></p>
<h2 id="反编译Field（了解一下）"><a href="#反编译Field（了解一下）" class="headerlink" title="反编译Field（了解一下）"></a>反编译Field（了解一下）</h2><p>给我一个class文件，能够拿到java源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ReflectTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//创建这个是为了拼接字符串</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">studentClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;ReflectTest.Student&quot;</span>);</span><br><span class="line">        s.append(Modifier.toString(studentClass.getModifiers())+<span class="string">&quot;class&quot;</span>+studentClass.getSimpleName()+<span class="string">&quot;&#123;\n&quot;</span>);</span><br><span class="line">        Field[] fields = studentClass.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field:fields</span><br><span class="line">             ) &#123;</span><br><span class="line">            s.append(<span class="string">&quot;\t&quot;</span>);<span class="comment">//转义符：缩进</span></span><br><span class="line">            s.append(Modifier.toString(field.getModifiers()));</span><br><span class="line">            s.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            s.append(field.getType().getSimpleName());</span><br><span class="line">            s.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            s.append(field.getName());</span><br><span class="line">            s.append(<span class="string">&quot;;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s.append(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br><br><br><br></p>
<h2 id="通过反射机制访问对象属性"><a href="#通过反射机制访问对象属性" class="headerlink" title="通过反射机制访问对象属性"></a>通过反射机制访问对象属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ReflectTest;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//不使用反射机制，怎么去访问一个对象的属性呢？</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s.no=<span class="number">1111</span>;<span class="comment">//给属性赋值</span></span><br><span class="line">        System.out.println(s.no);<span class="comment">//读属性值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用反射机制，怎么去访问一个对象的属性</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">studentClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;ReflectTest.Student&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> studentClass.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取no属性（根据属性的名称来获取Field</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">noField</span> <span class="operator">=</span> studentClass.getDeclaredField(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">        <span class="comment">//给obj对象（Student对象）的no属性赋值</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        虽然使用了反射机制，但是三要素还是缺一不可：</span></span><br><span class="line"><span class="comment">            要素1.obj对象</span></span><br><span class="line"><span class="comment">            要素2：no属性</span></span><br><span class="line"><span class="comment">            要素3:2222值</span></span><br><span class="line"><span class="comment">        注意：反射机制虽然让复杂了，但是为了“灵活，是值得的。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        noField.set(obj,<span class="number">22222</span>);<span class="comment">//给obj对象的no属性赋值22222</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取属性的值</span></span><br><span class="line">        <span class="comment">//两个要素：获取obj对象no属性的值</span></span><br><span class="line">        System.out.println(noField.get(obj));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//可以反问私有属性吗？</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> studentClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打破封装（反射机制的特点：打破封装（反射机制的特点）</span></span><br><span class="line">        <span class="comment">//这样设置完后，在外部也可以反问private的</span></span><br><span class="line">        nameField.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给name属性配置</span></span><br><span class="line">        nameField.set(obj,<span class="string">&quot;jackson&quot;</span>);</span><br><span class="line">        <span class="comment">//获取name属性的值</span></span><br><span class="line">        System.out.println(nameField.get(obj));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br><br><br><br></p>
<h2 id="可变长度参数（掌握"><a href="#可变长度参数（掌握" class="headerlink" title="可变长度参数（掌握)"></a>可变长度参数（掌握)</h2><ul>
<li>int… args这就是可变长度参数</li>
<li>语法是：<code>类型... </code> 注意：一定是3个点</li>
</ul>
<ol>
<li>可变长度参数要求的参数个数是0~N</li>
<li>可变长度参数在参数列表中必须在最后一个位置上，而且可变长度参数只能有一个</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ReflectTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArgsTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        m();</span><br><span class="line">        m(<span class="number">10</span>);</span><br><span class="line">        m(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">        m2(<span class="number">100</span>);</span><br><span class="line">        m2(<span class="number">200</span>,<span class="string">&quot;abd&quot;</span>,<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">        m3(<span class="string">&quot;abd&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;wqeq&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String[] strs=&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//也可以传一个数组进去</span></span><br><span class="line">        m3(strs);</span><br><span class="line"></span><br><span class="line">        m3(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;你&quot;</span>,<span class="string">&quot;很&quot;</span>,<span class="string">&quot;牛&quot;</span>,<span class="string">&quot;蛙&quot;</span>&#125;);<span class="comment">//没必要</span></span><br><span class="line">        m3(<span class="string">&quot;你&quot;</span>,<span class="string">&quot;很&quot;</span>,<span class="string">&quot;牛&quot;</span>,<span class="string">&quot;蛙&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">(<span class="type">int</span>... args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m方法执行了！&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">(<span class="type">int</span> a,String ... args)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">(String...args)</span>&#123;</span><br><span class="line">        <span class="comment">//args有length属性，说明args是一个数组！</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;args.length ; i++) &#123;</span><br><span class="line">            System.out.println(args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br><br><br><br></p>
<h2 id="反射Method（了解内容）"><a href="#反射Method（了解内容）" class="headerlink" title="反射Method（了解内容）"></a>反射Method（了解内容）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ReflectTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest08</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//获取类</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">userServiesClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;ReflectTest.UserService&quot;</span>);</span><br><span class="line">        <span class="comment">//获取所有的Method</span></span><br><span class="line">        Method[] methods= userServiesClass.getDeclaredMethods();</span><br><span class="line"><span class="comment">//        System.out.println(methods.length);//2</span></span><br><span class="line">        <span class="keyword">for</span>(Method method:methods)&#123;</span><br><span class="line">            <span class="comment">//获取修饰符列表</span></span><br><span class="line">            System.out.println(Modifier.toString(method.getModifiers()));</span><br><span class="line">            <span class="comment">//获取方法的返回值类型</span></span><br><span class="line">            System.out.println(method.getReturnType().getSimpleName());</span><br><span class="line">            <span class="comment">//获取方法名</span></span><br><span class="line">            System.out.println(method.getName());</span><br><span class="line">            <span class="comment">//方法的参数列表（一个方法的参数可能会有多个</span></span><br><span class="line">            Class[] parameterTypes=method.getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span> (Class cla:parameterTypes</span><br><span class="line">                 ) &#123;</span><br><span class="line">                System.out.println(cla.getSimpleName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="反编译Method一个类的方法"><a href="#反编译Method一个类的方法" class="headerlink" title="反编译Method一个类的方法"></a>反编译Method一个类的方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ReflectTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest09</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">userServiceClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;ReflectTest.UserService&quot;</span>);</span><br><span class="line">        s.append(Modifier.toString(userServiceClass.getModifiers())+<span class="string">&quot; class &quot;</span>+userServiceClass.getSimpleName()+<span class="string">&quot;&#123;\n&quot;</span>);</span><br><span class="line">        Method[] methods=userServiceClass.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method:methods</span><br><span class="line">             ) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            s.append(Modifier.toString(method.getModifiers()));</span><br><span class="line">            s.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            s.append(method.getReturnType().getSimpleName());</span><br><span class="line">            s.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            s.append(method.getName());</span><br><span class="line">            s.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            Class[] parameterTypes = method.getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span> (Class parameterType:parameterTypes</span><br><span class="line">                 ) &#123;</span><br><span class="line">                s.append(parameterType.getSimpleName());</span><br><span class="line">                s.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            s.deleteCharAt(s.length()-<span class="number">1</span>);</span><br><span class="line">            s.append(<span class="string">&quot;)&#123;&#125;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        s.append(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br><br><br><br></p>
<h2 id="重点：通过反射机制怎么调用一个对象的方法"><a href="#重点：通过反射机制怎么调用一个对象的方法" class="headerlink" title="重点：通过反射机制怎么调用一个对象的方法* * * * *"></a>重点：通过反射机制怎么调用一个对象的方法* * * * *</h2><p>反射机制，让代码很具有通用性，可变化的内容都是写到配置文件当中，将来修改配置文件之后，创建的对象不一样了，调用的方法不同了，但是java代码必须要做任何改动，这就是反射机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ReflectTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest10</span> &#123;</span><br><span class="line">    <span class="comment">//使用反射机制来调用一个对象的方法怎么做？</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">userServiceClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;ReflectTest.UserService&quot;</span>);</span><br><span class="line">    <span class="comment">//创建对象</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> userServiceClass.newInstance();</span><br><span class="line">    <span class="comment">//获取Method</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">loginMethod</span> <span class="operator">=</span> userServiceClass.getDeclaredMethod(<span class="string">&quot;login&quot;</span>,String.class,String.class);</span><br><span class="line">        System.out.println(loginMethod);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用方法</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    要素分析：</span></span><br><span class="line"><span class="comment">    对象userService</span></span><br><span class="line"><span class="comment">    login方法名</span></span><br><span class="line"><span class="comment">    实参列表</span></span><br><span class="line"><span class="comment">    返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用方法有几个要素，也需要4要素</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">retvalue</span> <span class="operator">=</span> loginMethod.invoke(obj,<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        System.out.println(retvalue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><em>注：重点是ReflectTest07和10</em></p>
<p><br><br><br><br></p>
<h2 id="反编译一个类的Constructor构造方法"><a href="#反编译一个类的Constructor构造方法" class="headerlink" title="反编译一个类的Constructor构造方法"></a>反编译一个类的Constructor构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ReflectTest;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest11</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">vipClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;ReflectTest.Vip&quot;</span>);</span><br><span class="line"></span><br><span class="line">        s.append(Modifier.toString(vipClass.getModifiers()));<span class="comment">//public</span></span><br><span class="line">        s.append(<span class="string">&quot; class &quot;</span>);</span><br><span class="line">        s.append(vipClass.getSimpleName());<span class="comment">//vip</span></span><br><span class="line">        s.append(<span class="string">&quot;&#123;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拼接构造方法</span></span><br><span class="line">        Constructor[] constructors = vipClass.getDeclaredConstructors();<span class="comment">//获取所有构造方法</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(Constructor constructor:constructors)&#123;</span><br><span class="line">            s.append(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            s.append(Modifier.toString(constructor.getModifiers()));</span><br><span class="line">            s.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            s.append(vipClass.getSimpleName());</span><br><span class="line">            s.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            <span class="comment">//拼接参数</span></span><br><span class="line">            Class[] parameterTypes = constructor.getParameterTypes();<span class="comment">//获取所有参数类型</span></span><br><span class="line">            <span class="keyword">for</span>(Class parameterType:parameterTypes)&#123;</span><br><span class="line">                s.append(parameterType.getSimpleName());</span><br><span class="line">                s.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//删除最后下标位置上的字符</span></span><br><span class="line">            <span class="keyword">if</span>(parameterTypes.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                s.deleteCharAt(s.length()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            s.append(<span class="string">&quot;)&#123;&#125;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        s.append(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public ReflectTest.Vip(int)</span><br><span class="line">public ReflectTest.Vip(int,java.lang.String)</span><br><span class="line">public ReflectTest.Vip(int,java.lang.String,java.lang.String)</span><br><span class="line">public ReflectTest.Vip(int,java.lang.String,java.lang.String,boolean)</span><br><span class="line">public ReflectTest.Vip()</span><br><span class="line">public class Vip&#123;</span><br><span class="line">	public Vip(int)&#123;&#125;</span><br><span class="line">	public Vip(int,String)&#123;&#125;</span><br><span class="line">	public Vip(int,String,String)&#123;&#125;</span><br><span class="line">	public Vip(int,String,String,boolean)&#123;&#125;</span><br><span class="line">	public Vip()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><br><br><br><br></p>
<h2 id="通过反射机制new对象（比上一个例子重要一些）（但也不是重点）"><a href="#通过反射机制new对象（比上一个例子重要一些）（但也不是重点）" class="headerlink" title="通过反射机制new对象（比上一个例子重要一些）（但也不是重点）"></a>通过反射机制new对象（比上一个例子重要一些）（但也不是重点）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package ReflectTest;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.Modifier;</span><br><span class="line"></span><br><span class="line">public class ReflectTest11 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        StringBuilder s = new StringBuilder();</span><br><span class="line">        Class vipClass = Class.forName(&quot;ReflectTest.Vip&quot;);</span><br><span class="line"></span><br><span class="line">        s.append(Modifier.toString(vipClass.getModifiers()));//public</span><br><span class="line">        s.append(&quot; class &quot;);</span><br><span class="line">        s.append(vipClass.getSimpleName());//vip</span><br><span class="line">        s.append(&quot;&#123;\n&quot;);</span><br><span class="line"></span><br><span class="line">        //拼接构造方法</span><br><span class="line">        Constructor[] constructors = vipClass.getDeclaredConstructors();//获取所有构造方法</span><br><span class="line"></span><br><span class="line">        for(Constructor constructor:constructors)&#123;</span><br><span class="line">            s.append(&quot;\t&quot;);</span><br><span class="line">            s.append(Modifier.toString(constructor.getModifiers()));</span><br><span class="line">            s.append(&quot; &quot;);</span><br><span class="line">            s.append(vipClass.getSimpleName());</span><br><span class="line">            s.append(&quot;(&quot;);</span><br><span class="line">            //拼接参数</span><br><span class="line">            Class[] parameterTypes = constructor.getParameterTypes();//获取所有参数类型</span><br><span class="line">            for(Class parameterType:parameterTypes)&#123;</span><br><span class="line">                s.append(parameterType.getSimpleName());</span><br><span class="line">                s.append(&quot;,&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            //删除最后下标位置上的字符</span><br><span class="line">            if(parameterTypes.length&gt;0)&#123;</span><br><span class="line">                s.deleteCharAt(s.length()-1);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            s.append(&quot;)&#123;&#125;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        s.append(&quot;&#125;&quot;);</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><br><br><br><br></p>
<h2 id="获取父类和父接口"><a href="#获取父类和父接口" class="headerlink" title="获取父类和父接口"></a>获取父类和父接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ReflectTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest13</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//String 举例</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">stringClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取String的父类</span></span><br><span class="line">        Class superClass= stringClass.getSuperclass();</span><br><span class="line">        System.out.println(superClass.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取String类实现的所有接口（一个类可以实现多个接口）</span></span><br><span class="line">        Class[] interfaces = stringClass.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class in: interfaces</span><br><span class="line">             ) &#123;</span><br><span class="line">            System.out.println(in.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br><br><br><br></p>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><ul>
<li><p>又叫注释，英文单词是Annotation</p>
</li>
<li><p>注解Annotation是一种引用数据类型。编译之后也是生成xxx.class文件。</p>
</li>
<li><p>怎么自定义注解呢？语法格式：</p>
<p>[修饰符列表] @ interface 注解类型名{</p>
<p>}</p>
</li>
<li><p>注解怎么使用，用在什么地方？</p>
<ol>
<li><p>注解使用时的语法格式是：</p>
<p>@注解类型名</p>
</li>
<li><p>注解可以出现在类上，属性上，方法上，变量上….注解还可以出现在注解类型上。</p>
</li>
</ol>
</li>
<li><p>JDK中内置了有哪些注解呢？</p>
<p>java.lang包下的注释类型：</p>
<ul>
<li><p>Deprecated用@Deprecated 注释的程序元素，不鼓励程序员使用这样的元素，通常是因为它很危险或存在更好的选择。</p>
<p><u>说明该类&#x2F;方法以过时，为了把这个信息传达出去，比如<del>doOther</del></u>（掌握）</p>
</li>
<li><p>Override 表示一个方法声明打算重写超类中的另一个方法声明。（掌握）</p>
</li>
<li><p>SuppressWarnings 只是应该在注释元素（以及包含在该注释元素中的所有程序元素）中取消显示只是的编译器警告。（不用掌握）</p>
</li>
</ul>
<p><br><br></p>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><ul>
<li><p>什么是元注解？</p>
<p>用来“标注”注解类型的“注解”,称为元注解</p>
</li>
<li><p>常见的元注解有哪些？</p>
<p>Target</p>
<p>Retention</p>
</li>
<li><p>关于Target注解：</p>
<p>这个一个元注解，用来标注“注解类型”的“注解”</p>
<p>这个Target注解用来标注“被标注的注解”可以出现在哪些位置上。</p>
<br>

<p><code>@Target(ElementType.METHOD)</code>:表示“被标注的注解只能出现在方法上</p>
</li>
<li><p>关于Retention注解</p>
<p>这个一个元注解，用来标注“注解类型”的“注解”</p>
<p>这个Retention注解用来标注“被标注的注解”最终保存在哪里。</p>
<br>

<p><code>@RetentionA(RetentionPolicy.SOURCE)</code>:表示该注解只能被保留在java源文件中。</p>
<p><code>@RetentionA(RetentionPolicy.CLASS)</code>:表示该注解被保存在class文件中。</p>
<p><code>@RetentionA(RetentionPolicy.RUNTIME)</code>:表示该注解被保存在class文件中，并且可以被反射机制所读取。</p>
</li>
</ul>
<p><br><br><br><br></p>
<h3 id="反射注解，获取注解里的属性值"><a href="#反射注解，获取注解里的属性值" class="headerlink" title="反射注解，获取注解里的属性值"></a>反射注解，获取注解里的属性值</h3><ul>
<li><p>有三个类</p>
</li>
<li><p>MyAnnotation.java【注解】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ReflectAnnotationTest;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只允许注解可以标注类和方法</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="comment">//希望这个注解可以被反射</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;宁波江东区&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    username属性</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    String <span class="title function_">username</span><span class="params">()</span>;</span><br><span class="line">  </span><br><span class="line">    String <span class="title function_">password</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>MyAnnotationTest.java【里面包含注解的java类】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ReflectAnnotationTest;</span><br><span class="line">  <span class="meta">@MyAnnotation(username = &quot;admin&quot;,password = &quot;123&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAnnotationTest</span> &#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ReflectAnnotation.java【用于测试】【所有需要了解的代码都在这里】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">package</span> ReflectAnnotationTest;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectAnnotation</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">          <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;ReflectAnnotationTest.MyAnnotationTest&quot;</span>);</span><br><span class="line">  </span><br><span class="line">          <span class="comment">//判断类上面是否有@MyAnnotation</span></span><br><span class="line">  <span class="comment">//        System.out.println(c.isAnnotationPresent(MyAnnotation.class));</span></span><br><span class="line">          <span class="keyword">if</span> (c.isAnnotationPresent(MyAnnotation.class)) &#123;</span><br><span class="line">              <span class="comment">//获取该注解对象</span></span><br><span class="line">              <span class="type">MyAnnotation</span> <span class="variable">myAnnotation</span> <span class="operator">=</span> (MyAnnotation) c.getAnnotation(MyAnnotation.class);</span><br><span class="line">              System.out.println(<span class="string">&quot;类上面的注解对象&quot;</span> + myAnnotation);</span><br><span class="line">              System.out.println(myAnnotation.username());</span><br><span class="line">              System.out.println(myAnnotation.password());</span><br><span class="line">  </span><br><span class="line">              <span class="comment">//获取注解对象的属性怎么办？和调接口没区别。</span></span><br><span class="line">              <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> myAnnotation.value();</span><br><span class="line">              System.out.println(value);</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><br><br><br><br></p>
</li>
</ul>
<h3 id="注解在开发中有什么用呢？"><a href="#注解在开发中有什么用呢？" class="headerlink" title="注解在开发中有什么用呢？"></a>注解在开发中有什么用呢？</h3><p>需求：</p>
<ul>
<li><p>假设有这丫昂的一个注解，叫做：@ID</p>
<ul>
<li>这个注解只能出现在类上面，当这个类上有这个注解的时候要求这个类中必须有一个int类型的id属性，如果没有这个属性就报异常，如果有这个属性则正常执行！</li>
</ul>
<p>答案</p>
<ul>
<li><p>ID.java【注解】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">package</span> AnnotationHomework;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line">  <span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line">  <span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line">  <span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line">  <span class="comment">//表示这个注解只能出现在类上面</span></span><br><span class="line">  <span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line">  <span class="comment">//该注解可以被反射机制读取到</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="meta">@interface</span> ID &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//这个注解@ID用来标注类，被标注的类中必须又一个int类型的id属性，没有的话就报异常</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>User.java【定义类，要求有int类型的id属性】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> AnnotationHomework;</span><br><span class="line"><span class="meta">@ID</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="type">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">  String password;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Test.java【测试类，使用了反射注解】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">package</span> AnnotationHomework;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  </span><br><span class="line">          <span class="comment">//获取类</span></span><br><span class="line">          <span class="type">Class</span> <span class="variable">userClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;AnnotationHomework.User&quot;</span>);</span><br><span class="line">          <span class="comment">//判断类上是否存在ID注解</span></span><br><span class="line">          <span class="type">boolean</span> <span class="variable">isOk</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">if</span>(userClass.isAnnotationPresent(ID.class))&#123;</span><br><span class="line">              <span class="comment">//当一个类上面有@ID注解的时候吗，要求类中必须存在int类型的id属性</span></span><br><span class="line">              <span class="comment">//如果没有int类型的id属性则报异常</span></span><br><span class="line">              <span class="comment">//获取类的属性</span></span><br><span class="line">              Field[] fields = userClass.getDeclaredFields();</span><br><span class="line">  </span><br><span class="line">              <span class="keyword">for</span> (Field field:fields)&#123;</span><br><span class="line">                  <span class="keyword">if</span> (<span class="string">&quot;id&quot;</span>.equals(field.getName())&amp;&amp;<span class="string">&quot;int&quot;</span>.equals(field.getType().getSimpleName()))&#123;</span><br><span class="line">                      <span class="comment">//表示这个类是合法的类。有@ID注解，则这个类必须有int类型的id</span></span><br><span class="line">                      isOk = <span class="literal">true</span>;</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (!isOk)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">HasnotIDPropertyException</span>(<span class="string">&quot;被@ID注解标注的类必须要有一个int类型的id属性！&quot;</span>);</span><br><span class="line">              &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>AnnotationHomework.java【自定义异常类】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> AnnotationHomework;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">自定义异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HasnotIDPropertyException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HasnotIDPropertyException</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HasnotIDPropertyException</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://lcdzzz.github.io">lcdzzz</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://lcdzzz.github.io/2021/07/04/java%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/">http://lcdzzz.github.io/2021/07/04/java%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://lcdzzz.github.io" target="_blank">布鲁成周勒的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%8E%9F%E5%88%9B/">原创</a><a class="post-meta__tags" href="/tags/java%E5%9F%BA%E7%A1%80/">java基础</a></div><div class="post-share"><div class="social-share" data-image="https://images.wallpaperscraft.com/image/single/lawn_forest_mountains_144578_300x168.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2021/07/04/java%E8%AF%AD%E6%B3%95%E9%9A%8F%E8%AE%B0/" title="java语法随记"><img class="cover" src="https://images.wallpaperscraft.com/image/single/pyramids_starry_sky_night_161840_300x168.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">java语法随记</div></div><div class="info-2"><div class="info-item-1">java.math.BigDecimal的用法 BigDecimal类型用来存储金额等有小数，需要精度的数据  BigDecimal不能直接使用int类型赋值！  两种使BigDecimal初始化为0的方法:BigDecimal a&#x3D;BigDecimalBigDecimal b&#x3D;new BigDecimal(0);BigDecimal a &#x3D; in.nextBigDecimal();  除法运算：  ​      System.out.println(new BigDecimal(153.5).divide(new BigDecimal(100), 2, BigDecimal.ROUND_HALF_UP)); 　  &#x2F;&#x2F;new BigDecimal(100)除数，2精确的位数，BigDecimal.ROUND_HALF_UP：舍入模式  加法运算： System.out.println(new BigDecimal(&quot;2.005&quot;).add(new BigDecimal(&quot;0.03&quot;)));...</div></div></div></a><a class="pagination-related" href="/2021/07/04/%E8%A7%A3%E5%86%B3%20java%20%E2%80%9C%E9%94%99%E8%AF%AF%EF%BC%9A%E7%BC%96%E7%A0%81GBK%20%E7%9A%84%E4%B8%8D%E5%8F%AF%E6%98%A0%E5%B0%84%E5%AD%97%E7%AC%A6%E2%80%9D/" title="解决 java “错误：编码GBK 的不可映射字符”"><img class="cover" src="https://images.wallpaperscraft.com/image/single/mclaren_p1_minimalism_art_98755_300x168.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">解决 java “错误：编码GBK 的不可映射字符”</div></div><div class="info-2"><div class="info-item-1">解决 java “错误：编码GBK 的不可映射字符” 当java程序在idea上可以执行，但在cmd时报错：编码GBK 的不可映射字符时，通常都是因为GB2312编码的问题。  比如这个程序。在idea上运行时不会有问题的。用cmd运行时问题就出在第10行的int xd =0//向导数上，其中的“向导数”出了问题。   123456789101112131415161718192021222324252627Scanner in = new Scanner(System.in);while (in.hasNext()) &#123;   int line = in.nextInt();    while (line-- &gt; 0) &#123;        int n = in.nextInt();//人数        int xd = 0;//向导数        int qx = n / 2;//抢险        int yl =(n-qx) *2 / 3;//医疗        int tx = n-qx - yl;//通讯        if (qx % 10 ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2022/05/15/2022%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/" title="2022操作系统复习"><img class="cover" src="https://img1.baidu.com/it/u=3338944306,761302638&fm=253&fmt=auto&app=138&f=JPEG?w=200&h=200" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-15</div><div class="info-item-2">2022操作系统复习</div></div><div class="info-2"><div class="info-item-1">操作系统引论定义 os是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充 主要作用提高利用率并为用户和应用程序提供一个简单的接口，便于用户使用 大量的应用软件，都直接依赖于操作系统的支持，取得它所提供的服务  os的目标 方便性 有效性 可扩充性 开放性  os的作用 作为用户和计算机硬件系统之间的接口 作为计算机系统资源的管理者，资源分为【处理机、存储器、IO设备、文件（数据和程序）】 实现了对计算机资源的抽象  操作系统的特征基本特征 并发 共享 虚拟 异步  主要功能处理机管理功能 进程控制 进程同步 进程通信 调度  存储器管理功能 内存分配 内存保护 地址映射 内存扩充  设备管理功能 缓冲管理 设备分配 设备处理  文件管理功能 文件存储空间管理 目录管理 文件读写管理和保护  os和用户之间的接口 用户接口 程序接口  进程的描述和控制程序顺序执行时的特征  顺序性 封闭性 可再现性  并发执行的特征  间断性 失去封闭性 不可再现性  进程和程序的区别   进程 程序    动态 静态   是程序的执行 是有序代码的集合   独立的运行单位，能与其他的进程并...</div></div></div></a><a class="pagination-related" href="/2022/11/05/hexo-%E5%8D%9A%E5%AE%A2%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B-%E8%83%8E%E6%95%99%E7%BA%A7/" title="hexo 博客安装教程 胎教级"><img class="cover" src="https://img1.baidu.com/it/u=3383539873,3601029117&fm=253&fmt=auto&app=138&f=JPEG?w=1920&h=460" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-05</div><div class="info-item-2">hexo 博客安装教程 胎教级</div></div><div class="info-2"><div class="info-item-1">环境准备安装git到 GitHub 的页面上下载 exe 安装文件并运行： 安装包下载地址 详细可看：(6条消息) Git 详细安装教程（详解 Git 安装过程的每一个步骤）_mukes的博客-CSDN博客_git安装    .ebulseweexyg{width:70%}   安装Nodejs下载链接：下载 | Node.js 中文网 (nodejs.cn)    .lnqkxotkpmrx{width:70%}   详细可看：Node.js 安装配置 | 菜鸟教程 (runoob.com) 最后通过cmd 输入node --version 检测是否安装完成，只要有输出就行，不管版本号是多少    .tbhfcpyanifl{width:70%}   查看是否安装成功： 在桌面鼠标右键点击git bash here或者打开电脑CMD，依次输入以下指令 12node -v	#查看node版本npm -v	#查看npm版本     .vrhowcxftmmg{width:70%}   显示如上即成功 安装淘宝的cnpm 管理器1npm install -g cnpm --regis...</div></div></div></a><a class="pagination-related" href="/2022/11/03/SprngSecurity%E5%AE%9E%E6%88%98%E5%AE%9E%E4%BE%8B%EF%BC%8CJWT%20Token%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81&%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/" title="SprngSecurity实战实例，JWT Token登录认证&amp;权限控制"><img class="cover" src="https://img2.baidu.com/it/u=924906505,2741718824&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=250" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-03</div><div class="info-item-2">SprngSecurity实战实例，JWT Token登录认证&amp;权限控制</div></div><div class="info-2"><div class="info-item-1"> 这个在暑假就写过，上学以后重新再去写一遍发现困难比较多，于是准备写一篇记录一下。 tips: 源码在文章末尾，sql文件在源码resource文件夹下的sql文件夹里   需求想用springsecurity实现JWT Token登录认证，实现动态菜单生成，权限控制，登出（用户注销）。 认证准备工作 maven依赖 1234567891011121314151617181920212223242526     &lt;dependency&gt;         &lt;groupId&gt;com.alibaba&lt;/groupId&gt;         &lt;artifactId&gt;fastjson&lt;/artifactId&gt;         &lt;version&gt;1.2.47&lt;/version&gt;     &lt;/dependency&gt;&lt;dependency&gt;         &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;         &lt;artifact...</div></div></div></a><a class="pagination-related" href="/2022/10/19/%E5%85%B3%E4%BA%8Ejava%E7%9A%84Calendar%E7%B1%BB%E7%9A%84bug/" title="关于java的Calendar类的bug"><img class="cover" src="https://img2.baidu.com/it/u=1334167515,3225602473&fm=253&fmt=auto&app=138&f=JPG?w=658&h=494" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-19</div><div class="info-item-2">关于java的Calendar类的bug</div></div><div class="info-2"><div class="info-item-1"> 这篇文章废话比较多，想看bug和本人的逆天操作的话，可以直接去看“解决办法”和“结论”部分  起源一切的一切都起源于软测这一道看似无比简单的题    .mqqhflquqhpp{width:70%}   简单来说就是输出20221019这样的格式，然后输出是星期几 错误的代码这是我最开始写的错误的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110import java.util.*;public class day &#123;    public static void main(String[] args) &#123;        Scanner in = new Scanne...</div></div></div></a><a class="pagination-related" href="/2022/02/07/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/" title="图书管理系统介绍"><img class="cover" src="https://images.wallpaperscraft.com/image/single/astronaut_spacesuit_reflection_144426_300x168.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-07</div><div class="info-item-2">图书管理系统介绍</div></div><div class="info-2"><div class="info-item-1">图书管理系统介绍简介项目地址：https://github.com/lcdzzz/springboot-library 对于github项目：https://github.com/jacklightChen/ManageBooks  的改造，这是原项目地址。 一个基于SpringBoot+Thymeleaf渲染的图书管理系统功能:  用户: a.预约图书 b.查看预约记录 c.还书 d.查看个人信息以及修改个人信息 管理员: a.添加图书 b.处理预约(借书) c.查看借阅记录另:1.当用户过了还书日期仍旧未还书时会发邮件通知（原）2.当有书被还时发邮件通知预约书的用户到图书馆进行借书（原）  在学习这个项目的过程中发现原项目的提供的sql文件并不完整，于是花了一些时间去完善了表结构，存储过程以及视图。 适用人群适合刚接触springboot不久的同学使用，因为几乎对每行代码都写上了注释，阅读起来会更舒适 使用技术   后端 …    核心框架 spring、springboot、mybatis   连接池 Alibaba Druid      前端 …    核心框架(轻量简洁...</div></div></div></a><a class="pagination-related" href="/2022/04/11/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Docker%EF%BC%8C%E5%AE%89%E8%A3%85java%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84docker/" title="如何使用Docker，安装java调试环境的docker"><img class="cover" src="https://bkimg.cdn.bcebos.com/pic/f703738da977391281957edbf0198618377ae2dd?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2UxODA=,g_7,xp_5,yp_5/format,f_auto" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-11</div><div class="info-item-2">如何使用Docker，安装java调试环境的docker</div></div><div class="info-2"><div class="info-item-1">Docker的安装 查看系统的内核 123[roo@www ~]$ uname -r3.10.0-1160.59.1.el7.x86_64     .mviiodzlmaqv{width:70%}        查看系统配置 1cat /etc/os-release     .kyqisakdzdpp{width:70%}        卸载旧的版本 123456789[root@www ~]# yum remove docker \                   docker-client \                   docker-client-latest \                   docker-common \                   docker-latest \                   docker-latest-logrotate \                   docker-logrotate \                   docker-engine     .csndwpdobyqq{wid...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">lcdzzz</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#IDEA%E4%BD%BF%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">IDEA使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA"><span class="toc-number">1.1.</span> <span class="toc-text">新建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EIDEA%E5%B7%A5%E5%85%B7%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.2.</span> <span class="toc-text">关于IDEA工具的快捷键以及一些简单的设置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E4%BD%93%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.2.1.</span> <span class="toc-text">字体设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">快捷方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#super%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.</span> <span class="toc-text">super关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.</span> <span class="toc-text">final关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88abstract%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">抽象类（abstract）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%EF%BC%88%E6%8E%A5%E5%8F%A3%E4%B9%9F%E6%98%AF%E4%B8%80%E7%A7%8D%E7%B1%BB%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">接口（接口也是一种类）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-number">5.1.</span> <span class="toc-text">接口的基础语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%9C%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">5.2.</span> <span class="toc-text">接口在开发中的作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9A"><span class="toc-number">6.</span> <span class="toc-text">类型和类型之间的关系：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">6.1.</span> <span class="toc-text">抽象类和接口有什么区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#package%E5%92%8Cimport%E6%9C%BA%E5%88%B6"><span class="toc-number">7.</span> <span class="toc-text">package和import机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#package"><span class="toc-number">7.1.</span> <span class="toc-text">package</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#import"><span class="toc-number">7.2.</span> <span class="toc-text">import</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90"><span class="toc-number">8.</span> <span class="toc-text">访问控制权限</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90%EF%BC%9F"><span class="toc-number">8.1.</span> <span class="toc-text">有哪些访问控制权限？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E4%B8%8A%E5%9B%9B%E7%A7%8D%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90%EF%BC%8C%E6%8E%A7%E5%88%B6%E7%9A%84%E8%8C%83%E5%9B%B4%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">8.2.</span> <span class="toc-text">以上四种访问控制权限，控制的范围是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%8F%AF%E4%BB%A5%E4%BF%AE%E9%A5%B0%E4%BB%80%E4%B9%88"><span class="toc-number">8.3.</span> <span class="toc-text">访问控制权限修饰符可以修饰什么</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK%E7%B1%BB%E5%BA%93%E7%9A%84%E6%A0%B9%E7%B1%BB%EF%BC%9AObject"><span class="toc-number">9.</span> <span class="toc-text">JDK类库的根类：Object</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Object%E7%B1%BB%E5%BD%93%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">9.1.</span> <span class="toc-text">Object类当中有哪些常用的方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toString-%E6%96%B9%E6%B3%95"><span class="toc-number">9.2.</span> <span class="toc-text">toString()方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#equals-%E6%96%B9%E6%B3%95"><span class="toc-number">9.3.</span> <span class="toc-text">equals()方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#finalize-%E6%96%B9%E6%B3%95"><span class="toc-number">9.4.</span> <span class="toc-text">finalize()方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashCode%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">9.5.</span> <span class="toc-text">hashCode方法：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%9A"><span class="toc-number">10.</span> <span class="toc-text">匿名内部类：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">11.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-JDK%E4%B8%AD%E5%86%85%E7%BD%AE%E7%9A%84%E4%B8%80%E4%B8%AA%E7%B1%BB%EF%BC%9Ajava-lang-String"><span class="toc-number">12.</span> <span class="toc-text">Java JDK中内置的一个类：java.lang.String</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EString%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">12.1.</span> <span class="toc-text">关于String类中的构造方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#String-%E7%B1%BB%E5%BD%93%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number"></span> <span class="toc-text">String 类当中常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#StringBuffer%E5%92%8CStringBulider"><span class="toc-number">1.</span> <span class="toc-text">StringBuffer和StringBulider</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuffer"><span class="toc-number">1.1.</span> <span class="toc-text">StringBuffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuilder%E5%92%8CStringBuffer%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">1.2.</span> <span class="toc-text">StringBuilder和StringBuffer的异同</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%96%B9%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">8种基本数据类型对应的包装类型及方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%90%8D%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E5%90%8D"><span class="toc-number">2.1.</span> <span class="toc-text">基本数据类型名对应的包装类型名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%86%E8%A3%85%E7%AE%B1%E5%8F%8A%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">拆装箱及方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK1-5%E4%BB%A5%E5%90%8E%EF%BC%8C%E6%94%AF%E6%8C%81%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1%EF%BC%9A"><span class="toc-number">2.3.</span> <span class="toc-text">JDK1.5以后，支持自动拆装箱：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%96%B9%E6%B3%95%E6%9D%83%E7%9B%8A%E4%B8%AD%E7%9A%84%E2%80%9C%E6%95%B4%E6%95%B0%E5%9E%8B%E5%B8%B8%E9%87%8F%E6%B1%A0%E2%80%9D"><span class="toc-number">3.</span> <span class="toc-text">关于方法权益中的“整数型常量池”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Integer%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">Integer常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-int-Integer%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2%EF%BC%9A"><span class="toc-number">5.</span> <span class="toc-text">String int Integer三种类型的互相转换：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%AF%B9%E6%97%A5%E6%9C%9F%E7%9A%84%E5%A4%84%E7%90%86%EF%BC%9A"><span class="toc-number">6.</span> <span class="toc-text">java对日期的处理：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#System%E7%B1%BB%E7%9A%84%E7%9B%B8%E5%85%B3%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">7.</span> <span class="toc-text">System类的相关属性和方法：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%95%B0%E5%AD%97%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">8.</span> <span class="toc-text">关于数字的格式化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BigDecimal"><span class="toc-number">9.</span> <span class="toc-text">BigDecimal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-number">10.</span> <span class="toc-text">随机数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%EF%BC%9A"><span class="toc-number">11.</span> <span class="toc-text">枚举：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">12.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%AF%B9%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E5%8C%85%E6%8B%AC%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">12.1.</span> <span class="toc-text">java语言中对异常的处理包括两种方式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5try-catch"><span class="toc-number">12.2.</span> <span class="toc-text">深入try..catch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E6%8A%A5%E5%92%8C%E6%8D%95%E6%8D%89%E7%9A%84%E9%80%89%E6%8B%A9%EF%BC%9A"><span class="toc-number">12.3.</span> <span class="toc-text">上报和捕捉的选择：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Etry-catch%E4%B8%AD%E7%9A%84fianlly%E5%AD%90%E5%8F%A5"><span class="toc-number">12.4.</span> <span class="toc-text">关于try..catch中的fianlly子句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E4%B8%AD%E4%BB%BB%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">12.5.</span> <span class="toc-text">java中任何自定义异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0"><span class="toc-number">13.</span> <span class="toc-text">集合概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Ejava-util-Collection%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">14.</span> <span class="toc-text">关于java.util.Collection接口中常用的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0%E7%9A%84remove"><span class="toc-number">14.1.</span> <span class="toc-text">关于集合元素的remove</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Ejava-util-list%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">15.</span> <span class="toc-text">关于java.util.list接口中常用的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList%E9%9B%86%E5%90%88%EF%BC%9A"><span class="toc-number">16.</span> <span class="toc-text">ArrayList集合：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%EF%BC%9A"><span class="toc-number">17.</span> <span class="toc-text">链表：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vector"><span class="toc-number">18.</span> <span class="toc-text">Vector</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">19.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF%EF%BC%9Aforeach"><span class="toc-number">20.</span> <span class="toc-text">增强for循环：foreach</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set%E4%B8%8B%E7%9A%84%E5%AD%90%E7%B1%BB"><span class="toc-number">21.</span> <span class="toc-text">Set下的子类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java-util-Map%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">22.</span> <span class="toc-text">java.util.Map接口中常用的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HshMap%E9%9B%86%E5%90%88"><span class="toc-number">23.</span> <span class="toc-text">HshMap集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E7%9A%84equals%E6%96%B9%E6%B3%95%E5%92%8ChashCode%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-number">23.1.</span> <span class="toc-text">HashMap的equals方法和hashCode方法重写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Properties%E7%B1%BB"><span class="toc-number">24.</span> <span class="toc-text">Properties类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TreeSet%E5%92%8CTreeMap"><span class="toc-number">25.</span> <span class="toc-text">TreeSet和TreeMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EFileOutputStream"><span class="toc-number">26.</span> <span class="toc-text">关于FileOutputStream</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-number">27.</span> <span class="toc-text">文件的复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java-io-File%E7%B1%BB"><span class="toc-number">28.</span> <span class="toc-text">java.io.File类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">28.1.</span> <span class="toc-text">关于序列化和反序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%BA%8F%E5%88%97%E5%8C%96%E9%9B%86%E5%90%88%EF%BC%89%E5%B9%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">28.2.</span> <span class="toc-text">序列化多个对象（序列化集合）并反序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#transient%E5%85%B3%E9%94%AE%E5%AD%97%E8%A1%A8%E7%A4%BA%E6%9C%89%E5%8A%9B%E7%9A%84%EF%BC%8C%E4%B8%8D%E5%8F%82%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">28.3.</span> <span class="toc-text">transient关键字表示有力的，不参与序列化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO-Properties%E7%9A%84%E8%81%94%E5%90%88%E5%BA%94%E7%94%A8"><span class="toc-number">29.</span> <span class="toc-text">IO+Properties的联合应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">30.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">30.1.</span> <span class="toc-text">实现线程的两种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%8D%E5%AD%97"><span class="toc-number">30.2.</span> <span class="toc-text">获取线程对象的名字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84sleep%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">31.</span> <span class="toc-text">关于线程的sleep方法：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E6%96%AD%E7%9D%A1%E7%9C%A0"><span class="toc-number">31.1.</span> <span class="toc-text">终断睡眠</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E4%B8%AD%E6%80%8E%E4%B9%88%E5%90%88%E7%90%86%E7%BB%88%E6%AD%A2%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="toc-number">31.2.</span> <span class="toc-text">java中怎么合理终止一个线程的执行</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%91%A2%EF%BC%9F"><span class="toc-number">32.</span> <span class="toc-text">怎么解决线程的安全问题呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E4%B8%AD%E6%9C%89%E4%B8%89%E5%A4%A7%E5%8F%98%E9%87%8F"><span class="toc-number">32.1.</span> <span class="toc-text">java中有三大变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">32.2.</span> <span class="toc-text">在开发中怎么解决线程安全问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E6%9C%89%E4%B8%89%E7%A7%8D%E7%94%A8%E6%B3%95%EF%BC%9A"><span class="toc-number">32.3.</span> <span class="toc-text">synchronized有三种用法：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">33.</span> <span class="toc-text">守护线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">34.</span> <span class="toc-text">定时器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AC%AC%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%8C%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3%E3%80%82%EF%BC%88JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E3%80%82%EF%BC%89"><span class="toc-number">35.</span> <span class="toc-text">实现线程的第三种方法，实现Callable接口。（JDK8新特性。）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EObject%E7%B1%BB%E4%B8%AD%E7%9A%84wait%E5%92%8Cnotify%E6%96%B9%E6%B3%95%EF%BC%88%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%81%EF%BC%89"><span class="toc-number">36.</span> <span class="toc-text">关于Object类中的wait和notify方法（生产者和消费者模式！）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="toc-number">37.</span> <span class="toc-text">反射机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E6%93%8D%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%8C%E9%9C%80%E8%A6%81%E9%A6%96%E5%85%88%E8%8E%B7%E5%8F%96%E5%88%B0%E8%BF%99%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%8C%E6%80%8E%E4%B9%88%E8%8E%B7%E5%8F%96java-lang-Class%E5%AE%9E%E4%BE%8B%EF%BC%9F"><span class="toc-number">37.1.</span> <span class="toc-text">要操作一个类的字节码，需要首先获取到这个类的字节码，怎么获取java.lang.Class实例？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%88%B0Class%EF%BC%8C%E8%83%BD%E5%B9%B2%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">37.2.</span> <span class="toc-text">获取到Class，能干什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%9A%84%E7%81%B5%E6%B4%BB%E6%80%A7"><span class="toc-number">37.3.</span> <span class="toc-text">验证反射机制的灵活性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%EF%BC%9AClass-foeName-%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">37.4.</span> <span class="toc-text">研究一下：Class.foeName()发生了什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">38.</span> <span class="toc-text">研究一下文件路径的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96field%EF%BC%88%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%EF%BC%89"><span class="toc-number">39.</span> <span class="toc-text">获取field（了解一下）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E7%BC%96%E8%AF%91Field%EF%BC%88%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%EF%BC%89"><span class="toc-number">40.</span> <span class="toc-text">反编译Field（了解一下）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7"><span class="toc-number">41.</span> <span class="toc-text">通过反射机制访问对象属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E9%95%BF%E5%BA%A6%E5%8F%82%E6%95%B0%EF%BC%88%E6%8E%8C%E6%8F%A1"><span class="toc-number">42.</span> <span class="toc-text">可变长度参数（掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84Method%EF%BC%88%E4%BA%86%E8%A7%A3%E5%86%85%E5%AE%B9%EF%BC%89"><span class="toc-number">43.</span> <span class="toc-text">反射Method（了解内容）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E7%BC%96%E8%AF%91Method%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">44.</span> <span class="toc-text">反编译Method一个类的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%EF%BC%9A%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E6%80%8E%E4%B9%88%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">45.</span> <span class="toc-text">重点：通过反射机制怎么调用一个对象的方法* * * * *</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E7%BC%96%E8%AF%91%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84Constructor%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">46.</span> <span class="toc-text">反编译一个类的Constructor构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6new%E5%AF%B9%E8%B1%A1%EF%BC%88%E6%AF%94%E4%B8%8A%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90%E9%87%8D%E8%A6%81%E4%B8%80%E4%BA%9B%EF%BC%89%EF%BC%88%E4%BD%86%E4%B9%9F%E4%B8%8D%E6%98%AF%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">47.</span> <span class="toc-text">通过反射机制new对象（比上一个例子重要一些）（但也不是重点）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%88%B6%E7%B1%BB%E5%92%8C%E7%88%B6%E6%8E%A5%E5%8F%A3"><span class="toc-number">48.</span> <span class="toc-text">获取父类和父接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">49.</span> <span class="toc-text">注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-number">49.1.</span> <span class="toc-text">元注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%B3%A8%E8%A7%A3%EF%BC%8C%E8%8E%B7%E5%8F%96%E6%B3%A8%E8%A7%A3%E9%87%8C%E7%9A%84%E5%B1%9E%E6%80%A7%E5%80%BC"><span class="toc-number">49.2.</span> <span class="toc-text">反射注解，获取注解里的属性值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E5%9C%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%E5%91%A2%EF%BC%9F"><span class="toc-number">49.3.</span> <span class="toc-text">注解在开发中有什么用呢？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/07/31/windows%E3%81%AEwsl%E5%AE%89%E8%A3%85centos/" title="windowsのwsl安装centos"><img src="https://img0.baidu.com/it/u=4198488413,3086794076&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=501&amp;h=500" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="windowsのwsl安装centos"/></a><div class="content"><a class="title" href="/2025/07/31/windows%E3%81%AEwsl%E5%AE%89%E8%A3%85centos/" title="windowsのwsl安装centos">windowsのwsl安装centos</a><time datetime="2025-07-30T16:25:54.000Z" title="发表于 2025-07-31 00:25:54">2025-07-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/23/GaussDB%E5%AE%89%E8%A3%85%E5%8F%8A%E5%BA%94%E7%94%A8/" title="GaussDB安装及应用"><img src="https://img2.baidu.com/it/u=1042180318,3822666887&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=565&amp;h=330" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GaussDB安装及应用"/></a><div class="content"><a class="title" href="/2024/11/23/GaussDB%E5%AE%89%E8%A3%85%E5%8F%8A%E5%BA%94%E7%94%A8/" title="GaussDB安装及应用">GaussDB安装及应用</a><time datetime="2024-11-23T14:52:15.000Z" title="发表于 2024-11-23 22:52:15">2024-11-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/30/prometheus-consul-blackboxTest/" title="prometheus&amp;consul&amp;blackboxTest"><img src="https://lcdzzz.github.io/2022/05/11/pictures/prometheus.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="prometheus&amp;consul&amp;blackboxTest"/></a><div class="content"><a class="title" href="/2024/09/30/prometheus-consul-blackboxTest/" title="prometheus&amp;consul&amp;blackboxTest">prometheus&amp;consul&amp;blackboxTest</a><time datetime="2024-09-30T09:03:24.000Z" title="发表于 2024-09-30 17:03:24">2024-09-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/20/hadoop%E4%B8%8Ehive%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/" title="hadoop与hive的安装和配置"><img src="https://img2.baidu.com/it/u=3645694001,4033166664&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=300&amp;h=248" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="hadoop与hive的安装和配置"/></a><div class="content"><a class="title" href="/2024/06/20/hadoop%E4%B8%8Ehive%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/" title="hadoop与hive的安装和配置">hadoop与hive的安装和配置</a><time datetime="2024-06-20T10:00:09.000Z" title="发表于 2024-06-20 18:00:09">2024-06-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/05/Docker%E7%AC%94%E8%AE%B0/" title="Docker笔记"><img src="https://img2.baidu.com/it/u=346135644,1115136735&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=281" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker笔记"/></a><div class="content"><a class="title" href="/2024/06/05/Docker%E7%AC%94%E8%AE%B0/" title="Docker笔记">Docker笔记</a><time datetime="2024-06-05T03:13:46.000Z" title="发表于 2024-06-05 11:13:46">2024-06-05</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2020 - 2025 By lcdzzz</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>